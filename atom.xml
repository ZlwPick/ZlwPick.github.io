<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zlwblog</title>
  
  <subtitle>zlwblog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-04T14:51:40.774Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zlw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 994.Rotting Oranges</title>
    <link href="http://yoursite.com/2020/03/04/LeetCode-994-Rotting-Oranges/"/>
    <id>http://yoursite.com/2020/03/04/LeetCode-994-Rotting-Oranges/</id>
    <published>2020-03-04T14:44:12.000Z</published>
    <updated>2020-03-04T14:51:40.774Z</updated>
    
    <content type="html"><![CDATA[<p>经典的bfs 题目,我的入门题目</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//方向坐标</span></span><br><span class="line">        <span class="hljs-keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;</span><br><span class="line">        <span class="hljs-keyword">int</span> day = -<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</span><br><span class="line">        Deque&lt;<span class="hljs-keyword">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="hljs-comment">//记录橘子数目(不论好坏)</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(grid[i][j] != <span class="hljs-number">0</span>)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">//找到第一个坏的橘子并将它的坐标设置入队</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)&#123;</span><br><span class="line">                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//deque队列的最后一个元素(但不删除)。返回null如果此deque队列为空。</span></span><br><span class="line">        <span class="hljs-keyword">int</span>[] flag = deque.peekLast();</span><br><span class="line">        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="hljs-comment">//出队 将之前入队的 坏橘子的 x y 坐标取出来</span></span><br><span class="line">            <span class="hljs-keyword">int</span>[] loc = deque.poll();</span><br><span class="line">            --count;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k =<span class="hljs-number">0</span>;k &lt; <span class="hljs-number">4</span>;++k)&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> x = loc[<span class="hljs-number">0</span>] + delta[k][<span class="hljs-number">0</span>];</span><br><span class="line">                <span class="hljs-keyword">int</span> y = loc[<span class="hljs-number">1</span>] + delta[k][<span class="hljs-number">1</span>];</span><br><span class="line">                <span class="hljs-comment">//判断当前的下标是否越界   周围的单元格是白色 和 已经是坏橘子 的就 </span></span><br><span class="line">                <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>|| x == m || y &lt; <span class="hljs-number">0</span> || y == n ||grid[x][y] == <span class="hljs-number">0</span> || grid[x][y] == <span class="hljs-number">2</span>)</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">                <span class="hljs-comment">//将好橘子 变成 坏橘子 并将坐标 入队</span></span><br><span class="line">                grid[x][y] = <span class="hljs-number">2</span>;</span><br><span class="line">                deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x,y&#125;);  </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(loc[<span class="hljs-number">0</span>] == flag[<span class="hljs-number">0</span>] &amp;&amp; loc[<span class="hljs-number">1</span>] == flag[<span class="hljs-number">1</span>])&#123;</span><br><span class="line">                ++day;</span><br><span class="line">                flag = deque.peekLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> count &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : Math.max(day,<span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经典的bfs 题目,我的入门题目&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA算法中笔记</title>
    <link href="http://yoursite.com/2020/03/02/JAVA%E7%AE%97%E6%B3%95%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/02/JAVA算法中笔记/</id>
    <published>2020-03-02T15:02:09.000Z</published>
    <updated>2020-03-02T15:15:54.550Z</updated>
    
    <content type="html"><![CDATA[<p>最近写算法时,遇到的一些问题,及其优化都总结在此篇.</p><a id="more"></a><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = new Scanner (System.in);//基本方法</span><br><span class="line">Scanner in = new Scanner (new BufferedInputStream(System.in));//更快</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));//使用缓存加速，比直接使用System.out快</span><br><span class="line">out.println(n); </span><br><span class="line">out.printf(&quot;%.2f\n&quot;, ans); // 与c语言中printf用法相同</span><br></pre></td></tr></table></figure><h1 id="大数据与高精度"><a href="#大数据与高精度" class="headerlink" title="大数据与高精度"></a>大数据与高精度</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.math.BigInteger; </span><br><span class="line">//主要有以下方法可以使用： </span><br><span class="line">BigInteger add(BigInteger other) </span><br><span class="line">BigInteger subtract(BigInteger other) </span><br><span class="line">BigInteger multiply(BigInteger other) </span><br><span class="line">BigInteger divide(BigInteger other)</span><br><span class="line">BigInteger [] dividedandRemainder(BigInteger other) //数组第一位是商，第二位是余数</span><br><span class="line">BigInteger pow(int other)// other次方</span><br><span class="line">BigInteger mod(BigInteger other) </span><br><span class="line">BigInteger gcd(BigInteger other) </span><br><span class="line">int compareTo(BigInteger other) //负数则小于,0则等于,正数则大于</span><br><span class="line">static BigInteger valueOf(long x)</span><br><span class="line">//输出数字时直接使用 System.out.println(a) 即可</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal add(BigDecimal other)</span><br><span class="line">BigDecimal subtract(BigDecimal other)</span><br><span class="line">BigDecimal multiply(BigDecimal other)</span><br><span class="line">BigDecimal divide(BigDecimal other)</span><br><span class="line">BigDecimal divide(BigDecimal divisor, int scale, BigDecimal.ROUND_HALF_UP)//除数，保留小数位数，保留方法四舍五入</span><br><span class="line">BigDecimal.setScale()方法用于格式化小数点 //setScale(1)表示保留一位小数，默认用四舍五入方式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写算法时,遇到的一些问题,及其优化都总结在此篇.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis 笔记1</title>
    <link href="http://yoursite.com/2020/02/26/Redis-%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2020/02/26/Redis-笔记1/</id>
    <published>2020-02-26T13:52:09.000Z</published>
    <updated>2020-02-29T04:28:14.613Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是完全开源免费的,遵守BSD协议,是一个高性能(NoSQL)的key-value数据库</p><a id="more"></a><p>NOSQL 与 SQL<br>数据与数据之间没有关联关系<br>表与表之间建立关联关系<br>NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战,尤其是大数据应用的难题.</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1.性能极高 读写速度快<br>2.丰富的数据类型<br>3.原子性<br>4.丰富的特性</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>wget <a href="http://download.redis.io/releases/redis-4.0.6.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.6.tar.gz</a></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>tar -zxvf</p><h2 id="yum安装gcc依赖"><a href="#yum安装gcc依赖" class="headerlink" title="yum安装gcc依赖"></a>yum安装gcc依赖</h2><p>yum install gcc</p><h2 id="跳转到redis解压目录下"><a href="#跳转到redis解压目录下" class="headerlink" title="跳转到redis解压目录下"></a>跳转到redis解压目录下</h2><p>cd redis-4.0.6</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>make MALLOC=libc<br>cd src &amp;&amp; make install</p><h1 id="redis-conf-配置文件详解"><a href="#redis-conf-配置文件详解" class="headerlink" title="redis.conf 配置文件详解"></a>redis.conf 配置文件详解</h1><table><thead><tr><th align="center">指令</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">daemonize no</td><td align="center">Redis默认不是以守护进程的方式运行,可以通过该配置项修改,使用yes 启用守护进程</td></tr><tr><td align="center">pidfile /var/run/redis_6379.pid</td><td align="center">pid 文件的路径</td></tr><tr><td align="center">port 6379</td><td align="center">端口号</td></tr><tr><td align="center">bind 127.0.01</td><td align="center">绑定主机地址(本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接，)</td></tr><tr><td align="center">timeout 300</td><td align="center">客户端闲置多久后关闭连接(0 表示关闭这个功能)</td></tr><tr><td align="center">loglevel verbose</td><td align="center">指定日志记录级别 (debug、verbose、notice、warning)</td></tr><tr><td align="center">logfile stdout</td><td align="center">日志记录方式,默认标准输出,如果Redis为守护进程方式运行,而这里又配置为日志记录方式为标准输出,则日志发送/dev/null</td></tr><tr><td align="center">databases 16</td><td align="center">设置数据库的数量</td></tr><tr><td align="center">save 900 1 (15分钟内有1个更改)save 300 10 (5分钟内有10个更改)save 60 10000 (60秒内有10000个更改)</td><td align="center">指定在多长时间内,有多少次更新操作,就将数据同步到数据文件,可以多个条件配合 save<seconds><changes></changes></seconds></td></tr><tr><td align="center">rdbcompression yes</td><td align="center">指定存储本地数据库时是否压缩数据</td></tr><tr><td align="center">dbfilename dump.rdb</td><td align="center">指定本地数据库文件名,默认值为 dump.rdb,在bin中</td></tr><tr><td align="center">dir ./</td><td align="center">指定本地数据库存放目录</td></tr><tr><td align="center">requirepass foobared</td><td align="center">设置Redis连接密码,如果配置了连接密码,客户端在连接Redis 时需要通过AUTH<password>命令提供密码,默认关闭</password></td></tr><tr><td align="center">maxclients 128</td><td align="center">设置同一时间最大客户端连接数:默认无限制</td></tr><tr><td align="center">maxmemory<bytes></bytes></td><td align="center">指定Redis最大内存限制</td></tr></tbody></table><p>redis作为优秀的中间缓存件,时常会存储大量的数据,即使采取了集群部署来动态扩容,也应该即时的整理内存,维持系统性能(如果数据一直新增,内存很快就会满)<br>有以下两种解决方案:<br>1.为数据设置超时时间,<br>设定内存空间,建议不要超过1G 256-512M<br>2.采用LRU 算法动态将不要的数据删除</p><p>redis-cli -h host -p port -a password<br>(ip地址) (端口号) (密码)</p><p>1.断电,非正常关闭,容易丢失数据<br>kill</p><p>2.正常关闭,数据保存<br>shutdown</p><h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h1><h2 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键 key"></a>Redis 键 key</h2><table><thead><tr><th align="center">指令</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">DEL key</td><td align="center">删除key的值</td></tr><tr><td align="center">dump key</td><td align="center">序列化给定key,并返回序列化的值</td></tr><tr><td align="center">exists key</td><td align="center">检查key 是否存在</td></tr><tr><td align="center">expire key seconds</td><td align="center">为给定key 设置过期时间(以秒计)</td></tr><tr><td align="center">ttl key</td><td align="center">以秒为单位,返回给定key的剩余生存时间</td></tr><tr><td align="center">pttl key *(毫秒)</td><td align="center">以毫秒为单位</td></tr><tr><td align="center">persist key</td><td align="center">移除过期时间(永久保持)</td></tr><tr><td align="center">keys pattern</td><td align="center">查找所有符合给定模式(pattern) 的key *所有 ?代表一个字符</td></tr><tr><td align="center">randomkey</td><td align="center">随机 key</td></tr><tr><td align="center">rename key newkey</td><td align="center">修改key名</td></tr><tr><td align="center">move key db</td><td align="center">当前数据库的key移动到给定数据库中</td></tr><tr><td align="center">type key</td><td align="center">返回key所储存的值的类型</td></tr><tr><td align="center">set key value</td><td align="center">有值就覆盖</td></tr><tr><td align="center">setnx key value</td><td align="center">如果key不存在,进行赋值,存在不赋值</td></tr><tr><td align="center">get key</td><td align="center">取值</td></tr><tr><td align="center">getrange key start end</td><td align="center">取字符串中start 到 end 范围的字符</td></tr><tr><td align="center">getbit key offset</td><td align="center">取指定偏移量上的位</td></tr><tr><td align="center">mget key1 key2…</td><td align="center">获取一个或者多个key</td></tr></tbody></table><h2 id="key-命名规范"><a href="#key-命名规范" class="headerlink" title="key 命名规范"></a>key 命名规范</h2><p>redis 单个 key 存入512M大小<br>1.key不要太长,不要超过1024字节<br>2.key不要太短,key可读性会降低<br>3.key最好使用统一的命名模式. user:123:password;</p><h2 id="Hash-命令"><a href="#Hash-命令" class="headerlink" title="Hash 命令"></a>Hash 命令</h2><p>赋值语法：</p><table><thead><tr><th align="center">指令</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">HSET KEY FIELD VALUE</td><td align="center">单个hash</td></tr><tr><td align="center">HMSET KET FIELD1 VALUE1 [FIELD2 VALUE2]</td><td align="center">多个hash</td></tr><tr><td align="center">hmset users uname zlw age 20 address “荆门市”</td><td align="center"></td></tr></tbody></table><p>取值语法</p><table><thead><tr><th align="center">指令</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">HGET KEY FIELD</td><td align="center">单个</td></tr><tr><td align="center">HGET KEY FIELD [FIELD1]</td><td align="center">多个</td></tr><tr><td align="center">HGEALL key</td><td align="center">返回hash表中所以字段和值</td></tr><tr><td align="center">HKEYS KEY</td><td align="center">获取所有哈希表中的字段</td></tr><tr><td align="center">HLEN KEY</td><td align="center">获取hash表中字段长度</td></tr></tbody></table><p>删除语法</p><table><thead><tr><th align="center">指令</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">HDEL KEY FIELD1 [FIELD2]</td><td align="center">删除一个或者多个hash表字段</td></tr><tr><td align="center">hsetnx key field value</td><td align="center">只有在字段field不存在,设置哈希字段的值</td></tr><tr><td align="center">hincrby key field value</td><td align="center">指定字段的整形值加上增量increment</td></tr><tr><td align="center">hincrbyfloat</td><td align="center">浮点型</td></tr><tr><td align="center">hexists key field</td><td align="center">查看hash表中，指定的字段是否存在</td></tr></tbody></table><p>#<dependency><br><groupid>redis.clients</groupid><br><artifactid>jedis</artifactid><br><version>2.9.0</version><br></dependency></p><h1 id="Redis和spring-整合"><a href="#Redis和spring-整合" class="headerlink" title="Redis和spring 整合"></a>Redis和spring 整合</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是完全开源免费的,遵守BSD协议,是一个高性能(NoSQL)的key-value数据库&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装git和基本操作</title>
    <link href="http://yoursite.com/2020/02/25/CentOS-7-%E5%AE%89%E8%A3%85git%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/02/25/CentOS-7-安装git和基本操作/</id>
    <published>2020-02-25T03:52:02.000Z</published>
    <updated>2020-02-29T04:39:52.278Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><a id="more"></a><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="查看git版本"><a href="#查看git版本" class="headerlink" title="查看git版本"></a>查看git版本</h2><pre>git --versionyum remove git</pre><h2 id="安装所需软件包"><a href="#安装所需软件包" class="headerlink" title="安装所需软件包"></a>安装所需软件包</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br><span class="line">yum install gcc-c++ perl-ExtUtils-MakeMaker</span><br><span class="line">yum install install autoconf automake libtool</span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre>cd /usr/src$ wget https://www.kernel.org/pub/software/scm/git/git-2.7.3.tar.gz</pre><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><pre>tar xf git-2.7.3.tar.gz</pre><h2 id="配置-安装-编译"><a href="#配置-安装-编译" class="headerlink" title="配置 安装 编译"></a>配置 安装 编译</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd git-2.7.3</span><br><span class="line">make configure</span><br><span class="line">./configure --prefix=/usr/git ##配置目录</span><br><span class="line">make profix=/usr/git</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="加入环境变量"><a href="#加入环境变量" class="headerlink" title="加入环境变量"></a>加入环境变量</h2><pre>vim /etc/profilesource /etc/profile</pre><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><h1 id="基础操作指令"><a href="#基础操作指令" class="headerlink" title="基础操作指令"></a>基础操作指令</h1><p>1.创建git-test 仓库<br>git –bare init git-test<br>chown -R zlwgit:zlwgit /home/zlwgit/git-test/</p><p>客户端<br>git clone <a href="mailto:zlwgit@47.111.237.227" target="_blank" rel="noopener">zlwgit@47.111.237.227</a>:/home/zlwgit/git-test (这里输入名字就是在本地新建一个文件放)<br>将服务器端的git-test 仓库下到本地的目录下</p><p>git remote<br>显示本机所关联的远程仓库</p><p>cat .git/config 查看具体信息</p><p>将本地仓库中的分支推送到远端仓库并与远端分支进行合并<br>git push(第一次将本地的修改推送到服务器,此服务器端还不存在master分支,需要用这指令重新推送,git push &lt;远端仓库&gt;&lt;远端分支&gt;)</p><p>git pull</p><p>显示所有的本地分支<br>git branch</p><p>显示所以下载到本地的远端分支<br>git branch -r</p><p>查看状态(当远程仓库的代码与本地代码有冲突时可以查看冲突文件)<br>git status</p><p>查看版本树<br>gitk</p><p>查看提交历史<br>git log<br>git log -p (patch,输出补丁) 显示每一步的修改内容<br>git log –stat –Summary()<br>git show 21321cf686e09eba538f935242b8a57f2893e903 查看某个提交的具体内容<br>git show 2132<br>git show HEAD (当前分支中最后提交记录的标识符)<br>等同 git show master</p><h1 id="管理分支"><a href="#管理分支" class="headerlink" title="管理分支"></a>管理分支</h1><p>创建分支<br>git branch zz<br>git branch (*当前所在的分支)<br>git checkout zz (切换分支)</p><p>我们在zz 分支进行修改内容后,在进行提交,在切换到master分支后,查看修改的文件,<font color="red">发现我们在zz分支修改的内容不见了</font>,原因是我们刚才的修改是在zz分支上做的,而我们现在已经切换回了master分支了</p><p>两个分支产生了分歧,每个分支包含不同的修改.如果要将zz合并到master中执行以下指令即可:<br>git merge zz<br>没有冲突merge 会自动完成,有冲突则合并过程中会中断.<br>Auto-merging zlwgit.txt<br>CONFLICT (content): Merge conflict in zlwgit.txt<br>Automatic merge failed; fix conflicts and then commit the result.<br>然后我们手动修改冲突,然后在提交,系统会自动的生成提交提示信息.</p><h1 id="git对象数据库"><a href="#git对象数据库" class="headerlink" title="git对象数据库"></a>git对象数据库</h1><p>在git中,文件、目录、提交记录都被作为对象管理,</p><p>[master 65f5957] version 1.1 master<br>3 files changed, 3 insertions(+)<br>主要不发生冲突,可以用前导字符串标识这条提交,就是提交记录标识符的前导字符串,提交记录的标识符是居于本次提交所包含的所有文件的内容,父节点的标识符、系统实践、用户名等综合信息所生成的一个SHA1字符串,这可以保证git永远不会生成重复的提交记录标识符。<br>提交记录保存在<br>.git/objects/</p><p>tree 是65f5957bc1f018918a19a4fd0e468aa87f13b938这个对象的类型<br>因此得到一下结论与猜想：<br>1.在git中每一条提交记录都具有唯一的标识符<br>2.提交记录被作为二进制文件保存在.git/objects/目录下<br>3.git中有多种类型的对象<br>4.提交记录是git中的一种对象,他的类型是commit<br>5.每个对象都有唯一的SHA1字符串与之对应(猜想)<br>6.提交记录只包含最基本的信息,它的具体内容保存在一个tree类型的对象内()</p><p>git ls-tree 65f5<br>查看目录</p><p>git正是通过commit对象的parent属性将独立的commit对象关联起来,从而构成了分支的版本书</p><p>git cat-file blob 120e<br>查看文件</p><p>git中的tree对象对应提交的代码中的目录,blob对象对应提交的代码中的文件,tree对象可以包含blob对象(目录中的文件)和tree对象(目录中的子目录)</p><p>git hash-object &lt;文件&gt;<br>计算文件在git中的SHA1标识符(无论文件的名称如何修改,位于哪个目录下,只要文件的内容不变,他的SHA1就是相同的)</p><p>在git中,blob类型的对象的SHA1只与文件的内容有关，相同的文件内容永远产生相同的SHA1,而不同的文件内容永远产生不同的SHA1.<br>这意味着如果我们将两个内容相同的文件提交到git中,他们实际上会被保存为同一个blob对象</p><p>git add test03<br>git commit -a -m “version 1.2 master”</p><p>为什么我们这一次的提交且包含上一次的那些文件跟目录(git ls-tree xxx)<br>实际上上一条提交记录是工作目录中sy</p><h1 id="git提交记录的访问方法"><a href="#git提交记录的访问方法" class="headerlink" title="git提交记录的访问方法"></a>git提交记录的访问方法</h1><p>1 通过SHA1访问<br>git show asdw<br>2 通过分支名访问<br>git log master<br>3 通过HEAD访问<br>git log HEAD<br>4 通过标签访问<br>git show version 1.1<br>5 通过^访问 (当前结点的父节点)<br>git log HEAD^<br>git log master^<br>6 通过^[n] 访问<br>git show HEAD^1 (访问第一个父节点)<br>git show HEAD^2 (访问第二个父节点)<br>7 通过~ 访问<br>git show HEAD^2</p><h1 id="git常用指令"><a href="#git常用指令" class="headerlink" title="git常用指令"></a>git常用指令</h1><ol><li><p>初始化本地仓库<br>git init</p></li><li><p>下载远程项目<br>git clone &lt;账号&gt;@&lt;ip地址&gt;:项目在服务器的地址</p></li><li><p>更新index (将工作目录中的文件、目录的内容更新到index中)<br>git add &lt;路径&gt;</p></li><li><p>查看工作目录状态<br>git status</p></li><li><p>撤销git add 操作(如果代码已经通过git commit提交,则不能执行此操作)<br>git reset HEAD &lt;路径&gt;</p></li><li><p>撤销本地操作(如果代码已经通过git commit提交,则不能执行此操作)<br>git checkout – &lt;路径&gt;</p></li><li><p>提交修改<br>git commit (提交index的内容)<br>git commit -a (将修改更新到index,然后提交,忽略新增的文件)<br>git commit -a -m “提交说明”</p></li><li><p>浏览提交历史<br>git log &lt;提交历史&gt;<br>git log (显示当前分支所有提交的历史)<br>显示本地master与远程仓库master之间的不同的提交记录<br>git log -p master..origin/master</p></li><li><p>显示某一提交的内容<br>git show &lt;提交记录&gt;：&lt;文件&gt;<br>git show 123d<br>git show master</p></li><li><p>显示版本树的图形界面<br>gitk &lt;提交记录&gt;</p></li><li><p>显示差异<br>git diff &lt;旧提交记录&gt;..&lt;新提交记录&gt;<br>git diff wy..master (主分支和从分支的区别)</p></li><li><p>生成patch<br>git format-patch &lt;旧提交记录&gt;..&lt;新提交记录&gt;</p></li><li><p>显示本地分支<br>git branch</p></li><li><p>创建本地分支<br>git branch &lt;分支名称&gt;</p></li><li><p>删除本地分支<br>git branch -d &lt;分支名称&gt; (-D 强制删除)</p></li><li><p>显示远端分支<br>git branch -r</p></li><li><p>切换分支<br>git checkout &lt;分支名&gt;</p></li><li><p>显示远端仓库<br>git remote</p></li><li><p>推送代码<br>git push</p></li><li><p>提取并更新代码<br>git pull</p></li><li><p>提取代码<br>git fetch</p></li><li><p>合并分支<br>git merge &lt;被合并分支&gt;</p></li><li><p>调查git对象<br>git cat-file -t<sha1>(查看文件的类型)<br>git cat-file<type><sha1><br>git cat-file commit 0111</sha1></type></sha1></p></li><li><p>调查tree对象<br>git ls-tree<sha1></sha1></p></li><li><p>内容检索<br>git prep &lt;关键字&gt;<br>git prep &lt;关键字&gt;&lt;提交记录&gt;<br>git prep &lt;关键字&gt;&lt;提交记录&gt;:&lt;文件&gt;</p></li><li><p>移动文件/目录<br>git mv &lt;原&gt; &lt;新&gt;</p></li><li><p>删除文件/目录<br>git rm &lt;路径&gt;</p></li><li><p>显示所有标签<br>git tag -n</p></li><li><p>新建本地标签<br>git tag &lt;标签名&gt; &lt;提交记录&gt;</p></li><li><p>删除标签<br>git tag -d &lt;标签名&gt;</p></li><li><p>创建远端标签<br>git tag -a &lt;标签名&gt; -m &lt;标签说明&gt; &lt;提交记录&gt;</p></li><li><p>推送远端标签<br>git push –tags</p></li><li><p>提取远端标签<br>git fetch –tags</p></li><li><p>撤销某条提交记录<br>git revert &lt;提交记录&gt;</p></li><li><p>获得某个文件的历史版本<br>git checkout master^ zlw.txt</p></li><li><p>计算文件的SHA1字符串<br>git hash-object zlw.txt</p></li><li><p>显示git配置<br>git config –global -l<br>git config -l</p></li><li><p>help<br>git help &lt;指令&gt;</p></li></ol><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h2 id="同时提交"><a href="#同时提交" class="headerlink" title="同时提交"></a>同时提交</h2><p>同事B先上传了代码到远程仓库,但同事A也在后面上传了代码,此时同时A报了一下的错误.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure><p>问题原因:<br>其他地方向同一远端库推送了代码，导致本地不是最新的。<br>解决:<br>先pull 一下,使当前本地仓库版本是最新的</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">AAAAAAAAAAAAA version1.1   这部分是本地的</span><br><span class="line">=======</span><br><span class="line">BBBBBBBBBBBBB version1.1   这部分是远程仓库的</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1f0894404b819648c9b207f19e425638c1bf35a4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android入门1</title>
    <link href="http://yoursite.com/2020/02/17/Android%E5%85%A5%E9%97%A81/"/>
    <id>http://yoursite.com/2020/02/17/Android入门1/</id>
    <published>2020-02-17T14:47:24.000Z</published>
    <updated>2020-02-25T02:25:34.880Z</updated>
    
    <content type="html"><![CDATA[<p>1</p><a id="more"></a><h1 id="项目的结构"><a href="#项目的结构" class="headerlink" title="项目的结构"></a>项目的结构</h1><p>build 编译时自动生成的文件<br>libs 第三方jar包<br>AndroidTest 测试用例<br>java java代码<br>res<br>drawable 图片<br>layout 布局<br>values 字符串<br>mipmap 开头的用来放应用图标 -xx是为了让程序能够好的兼容各种设备<br>AndroidManifest.xml 整个Android项目的配置文件,四大组件在这注册<br>proguard-rules.pro 指定项目代码的混淆规则,让破解者难以阅读.<br>Activity是Android应用程序的门面,凡是应用中你看到的东西,都是放在活动中的<br>Android程序的设计讲究逻辑和视图分离.</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p>调用应用程序名的字符串两种方式<br>代码中:R.string.hello_world<br>xml:@string/hello_world<br>string的部分可以替换drawable mipmap layout<br>引用id @id/id_name<br>定义id @+id/id_name<br>活动中使用Toast<br>活动本身就是一个Context 对象<br>makeText(“上下文对象”,”显示的文本”,”显示的时长”)<br>在活动中使用Menu(菜单)</p><h1 id="Intel"><a href="#Intel" class="headerlink" title="Intel"></a>Intel</h1><p>Intel是Android程序各组件之间进行交互的一种方式<br>Intent zlw = new Intent(启动活动的上下文,指定想要启动的目标活动.class)<br>startActivity(zlw);</p><h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>不明确指出那个活动,而指定action 和category(同时匹配上才响应)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class="line">     &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">&lt;category android:name=&quot;android.intent.category.ZLW&quot;/&gt;</span><br><span class="line">     &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h1 id="向下一个活动传数据"><a href="#向下一个活动传数据" class="headerlink" title="向下一个活动传数据"></a>向下一个活动传数据</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String data = &quot;qwerqwewerfjqwekrthqwejklrhjkl   ehjrklqwhrklqwerhqwelrhjqwelrwjkelrh&quot;;</span><br><span class="line"> intent.putExtra(&quot;s1&quot;,data);</span><br><span class="line"> Intent intent = getIntent();</span><br><span class="line"> String data =intent.getStringExtra(&quot;s1&quot;); //根据前一个传的键的类型写方法</span><br><span class="line"> Log.d(&quot;zlwzlwzlwzlwzlw&quot;,data);</span><br></pre></td></tr></table></figure><h1 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h1><p>第一个活动:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(intent,i)</span><br><span class="line">onActivityResult(int requestCode, int resultCode, @Nullable Intent data)</span><br><span class="line">requestCode判断来源</span><br><span class="line">resultCode判断结果</span><br><span class="line">data取数据</span><br></pre></td></tr></table></figure><p>第二个活动：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent1 = new Intent();                intent1.putExtra(&quot;data_return&quot;,&quot;android studio&quot;);</span><br><span class="line">setResult(RESULT_OK,intent1);</span><br><span class="line">finish();//销毁activity</span><br><span class="line">//会调回到上一个活动的onActivityResult方法中</span><br></pre></td></tr></table></figure><h1 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h1><p>Android是使用任务(task)来管理活动的，一个任务就是一组放在站里面的活动的集合,这个站也被称为返回栈<br>启动一个栈相当于压栈<br>finish相当于出栈</p><h2 id="四个状态"><a href="#四个状态" class="headerlink" title="四个状态"></a>四个状态</h2><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>处于栈顶的活动</p><h3 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h3><p>不处于栈顶的位置的活动,就进入暂停活动.仍然处于完全存活和可见状态.</p><h3 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h3><p>不在栈顶的位置的活动,完全不可见,但会保存状态和成员变量.</p><h3 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h3><p>从栈中移除的活动</p><h2 id="Activity类中定义了7种回调方法"><a href="#Activity类中定义了7种回调方法" class="headerlink" title="Activity类中定义了7种回调方法"></a>Activity类中定义了7种回调方法</h2><p>onCreate()<br>会在活动第一次被创建的时候调用</p><p>onStart()<br>完全不可见变可见时调用</p><p>onResume()<br>在活动准备好和用户进行交互的时候调用(一定处于栈顶)</p><p>onRestart()<br>停止状态到运行状态之前调用</p><p>onPause()<br>在系统准备去启动或者恢复另一个活动的时候调用.</p><p>onStop()<br>在完全不可见的时候调用</p><p>onDestroy()<br>在活动销毁前调用</p><h3 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h3><p>正常的dialog</p><h4 id="完整生存期-onCreate-onDestroy-之间经历"><a href="#完整生存期-onCreate-onDestroy-之间经历" class="headerlink" title="完整生存期 onCreate() onDestroy()之间经历"></a>完整生存期 onCreate() onDestroy()之间经历</h4><h4 id="可见生存期-onStart-进行加载-onStop-进行释放"><a href="#可见生存期-onStart-进行加载-onStop-进行释放" class="headerlink" title="可见生存期 onStart() 进行加载 onStop() 进行释放"></a>可见生存期 onStart() 进行加载 onStop() 进行释放</h4><p>会话</p><h4 id="前台生存期-onResume-onPause-活动总是处于运行状态-用户接触最多的"><a href="#前台生存期-onResume-onPause-活动总是处于运行状态-用户接触最多的" class="headerlink" title="前台生存期  onResume()  onPause() 活动总是处于运行状态,用户接触最多的"></a>前台生存期 onResume() onPause() 活动总是处于运行状态,用户接触最多的</h4><h4 id="活动被回收了怎么办"><a href="#活动被回收了怎么办" class="headerlink" title="活动被回收了怎么办"></a>活动被回收了怎么办</h4><p>当A活动在去启动B活动之后,由于内存不足,将A活动收回,那么用户按下Back返回活动A,会出现什么情况.还是会<br>onSaveInstanceState() 可以保证在活动被收回之前一定会被调用.</p><h1 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h1><h2 id="standard-默认启动模式"><a href="#standard-默认启动模式" class="headerlink" title="standard(默认启动模式)"></a>standard(默认启动模式)</h2><p>不在乎这活动是否已经在返回栈中存在,名次还是准备都会创建该活动的一个新的实例.</p><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>在启动活动是如果发现返回栈的栈顶已经是该活动,则认为可以直接使用它.不会在创建新的活动实例.</p><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>创建活动之前检查返回栈中是否存在该活动的实例,如果有直接使用该实例,并把这个活动之上的所有活动统统出栈,如果没有就直接创建一个新的实例.</p><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>指定该模式的活动会启用一个新的返回栈来管理这个活动(主要是为了很其他的应用程序进行交互,而上三种方式不行,共用这同一个返回栈)<br>在AndroidManifest.xml的<br><activity android:lunchmode></activity></p><h2 id="知晓当前在哪个活动中"><a href="#知晓当前在哪个活动中" class="headerlink" title="知晓当前在哪个活动中"></a>知晓当前在哪个活动中</h2><p>写一个BaseActivity,继承AppComatActivity并重写onCreate(),但不在在AndroidManifest.xml里面注册,只需要让要访问的类继承该类就行了,<br>protected void onCreate(@Nullable Bundle savedInstanceState) {<br>super.onCreate(savedInstanceState);<br>Log.d(“BaseActivity”, getClass().getSimpleName());<br>}</p><h2 id="活动管理器"><a href="#活动管理器" class="headerlink" title="活动管理器"></a>活动管理器</h2><p>新建一个类,里面有add,remove,还有一个FinnishAll()<br>和一个list<activity>列表.<br>每次在onCreate() 和 onDestroy() 执行add,remove方法<br>在需要的时候执行FinnishAll() 结束所有的活动.</activity></p><h1 id="常用控件的使用方法"><a href="#常用控件的使用方法" class="headerlink" title="常用控件的使用方法"></a>常用控件的使用方法</h1><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>match_parent 让当前控件的大小和父布局的大小一样<br>fill_parent 跟上面意义相同<br>wrap_parent 让当前控件的大小能够刚好包住里面的内容,由控件内容来决定控件的大小<br>TextView默认是居左对齐.<br>android:gravity=”center” top bottom left right center 可以用|来确定多个值<br>android:textSize=”24sp”<br>android:textColor=”#00000”</p><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>系统对button中的所有英文字母自动进行大写转换<br>android:textAllCaps=”false” 禁用</p><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>允许用户在控件里输入和编辑内容,并可在程序中对这些内容进行处理.(发短信,发微信,发qq)<br>默认的文本提示,输入文本就消失<br>android:hint=”默认的文本提示”<br>指定行数的限制<br>android:maxLines=”2”</p><h2 id="imageView"><a href="#imageView" class="headerlink" title="imageView"></a>imageView</h2><p>显示图片的控件<br>ProgressBar(进度条)<br>android:visibility=””<br>visible 可见(不指定默认可见)<br>invisible 不可见(但占位置和大小,透明)<br>gone 不仅不可见,而且不占空间<br>进度条的样式自己找</p><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>弹出对话框,置定于所以的界面之上.</p><h2 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h2><h1 id="4种基本布局"><a href="#4种基本布局" class="headerlink" title="4种基本布局"></a>4种基本布局</h1><p>布局用来管理控件</p><p>一个布局里面可以有多个布局和多个控件<br>1.线性布局<br><linearlayout><br>2.相对布局<br><relativelayout><br>3.帧布局<br><framelayout><br>所有的控件都放在左上角,先加载的在最低层.<br>4.百分百布局</framelayout></relativelayout></linearlayout></p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h1 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h1><p>最常用和最难用的插件.(当我们程序中有大量的数据需要展示的时候使用)ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内,同时屏幕上原有的数据则会滚动出屏幕。</p><p>提升ListView的效率</p><p>RecyclerView 比ListView跟方便跟轻松的实现</p><p>横向滚动和瀑布流布局<br>ListView的布局排列是由自身去管理的,RecyclerView则将这个任务交给LayoutManager,LayoutManager中制定了一套可扩展的布局排列接口,子类照着套就完事了<br>GridLayoutManager 实现网格布局<br>StaggeredGridLayoutManager 实现瀑布流布局</p><p>RecyclerView的点击事件</p><p>nine-patch 图片</p><h1 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h1><p>碎片是一种可以嵌入在活动中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间,(可以理解为迷你型的活动)</p><p>动态添加碎片<br>//创建添加的碎片实例<br>//获得fragmentManager,在活动中可以调用getSupportFragmentManager得到<br>//开启事务 获得fragmentManager.beginTransaction<br>//向容器添加或者替换碎片 用 replace() 传入 容器id 和 添加的碎片实例<br>//提交事务 commit()</p><p>//将一个事务添加到返回栈中<br>fragmentTransaction.addToBackStack(null);</p><p>碎片和活动之前进行通信<br>活动中调用碎片<br>FragmentManager 有类似于 findViewById()的方法 专门用于从布局文件中获得碎片的实例<br>getFragmentManager().findFragmentById(R.id.right_layout)</p><p>碎片中调用活动<br>MainActivity activity = (MainActivity) getActivity();</p><p>碎片的生命周期<br>1.运行状态<br>可见,关联的活动处于运行状态</p><p>2.暂停状态<br>活动处于暂停状态,碎片就进入暂停状态</p><p>3.停止状态<br>当一个活动进入停止状态时,与它相关的碎片就进入到停止状态,或者用 FragmentTransaction 的remove() replace() 从活动中移除. 调用addToBackStack会进入暂停状态,进入停止状态的碎片对于用户来说完全不可见</p><p>4.销毁状态<br>碎片总是依附活动而存在,活动亡,碎片亡, remove() replace() 在事务之前没有调用 addToBackStack方法,碎片就会进入销毁状态</p><p>onAttach()<br>当碎片和活动建立关联的时候调用</p><p>onCreateView()<br>为碎片创建视图(加载布局)时调用</p><p>onActivityCreated()<br>确保与碎片相关联的活动一定已经创建完毕的时候调用.</p><p>onDestroyView()<br>当与碎片关联的视图被移除的时候调用</p><p>onDetach()<br>当碎片和活动解除关联的时候调用</p><p>动态加载布局的技巧<br>判断程序应该是使用单页模式还是双页模式===&gt;限定符<br>在layout同级目录建一个<br>layout-large 其中large就是一个限定符,那些屏幕认为是large的设备就会自动加载layout-large 文件夹下的布局,小屏幕的设备还是会加载layout文件夹下的布局</p><p>android中一些常见的限定符<br>大小<br>small 小屏幕设备<br>normal 中等屏幕设备<br>large 大屏幕设备<br>xlarge 超大屏幕设备</p><p>分辨率<br>ldpi 低分辨率设备 120dpi以下<br>mdpi 中等分辨率设备 120dpi<del>160dpi<br>hdpi 高分辨率设备 160dpi</del>240dpi<br>xhdpi 超过高分辨率设备 240dpi<del>320dpi<br>xxhdpi 超超高分辨率设备 320dpi</del>480dpi</p><p>方向<br>land 横屏设备<br>port 竖屏设备</p><p>最小限定符<br>这个最小值为临界点,屏幕宽度大于这个值的设备就加载一个布局,小于加载另一个布局</p><p>碎片的最佳实例—一个简单版的新闻应用<br>FragmentBestPractice项目名<br>1.实现在app/build.gradle添加依赖<br>implementation ‘androidx.recyclerview:recyclerview:1.0.0’<br>2.创建新闻的实体类,有title和content这两个字段名,和get,set方法<br>3.编写新闻内容的布局 news_content_frag.xml<br>4.然后在创建 NewsContentFragment 新闻内容的碎片</p><p>广播的类型</p><p>1.标准广播<br>完全异步执行的广播,在广播发之后,所有广播接收器几乎都会在同一时刻接收到这条广播消息.无法截断<br>2.有序广播<br>同步执行,在广播发之后,同一时刻只会有一个广播接收器能够收到这条广播信息,当这个广播接收器中的逻辑执行完毕后,广播才会继续传播,此时广播接收器是有先后顺序的,优先级高的先接收,可以被截断.</p><p>可以对自己感兴趣的广播进行注册,注册广播有两种方式<br>1.在代码中注册 (动态注册)<br>2.在AndroidManifest.xml中注册 (静态注册)</p><p>任何创建一个广播接收器,新建类让他继承自 Broadcast-Receiver,并重写父类的onReceive就行了,在有广播到来时,该方法会得到执行.</p><p>Android系统为了保护用户设备的安全跟隐私,必须在配置文件中声明权限才可以<br><uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"><br>缺点是程序启动之后才可以接收到广播</uses-permission></p><p>静态注册实现开机启动<br>android:name=”.BootCompleteReceiver” 指定那个广播接收器<br>android:enabled=”true”<br>是否启动<br>android:exported=”true”<br>是否接收本程序以外的广播</p><p>不要在onReceive()方法中添加过多的逻辑进行任何的耗时操作.</p><p>发送自定义广播<br>android:priority=”100”<br>//表示将这条广播截断<br>abortBroadcast();</p><p>使用本地广播<br>之前我们发送和接收的广播都是属于系统全局广播<br>本地就是只能在应用程序的内部进行传递<br>LocalBroadcastManager 需要导入implementation ‘androidx.recyclerview:recyclerview:1.0.0’</p><p>实现强制下线的功能<br>界面上弹出一个对话框且中只有一个确定按钮,但用户可能出现在任意一个界面上，我们不可能每个界面都写这个弹出对话框的逻辑.</p><p>git的基本命令<br>git config –global user.name “zlw”<br>git config –global user.email “<a href="mailto:985686843@qq.com" target="_blank" rel="noopener">985686843@qq.com</a>“</p><p>创建仓库<br>git init</p><p>不想要之前本地仓库删除那个隐藏的.git文件夹就行了</p><p>提交本地代码<br>git init<br>git add .<br>git commit -m “First commit”<br>git remote add origin <a href="https://github.com/ZlwPick/AndroidTest.git" target="_blank" rel="noopener">https://github.com/ZlwPick/AndroidTest.git</a><br>git push -u origin master</p><p>添加单个文件<br>git add build.gradle<br>添加整个目录下的所有文件<br>git add app<br>添加所有文件<br>git add .<br>提交(描述信息)<br>git commit -m “First commit”<br>新建分支<br>git branch newbranch<br>检查分支<br>git branch</p><p>查看修改内容(显示更改的文件)<br>git status<br>查看更多修改信息()<br>git diff 具体文件的位置<br>撤销修改<br>git checkout 具体文件的位置</p><p>持久化技术<br>数据持久化技术保证数据不在是瞬时数据.保存在内存中的数据是瞬时的,保存在存储设备上的数据是处于持久化状态<br>android中三种常见的持久化：<br>1.文件存储<br>2.SharedPreference存储<br>3.数据库存储</p><p>文件存储<br>最基础的一个数据存储方式,不对存储的内容进行任何的格式化处理.原封不动的保存到文件中,适用于简单的文本数据或者二进制数据.</p><p>SharedPreference存储</p><p>要想使用SharedPreferences,首先需要获得SharedPreferences对象,有以下三种方式得到对象.</p><p>1.Context类中的getSharedPreferences()方法<br>2.Activity类中的getPreferences()方法<br>3.PreferenceManager 类中的 getDefaultSharedPreferences()方法</p><p>主要有以下三步.<br>1.调用 SharedPreferences对象的edit()获取SharedPreferences.Editor对象<br>2.向SharedPreferences.Editor对象中添加数据<br>putBoolean() putString() …<br>3.调用 apply() 方法数据提交</p><p>SQLite 数据库存储</p><ol><li>新建一个类继承 SQLiteOpenHelper 类,在重写 onCreate() 和 onUpgrade()</li><li>两种方法都可以打开一个现有的数据库<br>gerReadableDatabase()<br>返回只能读操作的对象<br>getWritableDatabase()<br>返回一个可以对数据库进行读写操作的对象</li></ol><p>MyDatabaseHelper(Context context,String name, SQLiteDatabase.CursorFactory factory, int version)<br>1.上下文对象 2.数据库名 3.Cursor对象,一般为null 4当前数据库的版本号 1</p><p>内容提供器<br>主要用于不同的应用程序之间实现数据共享的功能.<br>运行时权限,用户不必在安装软件的时候一次性授权所有的申请权限，比如有打开相机的功能时在申请相机的权限.所以的权限分为普通权限、危险权限.<br>每个危险权限都属于一个权限组下,当申请的一个危险权限得到授权时,整个组下的危险权限都可以使用.</p><p>ContentResolver的基本用法</p><p>1.Context.getContentResolver() 获取该类的实例,有一套CRUD(insert()、update()、delete()、query() ),不接受表名参数,而是使用一个Uri参数代替,Uri是由anthority和path组成,anthority是采用应用程序的包名来进行命名的,path则是用于对同一应用程序中不同的表做区分的.还需要在最前面加上协议如下：<br>content://com.example.app.provider/table1<br>content://com.example.app.provider/table2<br>content://com.example.app.provider/table2/1 (table2id为1的数据)</p><ul><li>表示匹配任意长度的任意字符<h1 id="表时匹配任意长度的数字"><a href="#表时匹配任意长度的数字" class="headerlink" title="表时匹配任意长度的数字"></a>表时匹配任意长度的数字</h1>content://com.example.app.provider/* (匹配任意表)<br>content://com.example.app.provider/table2/#匹配任意一行的数据内容<br>Uri.parse() 将字符串解析成Uri对象</li></ul><p>UriMatcher中的addUri 实现匹配内容 参数列表(anthority,path,一个自定义代码)</p><p>创建自己的内容提供器<br>1.新建一个类去继承 ContentProvider 的方式来创建一个自己的内容提供器. 重写他的6个方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-jvm篇2</title>
    <link href="http://yoursite.com/2020/02/15/java-jvm%E7%AF%872/"/>
    <id>http://yoursite.com/2020/02/15/java-jvm篇2/</id>
    <published>2020-02-15T08:48:41.000Z</published>
    <updated>2020-02-29T04:42:31.597Z</updated>
    
    <content type="html"><![CDATA[<p>jvm运行时的数据区,Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分成若干个不同的数据区域。</p><a id="more"></a><p>不同的JVM对于内存的划分方式和管理机制存在着部分差异.(大部分是方法区不同)<br>以下是简图:<br><img src="/images/java/jvm/运行时的数据区.png" width="400px" height="400px"></p><p>绿色的为单线程所有的,蓝色的为多个线程共享的:<br>每个线程:独立包括程序计数器、栈、本地栈.<br>线程间共享:堆、堆外内存(永久或者元空间、代码缓存)==&gt;方法区<br>每个JVM只有一个Runtime实例.(单例)</p><p>线程是一个程序里的运行单元,JVM允许一个应用有多个线程并行的执行.<br>在Hotspot JVM里,每个线程都与操作系统的本地线程映射.当一个java线程准备好执行以后,此时一个操作系统的本地线程也同时创建.java线程执行终止后,本地线程也会回收.</p><h1 id="PC寄存器-Program-Counter-Register"><a href="#PC寄存器-Program-Counter-Register" class="headerlink" title="PC寄存器(Program Counter Register)"></a>PC寄存器(Program Counter Register)</h1><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟.<br>作用:<font color="red">PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码,由执行引擎读取下一条指令</font></p><ol><li>使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？<br>进程切换,保存现场</li></ol><h1 id="JVM栈-Java-Virtual-Machine-Stack"><a href="#JVM栈-Java-Virtual-Machine-Stack" class="headerlink" title="JVM栈(Java Virtual Machine Stack)"></a>JVM栈(Java Virtual Machine Stack)</h1><p>栈是运行时的单位,堆是存储的单位.<br>早期也叫Java栈,每个线程在创建时都会创建一个虚拟机栈,其内部保存一个个的栈帧(Stack Frame),对应一次次Java方法调用.<br>不存在垃圾回收问题.GC(存在OOM)<br>作用:主管Java程序的运行,它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果,并参与方法的调用和返回.<br>Java栈的大小是动态的或者是固定不变的.</p><p>如果采用固定大小的jvm栈,那每个线程的jvm栈容量可以在线程创建的时候独立选定.如果线程请求分配的栈的容量超过JVM栈的最大容量,JVM栈会抛出一个<font color="red">StackOverflowError</font>异常.(递归,可以用-Xss 设置栈的大小)</p><p>如果JVM栈可以动态扩展,并尝试扩展的时候无法申请到足够的内存(创建先的线程时没有足够的内存去创建对应的JVM栈)JVM栈会抛出一个<font color="red">OutOfMemoryError</font>异常.<br>一个时间点上只会有一个活动的栈帧,当前执行的方法的栈帧称为当前栈帧,对应的方法称为当前方法,定义这个方法的类称为当前类.</p><h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><p>1.不同线程之间栈帧不允许相互引用.<br>2.方法返回时,会将此方法的执行结果给前一个栈帧,此帧丢弃.前一个栈帧成为当前栈帧.<br>3.Java方法有两种返回函数的方式,都会导致栈帧被弹出.<br>3.1 正常的函数返回(return)<br>3.2 抛出异常(Error)</p><h2 id="栈的内部结构"><a href="#栈的内部结构" class="headerlink" title="栈的内部结构"></a>栈的内部结构</h2><img src="/images/java/jvm/栈帧.png" width="500px" height="500px"><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>1.定义为一个数字数组,主要用于存储方法参数和定义在方法体内的局部变量(基本数据类型,对象引用,returnAddress)。<br>2.是线程私有的,不存在数据安全问题.<br>3.<font color="red">局部变量表所需的容量大小是在编译期确定下来的,运行期间是不会改变局部变量表的大小</font><br>4.方法嵌套调用的次数由栈的大小决定,栈越大,方法嵌套调用次数越多.<br>5.局部变量表中的变量 只在当前方法调用中有效,当方法调用结束后,随着方法栈帧的销毁也会随之销毁.<br>变量的分类:1.按照数据类型分：①基本数据类型 ②引用数据类型<br>2.按在类中的声明的位置分:<br>①成员变量:在使用前,都经历过默认初始化的赋值<br>类变量:linking的prepare阶段:给类变量默认赋值—&gt;&gt; initial阶段:给类变量显式赋值即静态代码块赋值<br>实例变量:随着对象的创建,会在堆空间中分配变量空间,并进行默认赋值.<br>②局部变量: 在使用之前要进行显式赋值,否则,编译不通过<br>局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象不会被回收.</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>在方法执行过程中,根据字节码指令,往栈中写入数据或者提取数据(入栈,出栈),用数组的结构来实现的<br>作用:主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间.<br>1.一个新的栈帧在创建出来,这个方法的操作数栈是空的(max_stack最大深度在编译期就定义好了)<br>2.栈顶缓存技术<br>将栈顶元素全部缓存到物理CPU的寄存器中,以此降低对内存的读/写次数,提升执行引擎的执行效率.</p><h3 id="动态链接-指向运行时常量池的方法引用"><a href="#动态链接-指向运行时常量池的方法引用" class="headerlink" title="动态链接(指向运行时常量池的方法引用)"></a>动态链接(指向运行时常量池的方法引用)</h3><p>每个栈帧内部都包含一个指向<font color="green">运行时常量池中</font>该栈帧所属方法的引用.包括这个引用的目的就是为了支持当前方法的代码能够实现动态链接。(invokedynamic)<br>作用:为了将这些符号引用转换为调用方法的直接引用.</p><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 Java 来说，绑定分为静态绑定和动态绑定，或者叫做前期绑定和后期绑定。</p><p>静态绑定：在程序执行前方法已经被绑定(也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法)，由编译器实现。C就是典型的前期绑定。Java 中 final，static，private 修饰的方法和构造方法是前期绑定(早期绑定)<br>动态绑定：运行时根据具体对象的类型进行绑定(晚期绑定)</p><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本,这个版本在运行时是不可改变的,这样的方法称为非虚方法<br>静态方法、私有方法、final方法、实例构造器、父类方法都是<br>其他的方法称为虚方法<br>jvm中的调用方法指令：(绿色表示非虚方法,其余的(final修饰的除外)称为虚方法)<br><font color="green">1.invokespecial (编译时方法绑定调用方法。)<br>2.invokestatic(调用静态方法。)</font><br>3.invokevirtual (运行时方法绑定调用方法。)<br>4.invokeinterface (调用接口方法。)<br>5.invokedynamic(Java为了实现动态类型语言支持而做的一种改进.Lambda表达式出现,invokedynamic指令的生成,在java中才有了直接的生成方式)<br>动态类型语言和静态类型语言的区别:<br>对类型的检查是在编译期还是运行期间.</p><pre>java: int i = 10;  (静态类型)Python:i = 10      (动态类型)</pre><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>存放调用该方法的PC寄存器的值.<br>1.正常退出:方法退出后会返回到调用该方法的下一条指令的地址.(执行引擎拿到地址进行跳转).<br>字节码指令中,方法指令包含:<br>1.1 ireturn(当返回值是boolean、byte、char、short、int类型时,使用长度小于int的)<br>1.2 lreturn、freturn、dreturn以及引用类型areturn<br>1.3 return(供声明void的方法、实例初始化方法、类、接口的初始化方法使用)<br>2.异常退出:”返回地址要通过异常表(本方法的异常表中没有搜索到匹配的异常处理器 )来确定,栈帧中一般不会保存这部分信息.</p><p>两者的区别:通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jvm运行时的数据区,Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分成若干个不同的数据区域。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 动静分离和高可用</title>
    <link href="http://yoursite.com/2020/02/14/Nginx-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/14/Nginx-动静分离和高可用/</id>
    <published>2020-02-14T06:32:25.000Z</published>
    <updated>2020-02-29T04:44:34.260Z</updated>
    
    <content type="html"><![CDATA[<p>待完善</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;待完善&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 简介和安装</title>
    <link href="http://yoursite.com/2020/02/12/Nginx-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/02/12/Nginx-简介和安装/</id>
    <published>2020-02-12T05:12:48.000Z</published>
    <updated>2020-02-27T05:27:21.933Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器,其特点是占有内存少，并发能力强.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么?"></a>Nginx是什么?</h2><p>是一个高性能的HTTP和反向代理web服务器.</p><h2 id="为什么使用Nginx"><a href="#为什么使用Nginx" class="headerlink" title="为什么使用Nginx?"></a>为什么使用Nginx?</h2><p>在传统的Web项目中,并发量小,用户使用的少.</p><p>所以在低并发的情况下,用户可以直接访问tomcat服务器,然后tomcat服务器返回消息给用户。<br>用户访问&lt;—&gt;Tomcat服务器</p><p>在互联网项目下,因单个Tomcat默认并发量有限,会产生如下问题:<br>1.用户并发大的情况下,单个Tomcat服务器无法支撑.<br>1.1 垂直 (扩展服务器的设备,买更好的服务器,来扩大Tomcat的并发量)<br>1.2 水平<br>(线性扩展 多个Tomcat服务器来支持用户的请求)<br>问题: 用户需要记很多个服务器地址,用户根本不知道哪台服务器是忙闲?<br>这时候Nginx完美解决。</p><h1 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h1><p>1.高并发,高可用,高性能<br>2.可扩展性好<br>3.热部署<br>4.BSD许可证</p><h1 id="代理的概念"><a href="#代理的概念" class="headerlink" title="代理的概念"></a>代理的概念</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>是一个位于客户端和原始服务器之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回客户端,客户端才能使用正向代理.<br><img src="/images/linux/nginx/正向代理.png" width="500px" height="600px"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理方式是指以代理服务器来接受internet上的连接请求,然后将请求转发给内部网络上的服务器,并将服务器上得到的结果返回给internet上请求连接的客户端,此时代理服务器对外就表现为一个反向代理服务器.<br><img src="/images/linux/nginx/反向代理.png" width="500px" height="600px"></p><h2 id="两者之间的区别"><a href="#两者之间的区别" class="headerlink" title="两者之间的区别"></a>两者之间的区别</h2><p>正向代理,是在客户端的.(VPN)<br>反向代理,是作用在服务器端的,是一个虚拟IP(VIP)</p><h1 id="安装-linux下"><a href="#安装-linux下" class="headerlink" title="安装(linux下)"></a>安装(linux下)</h1><p>1.一键安装四个依赖包<br>yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel<br>2.下载Nginx,解压</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mkdir nginx</span><br><span class="line">cd nginx/</span><br><span class="line">#下载安装Nginx</span><br><span class="line">wget http://nginx.org/download/nginx-1.13.11.tar.gz</span><br><span class="line">#先切换到opt目录下，新建文件夹nginx-1-13</span><br><span class="line">cd nginx-1.13.11</span><br><span class="line">./configure  --prefix=/opt/nginx-1-13      #指定安装目录</span><br></pre></td></tr></table></figure><p>3：在nginx-1.13.11目录下执行编译和执行安装命令<br>make &amp;&amp; make install<br>4:切换到安装目录和启动<br>cd /opt/nginx-1-13/sbin/</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#启动Nginx</span><br><span class="line">nginx  </span><br><span class="line">#强制关闭(某些东西不会保存,因此会丢失,此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。)</span><br><span class="line">nginx -s stop</span><br><span class="line">#强制关闭(某些东西不会保存,此方式停止步骤是待nginx进程处理任务完毕进行停止。)</span><br><span class="line">nginx -s quit</span><br><span class="line">#重启nginx</span><br><span class="line">nginx -s reload</span><br><span class="line">#查看Nginx版本</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><h1 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h1><h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p><font color="red">从配置文件开始到events块之间的内容,主要会设置一些影响nginx服务器整体运行的配置指令</font>,主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数,进程PID 存放路径、日志存放路径和类型以及配置文件的引入等.</p><h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接.</p><h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>nginx服务器配置中最频繁的部分,代理、缓存和日志定义等绝大多数功能和第三方模块的模块的配置都在这里面.可以分为一下两部分:</p><h3 id="http-全局块"><a href="#http-全局块" class="headerlink" title="http 全局块"></a>http 全局块</h3><p>http全局块配置的指令包括文件引入,MIME-TYPE定义、日志自定义、连接抄时间等</p><h3 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h3><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。<br>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。<br>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。<br>1.全局 server 块<br>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。<br>2.location 块<br>一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。 地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p><h1 id="反向代理-实例"><a href="#反向代理-实例" class="headerlink" title="反向代理(实例)"></a>反向代理(实例)</h1><p>目的:打开浏览器,在浏览器地址栏输入地址<a href="http://www.zlw.com,跳转到linux系统Tomcat主页面" target="_blank" rel="noopener">www.zlw.com,跳转到linux系统Tomcat主页面</a>. 1.启动Tomcat(端口8080,开放端口见linux学习日志7)<br>2.本地DNS域名解析修改hosts文件<br>192.168.0.9 <a href="http://www.zlw.com" target="_blank" rel="noopener">www.zlw.com</a><br>3.<a href="http://www.zlw.com:8080/访问出现Tomcat主页" target="_blank" rel="noopener">http://www.zlw.com:8080/访问出现Tomcat主页</a><br>4.修改nginx.conf 实现反向代理<br>server_name 192.168.0.9<br>location / {<br>root html;<br>proxy_pass <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>; index index.html index.htm;<br>}</p><p>修改Tomcat的端口号</p><details><summary>详细修改的地方展开查看</summary><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">&lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">&lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</span><br><span class="line">&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure></details>准备两个Tomcat服务器8080，8081 创建见文件夹和测试页面<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>增加服务器的数量,然后将请求分发到各个服务器上,将原先请求集中到单个服务器上的情况改为请求分发到多个服务器上,将负载分发到不同的服务器,这就是负载均衡.<br>· 目的:<a href="http://192.168.0.9/zlw/hhhh.html,实现负载均衡的效果,平分到8080,8081端口中" target="_blank" rel="noopener">http://192.168.0.9/zlw/hhhh.html,实现负载均衡的效果,平分到8080,8081端口中</a>.</p><p>1.准备两台Tomcat,中都有zlw文件夹,创建hhhh.html</p><p>2.配置nginx.conf</p><details><summary>详细配置的地方展开查看</summary><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">        #ip_hash;</span><br><span class="line">        server 192.168.0.9:8080;</span><br><span class="line">        server 192.168.0.9:8081;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.0.9;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            proxy_pass http://myserver:8080;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>负载均衡的策略<h2 id="轮询-默认"><a href="#轮询-默认" class="headerlink" title="轮询(默认)"></a>轮询(默认)</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器,如果后端服务器down掉,能自动剔除.</p><h2 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h2><p>weight代表权,默认为1,权重越高被分配的客户端越多.指轮询几率,weight和访问比率成正比,用于后端服务器性能不均的情况;</p><pre>upstream myserver{        server 192.168.0.9:8080 weight=1;        server 192.168.0.9:8081 weight=2;    }</pre><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>每个请求访问ip的hash结果分配,这样每个访客固定访问一个后端服务器,可以解决session的问题:</p><pre>upstream myserver{        ip_hash;        server 192.168.0.9:8080;        server 192.168.0.9:8081;    }</pre><h2 id="fair-第三方"><a href="#fair-第三方" class="headerlink" title="fair(第三方)"></a>fair(第三方)</h2><p>按后端服务器的响应时间来分配请求,响应时间短的优先分配.</p><pre>upstream myserver{        server 192.168.0.9:8080;        server 192.168.0.9:8081;        fair;    }</pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器,其特点是占有内存少，并发能力强.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-9</title>
    <link href="http://yoursite.com/2020/02/12/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-9/"/>
    <id>http://yoursite.com/2020/02/12/Linux-学习日志-9/</id>
    <published>2020-02-12T05:10:07.000Z</published>
    <updated>2020-02-14T06:32:55.744Z</updated>
    
    <content type="html"><![CDATA[<p>桥连接:liunx可以和其他的系统通信,但可以造成ip冲突<br>NAT:网络的地址转换方式:liunx可以访问外网,不会造成ip冲突<br>主机模式:liunx是一个独立的主机,不能访问外网.<br>一些基本的命令练习</p><a id="more"></a><h1 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h1><p>1.在root下创建空文件1.txt<br>2.在root下创建目录file1/file2<br>3.将1.txt复制到file1/file2<br>4.将1.txt移动到file1下<br>5.分别查看file1和file2下的内容<br>6.删除file2</p><h1 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h1><p>1.创建5个文件分别是 1.txt 2.txt 3.txt 4.txt 5.txt<br>2.压缩这5个文件，压缩包的名字是zlw.tar<br>3.把压缩包移动到/home下面<br>4.解压hailiang.tar<br>5.查看是否有这5个文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;桥连接:liunx可以和其他的系统通信,但可以造成ip冲突&lt;br&gt;NAT:网络的地址转换方式:liunx可以访问外网,不会造成ip冲突&lt;br&gt;主机模式:liunx是一个独立的主机,不能访问外网.&lt;br&gt;一些基本的命令练习&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-8</title>
    <link href="http://yoursite.com/2020/02/10/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-8/"/>
    <id>http://yoursite.com/2020/02/10/Linux-学习日志-8/</id>
    <published>2020-02-10T05:21:15.000Z</published>
    <updated>2020-02-12T06:16:46.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h1><p>shell是一个命令行解释器,他为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用shell来启动,挂起,暂停,编写一些程序.</p><a id="more"></a> <img src="/images/linux/shell.png" width="200px" height="400px"> document.querySelector('video').playbackRate = 3.0; ## 脚本格式要求 1.脚本以#!/bin/bash 开头 2.脚本需要有可执行权限<h2 id="脚本的常用执行方式"><a href="#脚本的常用执行方式" class="headerlink" title="脚本的常用执行方式"></a>脚本的常用执行方式</h2><p>首先要赋予执行的权限<br>1.直接输入文件的路径(绝对,相对都可以)<br>2.sh ./helloworld.sh(不需要赋权限)</p><h1 id="shell的变量"><a href="#shell的变量" class="headerlink" title="shell的变量"></a>shell的变量</h1><p>1.liunx shell中的变量分为<font color="red">系统变量</font>和<font color="red">用户自定义变量</font><br>1.1系统变量: $HOME $PWD $SHELL $USER<br>1.2显示当前shell中的所有变量:set</p><h2 id="shell变量的定义"><a href="#shell变量的定义" class="headerlink" title="shell变量的定义"></a>shell变量的定义</h2><p>基本语法(在引用变量时需要使用$)<br>定义变量: 变量=值<br>撤销变量 unset 变量(赋null)<br>声明静态变量: readnoly 变量(<font color="red">不能unset</font>) 定义变量的规则<br>1.变量名可以由字母、数字和下划线组成,但是不能以数字开头。<br>2.等号两侧不能有空格<br>3.变量名称一般习惯为大写</p><h2 id="将命令的返回值赋值给变量"><a href="#将命令的返回值赋值给变量" class="headerlink" title="将命令的返回值赋值给变量"></a>将命令的返回值赋值给变量</h2><p>1.A=<code>ls -la</code><br>2.A=$(ls -la)</p><h2 id="编写属于自己的环境变量"><a href="#编写属于自己的环境变量" class="headerlink" title="编写属于自己的环境变量"></a>编写属于自己的环境变量</h2><p>在/etc/profile 编写,编写完成后需要刷新该文件source</p><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释:"></a>多行注释:</h2><p>:&lt;&lt;! ZLW=”ZLW”<br>echo “$ZLW”<br>!</p><h2 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h2><p>执行一个shell脚本时,如果希望获取到命令行的参数信息,就可以使用位置参数变量(类似于方法传参的形式)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Myshell.sh 100 200 300</span><br></pre></td></tr></table></figure><ol><li>$n (n为数字,0代表命令本身,1-9为第一到第九个参数,大于10需要用大括号包含,如${10})</li><li>$* (所有参数看成一个整体)</li><li>$@ (也代表所有参数,但每个参数区分对待)</li><li>$# (参数的个数)</li></ol><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p>事先已经定义好的变量,可以直接在shell脚本中使用<br>1.$$ (当前进程的进程号(PID))<br>2.$! (后台运行的最后一个进程的进程号)<br>3.$? (最后一次执行的命令的返回状态)</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>基本语法<br>1.$((运算式)) 或 $[运算式]<br>2.expr m + n (expr运算符间要有空格)<br>3.expr m - n<br>4.expr * / % (乘,除,取余)</p><p>#第一种方式<br>RESULT1=$(((2+3)<em>4))<br>RESULT2=$[(2+3)</em>4]<br>echo “结果1=$RESULT1”<br>echo “结果2=$RESULT2”</p><p>#第二种方式<br>RESULT3=<code>expr 2 + 3</code><br>RESULT4=<code>expr $RESULT3 \* 4</code><br>echo “RESULT4=$RESULT4”</p><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>基本语法<br>[ condition ] (condition前后要有空格)<br>非空返回 true</p><h2 id="两个整数的比较"><a href="#两个整数的比较" class="headerlink" title="两个整数的比较"></a>两个整数的比较</h2><p>= 字符串比较<br>-lt 小于(less than)<br>-le 小于等于(less equal)<br>-eq 等于(equal)<br>-gt 大于(greater than)<br>-ge 大于等于(greater equal)<br>-ne 不等于(not equal)</p><h2 id="按照文件的权限进行判断"><a href="#按照文件的权限进行判断" class="headerlink" title="按照文件的权限进行判断"></a>按照文件的权限进行判断</h2><p>-r<br>-w<br>-x</p><h2 id="按照文件的类型进行判断"><a href="#按照文件的类型进行判断" class="headerlink" title="按照文件的类型进行判断"></a>按照文件的类型进行判断</h2><p>-f (文件存在并且是一个常规的文件)<br>-e (文件存在)<br>-d (文件存在并是一个目录)</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h2><p>基本语法(两种方式,中括号和条件判断式之间必须有空格)<br>1.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">elif[ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><details><summary>案例展开查看</summary><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;及格&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;不及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></details><h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><p>基本语法</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">值为1的程序段</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">值为1的程序段</span><br><span class="line">;;</span><br><span class="line">&quot;值3&quot;)</span><br><span class="line">值为1的程序段</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"> 以上值都不是执行该语句</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><details><summary>案例展开查看</summary><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">        echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">        echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;3&quot;)</span><br><span class="line">        echo &quot;周三&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">        echo &quot;xxxxxxxx&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></details><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>基本语法 (这就要用到之前的位置变量)<br>1.跟Python很类似</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3</span><br><span class="line">do </span><br><span class="line">   程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>2.跟java很类似</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">do </span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><details><summary>案例展开查看</summary><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;$i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;--------------------------------&quot;</span><br><span class="line">for z in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;$z&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">        SUM=$[$SUM + $i]</span><br><span class="line">done</span><br><span class="line">echo &quot;$SUM&quot;</span><br></pre></td></tr></table></figure></details><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>基本语法</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line">        SUM=$[$SUM+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><h2 id="read-读取控制台输入"><a href="#read-读取控制台输入" class="headerlink" title="read 读取控制台输入"></a>read 读取控制台输入</h2><p>基本语法<br>read (选项)(参数)<br>-p (指定读取值时的提示符)<br>-t (指定提示的时间,超过就不在等待,单位是秒)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;输入数字:&quot; NUM</span><br><span class="line">echo &quot;num=$NUM&quot;</span><br><span class="line"></span><br><span class="line">read -t 10 -p &quot;输入数字:&quot; NUM1</span><br><span class="line">echo &quot;NUM1=$NUM1&quot;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>1.系统函数<br>basename[pathname][suffix]<br>功能:返回完整路径最后/部分,常用于获取文件名<br>suffix为后缀,在返回结果是会被去掉<br>basename ./zlw.txt .txt</p><p>dirname<br>功能:返回完整路径最后/部分前面的部分,跟basename相反<br>dirname /home/zlw/shellzlw/zlw.txt</p><p>2.自定义函数</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#不需要形参</span><br><span class="line">function getSum()&#123;</span><br><span class="line">        NUM=$[$N1 + $N2]</span><br><span class="line">        echo &quot;$NUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;输入第一个参数:&quot; N1</span><br><span class="line">read -p &quot;输入第二个参数:&quot; N2</span><br><span class="line"></span><br><span class="line">#方法调用</span><br><span class="line">getSum $N1 $N2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell是什么&quot;&gt;&lt;a href=&quot;#shell是什么&quot; class=&quot;headerlink&quot; title=&quot;shell是什么&quot;&gt;&lt;/a&gt;shell是什么&lt;/h1&gt;&lt;p&gt;shell是一个命令行解释器,他为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用shell来启动,挂起,暂停,编写一些程序.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java-jvm篇1</title>
    <link href="http://yoursite.com/2020/02/04/java-jvm%E7%AF%871/"/>
    <id>http://yoursite.com/2020/02/04/java-jvm篇1/</id>
    <published>2020-02-04T08:43:01.000Z</published>
    <updated>2020-02-16T03:41:48.028Z</updated>
    
    <content type="html"><![CDATA[<p>jvm的类加载子系统</p><a id="more"></a><p>java虚拟机平台上运行非Java语言编写的程序.只关心”字节码”文件.(语言无关性)</p><img src="/images/java/jvm/jdk,jre,jvm.png" width="400px" height="400px"><p>JVM的整体结构如下图:<br><img src="/images/java/jvm/JVM整体流程图.png" width="650px" height="650px"></p><h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><h2 id="基于栈式架构的特点-HotSpot"><a href="#基于栈式架构的特点-HotSpot" class="headerlink" title="基于栈式架构的特点(HotSpot)"></a>基于栈式架构的特点(HotSpot)</h2><p>1.设计和实现更简单,适用于资源受限的系统.<br>2.避开寄存器的分配难题,使用零地址指令式分配.<br>3.指令流中的指令大部分是零地址指令,其执行过程依赖于操作栈,指令集更小,编译器容易实现.<br>4.不需要硬件支持,可移植性更好,更好实现跨平台.</p><h2 id="基于寄存器架构的特点"><a href="#基于寄存器架构的特点" class="headerlink" title="基于寄存器架构的特点"></a>基于寄存器架构的特点</h2><p>1.x86的二进制指令集<br>2.指令集架构完全依赖硬件,移植性差<br>3.性能优秀和执行更高效.<br>4.花费更少的指令去完成一项任务<br>5.有一,二,三地址指令</p><h1 id="jvm的生命周期"><a href="#jvm的生命周期" class="headerlink" title="jvm的生命周期"></a>jvm的生命周期</h1><p>1.vm启动<br>是通过引导类加载器(bootstrap class loader)创建一个初始类(inital class)来完成的,这个类是由虚拟机的具体实现指定的.<br>2.vm执行<br>执行一个所谓的java程序的时候,真真正正在执行的是一个叫做Java虚拟机的进程.<br>3.vm退出<br>3.1.正常退出<br>3.2.异常终止<br>3.3.操作系统出现问题终止<br>3.4.某些api的方法退出</p><h1 id="jvm发展史"><a href="#jvm发展史" class="headerlink" title="jvm发展史"></a>jvm发展史</h1><p>1.Sun Classic VM (只提供解释器)<br>2.Exact VM<br>3.HotSpot(主流)<br>4.JRockit(专注于服务器端应用,JRockit 是世界上最快的JVM)<br>5.J9<br>6.KVM CDC CLDC</p><h1 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h1><p>类加载器子系统负责从文件系统或者网络中加载Class文件,class文件在文件打开有特定的文件标识.<br>ClassLoader只负责class文件的加载,至于它是否可以运行,则由Execution Engine决定.<br>加载的类信息存放于一块称为方法区的内存空间,除了类的信息外,方法区中还会存放运行时常量池信息,可能还包括字符串面量和数字常量.<br>类的加载过程如下图<br><img src="/images/java/jvm/类的加载过程.png" width="450px" height="450px"></p><h2 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h2><p>1.通过一个类的全限定名获取定义此类的二进制字节流.<br>2.将这个字节流所代表的静态储存结构转化为方法区的运行时的数据结构.<br>3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口.</p><h2 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接(Linking)"></a>链接(Linking)</h2><h3 id="验证-verify"><a href="#验证-verify" class="headerlink" title="验证(verify)"></a>验证(verify)</h3><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性.(字节码在文件开头有特定的文件标识.)</p><h3 id="准备-Perpare"><a href="#准备-Perpare" class="headerlink" title="准备(Perpare)"></a>准备(Perpare)</h3><p>为类变量分配内存并且设置该类变量的默认初始值,零值.<br><font color="red">不包含final修饰的static,final在编译的时候就会分配,准备阶段会显式初始化.</font><br><font color="red">此阶段不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到jvm堆中</font></p><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h3><p>将常量池内的符号引用转换为直接引用的过程.</p><h2 id="初始化-Initalization"><a href="#初始化-Initalization" class="headerlink" title="初始化(Initalization)"></a>初始化(Initalization)</h2><p>此阶段就是 执行类构造器方法<clinit>() 的过程.<br>此方法不需要定义,是Javac编译器自动收集类中所有类变量赋值动作和静态代码块中的语句合并而来.<br>构造器方法中指令按语句在源文件中出现的顺序执行.<br><clinit>()不同于类的构造器.(父类的<clinit>()在子类之前执行)<br>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁.</clinit></clinit></clinit></clinit></p><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><h3 id="启动类加载器-引导类加载器-bootstrap-ClassLoader"><a href="#启动类加载器-引导类加载器-bootstrap-ClassLoader" class="headerlink" title="启动类加载器(引导类加载器,bootstrap ClassLoader)"></a>启动类加载器(引导类加载器,bootstrap ClassLoader)</h3><p>这个类加载是C++实现的,不继承自java.lang.ClassLoader,没有父加载器,用来加载java的核心库.用于提供JVM自身需要的类</p><h3 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h3><p>java 语言编写,派生于ClassLoader类,如果用户创建的jar放在次目录下,也会自动由扩展类加载器加载.</p><h3 id="应用程序类加载器-系统类加载器-AppClassLoader"><a href="#应用程序类加载器-系统类加载器-AppClassLoader" class="headerlink" title="应用程序类加载器(系统类加载器 AppClassLoader)"></a>应用程序类加载器(系统类加载器 AppClassLoader)</h3><p>该类加载是程序中默认的类加载器.<br>ClassLoader#getSystemClassLoader()方法获取该加载器.</p><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>继承java.lang.ClassLoaderlei,实现自己的类加载器.</p><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>1.如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行.<br>2.如果父类加载类还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器.<br>3.如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派机制.<br><img src="/images/java/jvm/双亲委派机制.png" width="500px" height="500px"></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>1.避免类的重复加载<br>2.保护程序安全,防止API被随意篡改<br>java.lang.String<br>java.lang.zlw</p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>自定义String类,但是在加载自定义string类的时候会使用引导类加载器,而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class),报错信息说没有main方法,就是因为加载的是rt.jar包中的Stringlei,这样可以保证对java核心源代码的保护,这就是沙箱安全机制.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jvm的类加载子系统&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-7</title>
    <link href="http://yoursite.com/2020/01/19/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-7/"/>
    <id>http://yoursite.com/2020/01/19/Linux-学习日志-7/</id>
    <published>2020-01-19T08:24:11.000Z</published>
    <updated>2020-02-13T10:18:25.293Z</updated>
    
    <content type="html"><![CDATA[<p>组管理和权限管理</p><a id="more"></a><p>[chgrp] 改变文件所属群组<br>[chown] 改变文件拥有者</p><p>改变用户所在的组<br>usermod -g 组名 用户名</p><p>groups 查询所有的组</p><p>chown newuser:newgroup file 改变用户的拥有者和所在组<br>-r 目录下面的所有东西都改变</p><h1 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h1><p>crontab [选项]<br>| -e | 编辑crontab定时任务 |<br>| -i | 查询crontab任务 |<br>| -r | 删除当前用户所有的crontab任务 |</p><p>参数细节<br>| / | 含义 | 范围 |<br>| :—-:| :—-: | :—-: |<br>| 第一个”*” | 一小时当中的第几分钟 | 0-59 |<br>| 第二个”*” | 一天当中的第几小时 | 0-23 |<br>| 第三个”*” | 一月当中的第几天 | 0-31 |<br>| 第四个”*” | 一年当中的第几月 | 1-12 |<br>| 第五个”*” | 一周当中的星期几 | 0-7 |</p><p>特殊符号<br>| 特殊符号 | 含义 |<br>| :—-:| :—-: |<br>| * | 一小时当中的第几分钟 |<br>| 第二个”*” | 一天当中的第几小时 |<br>| 第三个”*” | 一月当中的第几天 |<br>| 第四个”*” | 一年当中的第几月 |<br>| 第五个”*” | 一周当中的星期几 |</p><p>linux分区<br>硬盘 linux的文件系统<br>分区一 /<br>分区二 boot mnt…<br>。。。<br>。。。</p><p>分区挂载到目录(mount挂载和umount卸载)<br>查看系统的分区和挂载的情况<br>lsblk -f</p><p>如何添加一块硬盘<br>1.虚拟机添加硬盘(当添加之后lsblk中并没有新的硬盘的信息,需要虚拟机重启)<br>2.分区(fdisk 地址)<br>3.格式化()<br>4.挂载<br>5.设置自动挂载</p><p>查询系统磁盘的整体使用情况<br>df -lh</p><p>查询某一特定的目录的使用情况<br>du -h /….<br>-h 带计量单位<br>-a 带文件<br>-c 列出明细的同时,增加汇总值<br>–max-depth=1 子目录深度</p><p>统计指定目录下文件的数目<br>ls -l /home/zlw | grep “^-“ | wc -l</p><p>统计指定目录下目录的数目<br>ls -l /home/zlw | grep “^ d” | wc -l</p><p>统计指定目录下文件的数目,包括子文件下的<br>ls -lR /home/zlw | grep “^-“ | wc -l</p><p>统计指定目录下目录的数目 ,包括子文件下的<br>ls -lR /home/zlw | grep “^ d” | wc -l</p><p>用树状显示目录<br>yun install tree</p><p>RPM==&gt;&gt;下载包的打包及安装工具(类似于windows中的setup.exe)</p><p>查询已经安装的的rpm列表<br>rpm -qa | grep XX</p><p>查询rpm安装的软件信息<br>rpm -qi XXX</p><p>查询rpm包的文件安装在哪<br>rpm -ql XXX</p><p>查询某个文件所有那个rpm包<br>rpm -qf XXX</p><p>删除rpm包<br>rpm -e rpm包的名称</p><p>强制删除(在某些情况下你要删除的包可能跟其他的包有依赖在删除之后可以会出现错误)<br>rpm -e –nodeps foo</p><p>用rpm安装包<br>rpm -ivh</p><ul><li>install 安装</li><li>verbose 提示</li><li>hash 进度条</li></ul><p>安装的步骤<br>1.先找到要安装rpm包,然后需要挂载安装的centos的iso文件,然后到/media/下去找rpm</p><p>2.copy出来在安装</p><p>YUN 是基于rpm包管理,能够从指定的服务器自动下载rpm包并安装&lt;fontcolor=”red”&gt;可以自动处理依赖性关系</p><p>查看yum 服务器是否需要安装的软件<br>yum list | grep firefox</p><p>安装<br>yum install firefox</p><p>安装jdk,配置java环境<br>1.先将软件通过xftp5继续远程上传到 /opt 下<br>2.解压到/opt<br>3.配置环境变量的配置文件 vim /etc/profile<br>4.JAVA_HOME=/opt/jdk1.7.0_79<br>5.PATH=/opt/jdk1.7.0_79/bin:$PATH<br>6.export JAVA_HOME PATH</p><p>安装tomcat<br>1.解压apache-tomcat-7.0.70.tar</p><p>2.cd 到apache-tomcat-7.0.70.tar/bin<br>./startup.sh (启动)</p><p>如果想要windows上访问Linux的<a href="http://localhost:8080就需要linux放行8080端口" target="_blank" rel="noopener">http://localhost:8080就需要linux放行8080端口</a></p><p>window中telnet服务记得打开<br>telnet 192.168.0.116 8080<br>firewall-cmd –zone=public –list-ports</p><p>firewall-cmd –permanent –zone=public –add-port=80/tcp<br>Centos7:firewall-cmd –permanent –add-port=8080/tcp<br>–zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效<br>//firewall-cmd –reload</p><p>service firewalld restart<br>telnet成功而打不开的先试试本地是否打开，然后看看防火墙端口centos7可以看systemctl status firewalld，或者用以前的ps和top都能看到，要活学活用</p><p>eclipse的安装<br>1.解压到/opt中<br>2.配置jre和server<br>3.编写jsp测试</p><p>MySQL安装和配置<br>1.卸载旧版本<br>-rpm -qa | grep mysql<br>有删除,没有下一步<br>2.安装mysql<br>安装编译代码需要的包<br>yum -y install make gcc-c++ cmake bison-devel ncurses-devel</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql</span><br><span class="line">-DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc</span><br><span class="line">-DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1</span><br><span class="line">-DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1</span><br><span class="line">-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306</span><br><span class="line">-DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENHINE=1</span><br><span class="line">-DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8</span><br><span class="line">-DDEFAULT_COLLATION=utf8_general_ci</span><br></pre></td></tr></table></figure><p>3.make &amp;&amp; make install (此过程按照时间很长)</p><p>4.查看是否有MySQL用户及用户组</p><p>cat /etc/passwd 查看用户<br>cat /etc/proup 查看组<br>没有创建</p><p>修改 ls -al /usr/local/mysql的权限,交给mysql组<br>chown -R mysql:mysql /usr/local/mysql/<br>5.初始化mysql<br>cd /usr/local/mysql/<br>scripts/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysql</p><p>mv /etc/my.cnf /etc/my.cnf.bak</p><p>6.启动mysql<br>cp support-files/mysql.server /etc/init.d/mysql</p><p>chkconfig mysql on<br>设置默认启动</p><p>service mysql start</p><p>netstat -anp |more (查看3306端口)</p><p>7.修改root的密码<br>cd /usr/local/mysql/bin</p><p>./mysql -uroot</p><p>SET PASSWORD = PASSWORD(‘weiwei1998’);</p><p>quit退出</p><p>再次进入 ./mysql -u root -p</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组管理和权限管理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-6</title>
    <link href="http://yoursite.com/2020/01/14/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-6/"/>
    <id>http://yoursite.com/2020/01/14/Linux-学习日志-6/</id>
    <published>2020-01-14T10:55:18.000Z</published>
    <updated>2020-02-10T07:07:59.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vi-跟-vim-编辑器"><a href="#vi-跟-vim-编辑器" class="headerlink" title="vi 跟 vim 编辑器"></a>vi 跟 vim 编辑器</h1><a id="more"></a><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>可以使用快捷键<br>yy复制当前行, 5yy复制当前以下5行 p粘贴<br>dd 删除<br>G 最末行<br>gg 最首行<br>u 撤销之前写的<br>10gg<br>查找某关键字 /XXXX n 下一个</p><h2 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="插入模式(编辑模式)"></a>插入模式(编辑模式)</h2><p>可以输入内容,按i、I,o、O等进入</p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>可以完成读取,存盘,替换,离开等操作<br>q 打开后没有修改<br>wq 打开后修改了<br>q! 强制保存<br>set nu 设置行数<br>set nonu 取消行数<br>习惯性的会按Ctrl+s vim会进入假死状态,按Ctrl+q退出该状态</p><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>useradd [选项] -d 指定目录 (每个用户必须在一个组里面,新创建的一个组在以自己名字的组中)<br>useradd -g 组名 用户名</p><p>passwd 设置密码</p><p>userdel 删除用户 保存家目录 [-r] 家目录一起删除</p><h2 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h2><p>id 用户名<br>su - 切换到root<br>su - 用户名 切换到普通用户<br>exit 回到原来的用户</p><h2 id="添加组"><a href="#添加组" class="headerlink" title="添加组"></a>添加组</h2><p>groupadd 组名<br>groupdel 组名</p><h2 id="修改用户所在的组"><a href="#修改用户所在的组" class="headerlink" title="修改用户所在的组"></a>修改用户所在的组</h2><p>usermod -g 组名 用户名</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>用户信息配置文件<br>etc/passwd<br>其中行的每一个项的意义<br>用户名 口令 用户id 组id 家目录 登录shell</p><p>组配置文件<br>etc/group<br>其中行的每一个项的意义<br>组名 口令 组内成员列表 组id</p><p>口令配置文件(密码和登录信息,是加密的)<br>etc/shadow<br>其中行的每一个项的意义<br>登录名 加密口令 最后一次修改时间 最小间隔 最大时间间隔等等</p><h1 id="Linux的运行级别"><a href="#Linux的运行级别" class="headerlink" title="Linux的运行级别"></a>Linux的运行级别</h1><ol start="4"><li>描述linux运行级别0-6的各自含义（记时1分钟）<br>0：关机<br>1：单用户模式<br>2：无网络支持的多用户模式<br>3：有网络支持的多用户模式（文本模式，工作中最常使用的模式）<br>4：保留，未使用<br>5：有网络支持有X-Window支持的多用户模式<br>6：重新引导系统，即重启</li></ol><p>文件在/etc/inittab中</p><p>init [012356]</p><h1 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令"></a>常用的指令</h1><h2 id="帮助类指令"><a href="#帮助类指令" class="headerlink" title="帮助类指令"></a>帮助类指令</h2><p>man [命令或者配置文件]</p><p>help [命令]</p><h2 id="目录类指令"><a href="#目录类指令" class="headerlink" title="目录类指令"></a>目录类指令</h2><p>pwd<br>ls<br>cd<br>mkdir [选项] -p 多级 要创建的目录<br>rmdir [选项] -rf 只能删除空目录 否则加rf<br>ch 文件名1 文件名2<br>cp [选项]-r 源 目的<br>rm [选项] -r 递归 -f 强制(force) 文件名<br>mv 文件名1地址 文件名2地址</p><p>cat -n 文件地址 |more(一次性全部加载) less(懒加载)<br>more 文件地址<br>less 文件地址</p><p>&gt; 文件 列表内容写入文件a.txt中 覆盖</p><p>&gt;&gt; 文件 列表的内容追加到文件a.txt的末尾</p><p>cat 文件1 &gt; 文件2 覆盖<br>cat 文件1 &gt;&gt; 文件2 追加</p><p>echo “内容” &gt; 文件<br>echo “内容” &gt;&gt; 文件</p><p>echo $PATH</p><p>head [-n] 文件 显示文件的前10行<br>tail [-n] 文件 显示文件的后10行<br>tail -f 文件</p><p>history 查看历史执行的指令<br>history n 查看最后n条指令</p><p>ln -s 源文件地址 链接名<br>删除链接<br>rm -rf 链接名 (切记链接名后面不可以加/ 要不然把链接地址下面的东西全部删除)</p><h1 id="查找类指令"><a href="#查找类指令" class="headerlink" title="查找类指令"></a>查找类指令</h1><p>find [查找范围] [选项] -name 文件名(可以用正则表达式)</p><p>find [查找范围] -user 用户名 (显示指定的用户的所有文件)</p><p>+n大于 -n小于 n等于<br>find [查找范围] -size +nM(k G)</p><p>快速定位通过locate数据库找到文件路径<br>updatedb</p><p>| 表示将前一个命令的处理结果输出传递给后面的命令处理</p><p>过滤查找 一般配合管道使用<br>grep [选项] 查找内容 源文件<br>-n 显示匹配行<br>-i 忽略大小写</p><h1 id="压缩与解压缩指令"><a href="#压缩与解压缩指令" class="headerlink" title="压缩与解压缩指令"></a>压缩与解压缩指令</h1><p>gzip 文件名 (压缩完之后 原来的文件不保留)<br>gunzip 文件名</p><p>zip [选项] XXX.zip 将要压缩的内容(文件或者目录)<br>-r<br>unzip [选项] [指定解压到的目录] XXX.zip<br>-d 指定解压到的目录</p><p><font color="red">tar 指令(打包指令.tar.gz)</font><br>选项<br>-c 产生.tar打包文件<br>-v 显示详细信息<br>-f 指定压缩后的文件名<br>-z 打包同时压缩<br>-x 解压.tar文件</p><p>tar -czvf zlw.tar.gz zlw.py zlw1.py</p><p>解压文件</p><p>tar -xzvf zlw.tar.gz(默认的本目录) -C [指定的目录]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vi-跟-vim-编辑器&quot;&gt;&lt;a href=&quot;#vi-跟-vim-编辑器&quot; class=&quot;headerlink&quot; title=&quot;vi 跟 vim 编辑器&quot;&gt;&lt;/a&gt;vi 跟 vim 编辑器&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 198 House Robber</title>
    <link href="http://yoursite.com/2020/01/06/LeetCode-198-House-Robber/"/>
    <id>http://yoursite.com/2020/01/06/LeetCode-198-House-Robber/</id>
    <published>2020-01-06T15:30:13.000Z</published>
    <updated>2020-01-06T15:39:50.178Z</updated>
    
    <content type="html"><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><a id="more"></a><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,1]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [2,7,9,3,1]<br><strong>输出:</strong> 12<br><strong>解释:</strong> 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><p>经典的动态规划题目,这一题要好好品一下,对于房屋,我们就只有偷还是不偷这两选项,</p><p>这个大佬讲的动态规划思路好理解👇:<br><a href="https://www.bilibili.com/video/av16544031" target="_blank" rel="noopener">https://www.bilibili.com/video/av16544031</a></p><figure class="highlight java hljs"><figcaption><span>tetle:解法一</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length + <span class="hljs-number">1</span>];</span><br><span class="line">        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= nums.length; i++)</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);</span><br><span class="line">        <span class="hljs-keyword">return</span> dp[nums.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;/p&gt;&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-基础篇1</title>
    <link href="http://yoursite.com/2020/01/01/Java-%E5%9F%BA%E7%A1%80%E7%AF%871/"/>
    <id>http://yoursite.com/2020/01/01/Java-基础篇1/</id>
    <published>2020-01-01T13:54:42.000Z</published>
    <updated>2020-01-04T15:29:11.984Z</updated>
    
    <content type="html"><![CDATA[<p>距上次学习Java基础已经过去2年多了,现在或多或少忘记了一些知识点,正好这次期末要考Java基础,在此重新把Java基础过一遍,查漏补缺,加深印象.</p><a id="more"></a><h2 id="Java的基础程序设计结构"><a href="#Java的基础程序设计结构" class="headerlink" title="Java的基础程序设计结构"></a>Java的基础程序设计结构</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th align="center">类型</th><th align="center">储存需求</th><th align="center">包装类型</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1字节</td><td align="center">Byte</td></tr><tr><td align="center">char</td><td align="center">2字节</td><td align="center">Character</td></tr><tr><td align="center">int</td><td align="center">4字节</td><td align="center">Integer</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td align="center">Short</td></tr><tr><td align="center">long</td><td align="center">8字节</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">4字节</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">8字节</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">1,0</td><td align="center">Boolean</td></tr></tbody></table><p>在Java中,整型、实型和字符型被视为简单数据类型,这些类型由低级到高级分别为:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="hljs-keyword">byte</span>、<span class="hljs-keyword">short</span>、<span class="hljs-keyword">char</span>）---&gt; <span class="hljs-keyword">int</span> ---&gt; <span class="hljs-keyword">long</span> ---&gt; folat ---&gt; <span class="hljs-keyword">double</span></span><br></pre></td></tr></table></figure><h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><p>装箱===&gt; 基本数据类型转换为包装器类型.<br>拆箱===&gt; 包装器类型转换为基本数据类型.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="hljs-number">1111</span>;  <span class="hljs-comment">//装箱</span></span><br><span class="line"><span class="hljs-keyword">int</span> n = i;      <span class="hljs-comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>int 和 Integer 区别<br>1.Integer是int的包装类,int是基本数据类型<br>2.Integer变量必须实例化之后才可以使用,int可以直接使用<br>3.Integer默认值是null,int是0<br><font color="red">String、StringBuffer、StringBuilder区别(面试常问)</font><br>从三个方面去回答(可变、线程安全、String不变有什么好处)</p><ul><li>1.是否可变:<ul><li>1.1 String不能进行修改,若修改则是重新创建一个String对象</li><li>1.2StringBuffer、StringBuilder则是直接对本身String对象进行修改,append()等方法</li></ul></li><li>2.是否线程安全:<ul><li>2.1String对象定义之后不能改变,所以线程安全</li><li>2.2StringBuffer是线程不安全的,适用于单线程下操作字符串缓冲区大量数据.</li><li>2.3StringBuffer:是线程安全的(对调用方法加入同步锁),执行效率较慢,适用于多线程下操作字符串缓冲区大量数据.</li></ul></li><li>3.String不可变有什么好处？<ul><li>3.1可以缓存 hash 值</li><li>3.2String Pool 的需要</li><li>3.3线程安全</li></ul></li></ul><h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>记住一下表就完事了</p><table><thead><tr><th align="center">修饰符</th><th align="center">当前类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><ul><li>static(用来修饰变量、方法、类)<ul><li>修饰变量:变成静态变量其他的类、方法可以访问这个属性</li><li>修饰方法:静态方法在类加载的时候就存在了,它不依赖于任何实例</li><li>修饰语块:在类初始化一次</li><li>修饰类:静态内部类不依赖外部类,且不能访问外部类的非 static 变量和方法.</li></ul></li><li>final<ul><li>修饰变量:该变量不能不可改变(基本类型)</li><li>修饰方法:不能被继承类重新定义</li><li>修饰类:不能够被继承</li></ul></li><li>abstract<ul><li>用来创建抽象类和抽象方法.</li></ul></li><li>synchronized、volatile<ul><li>主要用于线程的编程.</li></ul></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>成员变量</li><li>局部变量</li><li>全局变量</li></ul><table><thead><tr><th align="center">\</th><th align="center">成员变量</th><th align="center">局部变量</th><th align="center">静态变量</th></tr></thead><tbody><tr><td align="center">定义位置</td><td align="center">在类中,方法外</td><td align="center">方法中,或者方法的形式参数</td><td align="center">在类中,方法外</td></tr><tr><td align="center">初始化值</td><td align="center">有默认初始化值</td><td align="center">无,先定义,后赋值才可以使用</td><td align="center">有默认初始化值</td></tr><tr><td align="center">调用方式</td><td align="center">对象调用</td><td align="center">—</td><td align="center">对象调用,类名调用</td></tr><tr><td align="center">储存位置</td><td align="center">堆中</td><td align="center">栈中</td><td align="center">方法区</td></tr><tr><td align="center">生命周期</td><td align="center">与对象共存亡</td><td align="center">与方法共存亡</td><td align="center">与类共存亡</td></tr><tr><td align="center">别名</td><td align="center">实例变量</td><td align="center">—</td><td align="center">类变量</td></tr></tbody></table><h2 id="Java面对对象"><a href="#Java面对对象" class="headerlink" title="Java面对对象"></a>Java面对对象</h2><p>Java面对对象具有三大特性:</p><ul><li>封装<br>-继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）.继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的</li><li>继承<br>-通常认为封装是把数据和操作数据的方法绑定起来,对数据的访问只能通过已定义的接口</li><li>多态<br>-多态是指允许不同子类型的对象对同一消息作出不同的响应.要实现多态主要是做两件事:重写和重载.</li></ul><h3 id="Overload-方法重载-和Override-方法重写"><a href="#Overload-方法重载-和Override-方法重写" class="headerlink" title="Overload(方法重载)和Override(方法重写)"></a>Overload(方法重载)和Override(方法重写)</h3><p>重载:是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>重写:重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距上次学习Java基础已经过去2年多了,现在或多或少忘记了一些知识点,正好这次期末要考Java基础,在此重新把Java基础过一遍,查漏补缺,加深印象.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2019年自我总结</title>
    <link href="http://yoursite.com/2019/12/28/2019%E5%B9%B4%E8%87%AA%E6%88%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/28/2019年自我总结/</id>
    <published>2019-12-28T13:19:54.000Z</published>
    <updated>2019-12-28T15:09:50.589Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><a id="more"></a><h1 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a><p style="text-align:center"><font>自我总结<font></font></font></p></h1><p>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2019年对于我来说是具有成长性的一年,这一年里面我收获许多,也绝望很多,但还是坚持下来了,而且对自己未来的道路十分的迷茫,我分别对这一年的时间内进行概述:<br>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;1月的时候我还在深圳找工作,在各个平台上投了加起来将近7000多份简历,只收到了仅有的7次面试.我现在都还记得那种绝望,整个房间都空了,朋友们都去面试了,只有自己一个人坐在凳子上,投简历、准备面试题、准备自我介绍。在7次的面试中有4家是培训机构的子公司(达内),面试你这种刚出来的小白,就是一顿打击,然后让你他们的公司培训一下.还有一次是一个居民楼里面的公司自己感觉还行,但回来之前就没有信息了,还有一次我坐地铁2个小时,然后又走了半个小时,然后是一个骗子公司,啥技术都没问,就给你开8000,还说我们这最低8000.我傻了都,还有一次运维的工作要去外地现在维护就没去开的5000,最后一次是我工作的公司深圳市筷云有限公司,跟软通动力一个写字楼,实习5000,转正8000,考察期1个星期,一个外包公司.我进去的第一个星期双休变单休,……,由于这个是一个外包公司,人员变动的很快,基本上公司一直在招人,我一进来就一工作了1个月的哥们被项目大佬嫌太菜给踢了,我慌的一比,但还好项目很快就熟悉了下了,也慢慢的好起来了,然后过年回来我一哥们说要专升本,我还是头一次一听说专升本,了解了一下,打算试一试,所以辞去了深圳的工作,回家复习.<br>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3月我开始了复习,一开始准备的是湖北师范大学,买了c语言、微机原理的资料,英语基础基本上是从音开始的(我是真的菜),然后就开开始疯狂学微机可以多拉点分,写了接近100份微机试卷,MD,招生简章出来了,说今年不考微机了,……,然后我就换了一个学校,荆楚理工.花了1个月的时间去重新学了计算机基础,到了6月考试,出的题目是真的简单(英语看不懂除外),然后就考上了,15名,之前就跟基友疯玩了2个月(现在想想就后悔浪费了这么多的时间),9月去上学.<br>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 9月来到学校,看了课表,MD,居然有CAD,我服了,一个计算机学院的开了一门机械的课程,我不喜欢这个课,就开始学自己想学的东西,之前用hexo搭了一个静态的博客,就一直没有管了,我就重新启动了这个博客,给它注册了个域名,开始写博客了,我写的博客是自己学习过程中的一些总结,才发现写博客是多快乐的一件事情,看着自己的文章一篇一篇变多了,心里就有一种满足感,这种满足比我打游戏还舒服,之后的几个月我基本上没有打几次游戏了,中途报了个软考程序员,也过了,题很简单.又去图书馆看了一下408的那几门课程,打算如果明年4级过了就去试一试考研.<br>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 回看我这即将过去的2019,觉得有几分可惜、有几分自信、几分迷茫,但过去的都过去了,目前只有把握现在,才能去追求远方和我等了很久的那个女孩,在此我给我在2020定一下几个目标:<br>1.坚持写博客,减一下肥<br>2.liunx一定要学好<br>3.javaWeb相关的知识学习,中间件,并发等<br>4.看源码<br>5.坚持背单词<br>6.3月的篮桥,4月的四级<br>7.LeetCode的题坚持刷</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在最后引用美国往事里面的一句话:</p><blockquote><p>当我对世事厌倦的时候，我就会想到你。想到你在世界的某个地方生活着、存在着，我就愿意忍受一切。你的存在对我很重要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python-入门篇9</title>
    <link href="http://yoursite.com/2019/12/27/Python-%E5%85%A5%E9%97%A8%E7%AF%879/"/>
    <id>http://yoursite.com/2019/12/27/Python-入门篇9/</id>
    <published>2019-12-27T08:44:38.000Z</published>
    <updated>2019-12-27T09:06:44.179Z</updated>
    
    <content type="html"><![CDATA[<p>这部分是关于多线程与多进程之间的知识,再次之前必须了解操作系统的相关知识,因为Python是在系统调用进行了封装.</p><a id="more"></a><p>在Linux中,创造新进程的方法只有一个，就是fork(),其他的函数库看似可以创建进程,其实内部调用了fork(),<br>普通的函数:调用一次,返回一次.<br>fork():调用的一个奇妙之处就是<font color="red">它仅仅被调用一次，却能够返回两次.</font><br>1.在父进程中，fork返回新创建子进程的进程ID；<br>2.在子进程中，fork返回0；<br>3.如果出现错误，fork返回一个负值；</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.getpid())</span><br><span class="line"><span class="hljs-comment">#子进程只需要调用getppid()就可以拿到父进程的ID。</span></span><br><span class="line">pid = os.fork()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分是关于多线程与多进程之间的知识,再次之前必须了解操作系统的相关知识,因为Python是在系统调用进行了封装.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇8</title>
    <link href="http://yoursite.com/2019/12/23/Python-%E5%85%A5%E9%97%A8%E7%AF%878/"/>
    <id>http://yoursite.com/2019/12/23/Python-入门篇8/</id>
    <published>2019-12-23T09:21:33.000Z</published>
    <updated>2019-12-27T08:06:28.545Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分是关于IO操作</p><a id="more"></a><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>使用Python内部的函数open()</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"C:/Users/1171676294/Desktop/新建文本文档 (2).txt"</span>,<span class="hljs-string">"r"</span>,encoding=<span class="hljs-string">'UTF-8'</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="line">print(f.read()) <span class="hljs-comment">#会一次性读取文件的全部内容</span></span><br><span class="line">    <span class="hljs-comment">#with语句来自动帮我们调用close()方法</span></span><br><span class="line">    <span class="hljs-comment">#f.close()</span></span><br></pre></td></tr></table></figure><p>1.read(size)方法，每次最多读取size个字节的内容。<br>2.readlines()一次读取所有内容并按行返回list。<br>rb,已二进制的形式读取文件</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>使用Python内部的函数open()</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"C:/Users/1171676294/Desktop/text.txt"</span>,<span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> f:</span><br><span class="line">f.write(<span class="hljs-string">"zlwzlwlzlw"</span>)</span><br><span class="line">    <span class="hljs-comment">#w 写命令 wb 已二进制写入文件</span></span><br><span class="line">    <span class="hljs-comment">#'a'以追加（append）模式写入。</span></span><br></pre></td></tr></table></figure><h2 id="读写内存"><a href="#读写内存" class="headerlink" title="读写内存"></a>读写内存</h2><p>1.写入字符串<br>2.读写二进制文件</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">print(f.write(<span class="hljs-string">"zlwzlwzlw"</span>))</span><br><span class="line">print(f.getvalue())</span><br><span class="line"><span class="hljs-comment"># print(f.write(" "))</span></span><br><span class="line">print(f.readable())</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span>  BytesIO</span><br></pre></td></tr></table></figure><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>Python内置的os模块也可以直接调用操作系统提供的接口函数。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"><span class="hljs-comment">#查看当前的操作系统</span></span><br><span class="line">print(os.name)</span><br><span class="line"><span class="hljs-comment">#查看当前目录的绝对路径</span></span><br><span class="line">print(os.path.abspath(<span class="hljs-string">"."</span>))</span><br><span class="line"><span class="hljs-comment">#在路径拼接</span></span><br><span class="line">print(os.path.join(<span class="hljs-string">"C:/Users/1171676294/Desktop/"</span>,<span class="hljs-string">"408"</span>))</span><br><span class="line"><span class="hljs-comment">#创建目录</span></span><br><span class="line">print(os.mkdir(<span class="hljs-string">"C:/Users/1171676294/Desktop/zlwzlw"</span>))</span><br><span class="line"><span class="hljs-comment">#删除目录</span></span><br><span class="line">os.rmdir(<span class="hljs-string">"C:/Users/1171676294/Desktop/zlwzlw"</span>)</span><br><span class="line"><span class="hljs-comment">#得到文件名</span></span><br><span class="line">print(os.path.split(<span class="hljs-string">"C:/Users/1171676294/Desktop/zlwzlw"</span>)[<span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-comment">#得到文件扩展名</span></span><br><span class="line">print(os.path.splitext(<span class="hljs-string">"C:/Users/1171676294/Desktop/zlwzlw"</span>)[<span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-comment">#对于当前目录下文件改名</span></span><br><span class="line">print(os.rename(<span class="hljs-string">"ZZZ.txt"</span>,<span class="hljs-string">"zlwzlwzlw.txt"</span>))</span><br><span class="line"><span class="hljs-comment">#删除文件</span></span><br><span class="line">os.remove(<span class="hljs-string">"zlwzlwzlw.txt"</span>)</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><font color="red">变量从内存中变成可存储或传输的过程称之为序列化</font>，在Python中叫pickling，在其他语言中也被称之为serialization，</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">f = dict(name=<span class="hljs-string">"zlw"</span>,age=<span class="hljs-number">18</span>,score=<span class="hljs-number">90</span>)</span><br><span class="line">print(pickle.dumps(f))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分是关于IO操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-爬虫篇4</title>
    <link href="http://yoursite.com/2019/12/22/Python-%E7%88%AC%E8%99%AB%E7%AF%874/"/>
    <id>http://yoursite.com/2019/12/22/Python-爬虫篇4/</id>
    <published>2019-12-22T09:31:24.000Z</published>
    <updated>2019-12-22T10:07:44.434Z</updated>
    
    <content type="html"><![CDATA[<p>openpyxl模块,关于Excel的读写操作,常用的关于Excel的操作的模块如一下表格:</p><a id="more"></a><table><thead><tr><th>\</th><th align="center">XlsxWriter</th><th align="center">xlrd</th><th align="center">xlwt</th><th align="center">openpyxl</th></tr></thead><tbody><tr><td>介绍</td><td align="center">可以创建XLSX文件</td><td align="center">用来读取xls文件，是python-excel的三大模块</td><td align="center">用来写xls文件，是python-excal的三大模块</td><td align="center">可以读写XLSX、XLSM文件</td></tr><tr><td>读</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>写</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td>.xls</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td>.xlsx</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td>大文件</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr></tbody></table><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook</span><br><span class="line"><span class="hljs-comment">#</span></span><br><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#实例化</span></span><br><span class="line">workbook = Workbook()</span><br><span class="line"><span class="hljs-comment">#激活 WorkSheet</span></span><br><span class="line">ws = workbook.active</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#打开已经存在的文件</span></span><br><span class="line"><span class="hljs-comment">#workbook2 = load_workbook("./zlwzlw.xlsx")</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#写的方式</span></span><br><span class="line"><span class="hljs-comment">#一.直接行号加列号写入</span></span><br><span class="line">ws[<span class="hljs-string">"A1"</span>] = <span class="hljs-number">123123</span></span><br><span class="line"><span class="hljs-comment">#二.可以附加行，从第一列开始附加(从最下方空白处，最左开始)(可以输入多行)</span></span><br><span class="line">ws.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#创建表 后面可以加参数,默认是插入到最后一位,如果为0,则插入在第一位</span></span><br><span class="line">zs = workbook.create_sheet(<span class="hljs-string">"zlwSheet"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#选择表</span></span><br><span class="line">ws = workbook[<span class="hljs-string">"zlwSheet"</span>]</span><br><span class="line">ws.append([<span class="hljs-string">"ZLW"</span>,<span class="hljs-string">"ZLWZLW"</span>])</span><br><span class="line">ws.append([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#查看表 一个数组</span></span><br><span class="line">print(workbook.sheetnames)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#访问单元格</span></span><br><span class="line"><span class="hljs-comment">#单一单元格访问</span></span><br><span class="line">s = ws[<span class="hljs-string">"A1"</span>]</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 保存文件</span></span><br><span class="line">workbook.save(<span class="hljs-string">"./zlwzlw.xlsx"</span>)</span><br></pre></td></tr></table></figure><h3 id="一个利用openpyxl模块将分页的数据保存在Excel中的例子"><a href="#一个利用openpyxl模块将分页的数据保存在Excel中的例子" class="headerlink" title="一个利用openpyxl模块将分页的数据保存在Excel中的例子"></a>一个利用openpyxl模块将分页的数据保存在Excel中的例子</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> requests</span><br><span class="line"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook</span><br><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 请求页面</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHtml</span><span class="hljs-params">(url)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 请求头</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="hljs-keyword">if</span> req.status_code == <span class="hljs-number">200</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> req.text</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 解析数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interpretData</span><span class="hljs-params">(html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="hljs-string">"lxml"</span>)  <span class="hljs-comment"># a</span></span><br><span class="line">    s = soup.find_all(<span class="hljs-string">"div"</span>, class_=<span class="hljs-string">"list-group-item list-group-item-action p-06"</span>)</span><br><span class="line">    data = []</span><br><span class="line">    i = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:</span><br><span class="line">        i += <span class="hljs-number">1</span></span><br><span class="line">        title = x.find(<span class="hljs-string">"div"</span>, class_=<span class="hljs-string">"topic_title"</span>)</span><br><span class="line">        <span class="hljs-keyword">if</span> title:</span><br><span class="line">            data1 = &#123;<span class="hljs-string">"title"</span>: title.text.split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>], <span class="hljs-string">"href"</span>: x.a[<span class="hljs-string">"href"</span>], <span class="hljs-string">"author"</span>: x.strong.a.string,</span><br><span class="line">                     <span class="hljs-string">"date"</span>: x.p.span[<span class="hljs-string">"title"</span>]&#125;</span><br><span class="line">            data.append(data1)</span><br><span class="line">    <span class="hljs-keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 写入Excel</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writer</span><span class="hljs-params">(data, num)</span>:</span></span><br><span class="line">    workbook2 = load_workbook(<span class="hljs-string">"./zlw.xlsx"</span>)</span><br><span class="line">    ws = workbook2.active</span><br><span class="line">    <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:</span><br><span class="line">        ws.append([U<span class="hljs-string">'标题'</span>, U<span class="hljs-string">'地址'</span>, U<span class="hljs-string">'作者'</span>, U<span class="hljs-string">'时间'</span>])</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(data) + <span class="hljs-number">1</span>):</span><br><span class="line">        data1 = [data[i - <span class="hljs-number">1</span>].get(<span class="hljs-string">"title"</span>), data[i - <span class="hljs-number">1</span>].get(<span class="hljs-string">"href"</span>), data[i - <span class="hljs-number">1</span>].get(<span class="hljs-string">"author"</span>), data[i - <span class="hljs-number">1</span>].get(<span class="hljs-string">"date"</span>)]</span><br><span class="line">        ws.append(data1)</span><br><span class="line">        i += <span class="hljs-number">1</span></span><br><span class="line">    workbook2.save(<span class="hljs-string">"./zlw.xlsx"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 主函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(num)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># url拼之后分页请求</span></span><br><span class="line">    url = <span class="hljs-string">f"https://www.lmonkey.com/t?page=<span class="hljs-subst">&#123;num&#125;</span>"</span></span><br><span class="line">    <span class="hljs-comment"># 发送请求</span></span><br><span class="line">    html = getHtml(url)</span><br><span class="line">    <span class="hljs-comment"># 解析数据</span></span><br><span class="line">    data = interpretData(html)</span><br><span class="line">    <span class="hljs-comment"># 写入Excel</span></span><br><span class="line">    writer(data, num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):</span><br><span class="line">        print(<span class="hljs-string">f"我是第<span class="hljs-subst">&#123;x&#125;</span>页"</span>)</span><br><span class="line">        main(x)</span><br><span class="line">        <span class="hljs-comment"># 设置请求间隙给访问的服务器减少压力</span></span><br><span class="line">        time.sleep(<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;openpyxl模块,关于Excel的读写操作,常用的关于Excel的操作的模块如一下表格:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-爬虫篇3</title>
    <link href="http://yoursite.com/2019/12/18/Python-%E7%88%AC%E8%99%AB%E7%AF%873/"/>
    <id>http://yoursite.com/2019/12/18/Python-爬虫篇3/</id>
    <published>2019-12-18T13:54:07.000Z</published>
    <updated>2019-12-24T13:53:02.207Z</updated>
    
    <content type="html"><![CDATA[<p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时,以下是官方API👇:<br><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#</a></p><a id="more"></a><p>我们先根据HTML字符串练习一下bs4,字符串如下:</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">&lt;html&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;head&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/head&gt; </span></span><br><span class="line"><span class="hljs-string">&lt;body&gt; </span></span><br><span class="line"><span class="hljs-string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were </span></span><br><span class="line"><span class="hljs-string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="hljs-string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt;and</span></span><br><span class="line"><span class="hljs-string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="hljs-string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 创建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="hljs-string">"lxml"</span>)</span><br></pre></td></tr></table></figure><h3 id="一-使用Tag对象按照文档结构获取数据"><a href="#一-使用Tag对象按照文档结构获取数据" class="headerlink" title="一.使用Tag对象按照文档结构获取数据"></a>一.使用Tag对象按照文档结构获取数据</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">z = soup.title.string</span><br><span class="line">z = soup.title.name</span><br><span class="line"><span class="hljs-comment"># 默认获取第一个p</span></span><br><span class="line">z = soup.p.string</span><br><span class="line"><span class="hljs-comment"># 获取p里面的class属性</span></span><br><span class="line">z = soup.p[<span class="hljs-string">'class'</span>]</span><br><span class="line"><span class="hljs-comment"># 获取p标签的父类的姓名</span></span><br><span class="line">z = soup.p.parent.name</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure><h3 id="二-搜索"><a href="#二-搜索" class="headerlink" title="二.搜索"></a>二.搜索</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查询满足条件的一个元素</span></span><br><span class="line">f = soup.find(id=<span class="hljs-string">"link3"</span>)[<span class="hljs-string">"class"</span>]</span><br><span class="line">f = soup.find(id=<span class="hljs-string">"link3"</span>).string</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 查询满足条件的所有元素</span></span><br><span class="line">f = soup.find_all(<span class="hljs-string">"a"</span>)  <span class="hljs-comment"># 总返回一个列表,如果没有找到则返回空</span></span><br><span class="line"><span class="hljs-comment"># 属性参数attributes：可以传一个用Python字典封装起来的某个标签的若干个属性及与其对应的属性值做属性参数attributes。</span></span><br><span class="line"><span class="hljs-comment"># f = soup.findAll("",&#123;"class":&#123;"story","title"&#125;&#125;)</span></span><br><span class="line"><span class="hljs-comment"># 文本参数text:用标签的文本内容去匹配，而不是用标签的属性去匹配。</span></span><br><span class="line">f = soup.findAll(<span class="hljs-string">""</span>, text=<span class="hljs-string">"Tillie"</span>)</span><br><span class="line">f = soup.findAll(<span class="hljs-string">""</span>, id=<span class="hljs-string">"link2"</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> f:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><h3 id="三-css选择器"><a href="#三-css选择器" class="headerlink" title="三.css选择器"></a>三.css选择器</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">z = soup.select(<span class="hljs-string">"a"</span>)        <span class="hljs-comment"># 通过标签名字 #list</span></span><br><span class="line">z = soup.select(<span class="hljs-string">".sister"</span>)  <span class="hljs-comment"># 通过class选择器</span></span><br><span class="line">z = soup.select(<span class="hljs-string">"#link1 #link2 #link3"</span>)  <span class="hljs-comment"># 通id选择器</span></span><br><span class="line">z = soup.select(<span class="hljs-string">"p &gt; #link1"</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> z:</span><br><span class="line">    print(x.string)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> requests,json</span><br><span class="line"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># url</span></span><br><span class="line">url = <span class="hljs-string">"https://www.lmonkey.com/t"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = requests.get(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># if req.status_code == 200:</span></span><br><span class="line"><span class="hljs-comment">#     with open(r"./yqpy.html", "w", encoding='UTF-8') as fp:</span></span><br><span class="line"><span class="hljs-comment">#         fp.write(req.text)</span></span><br><span class="line"><span class="hljs-comment"># a = open("./yqpy.html","r",encoding="utf-8").read()</span></span><br><span class="line"><span class="hljs-comment"># 解析数据</span></span><br><span class="line">soup = BeautifulSoup(req.text, <span class="hljs-string">"lxml"</span>)  <span class="hljs-comment"># a</span></span><br><span class="line">s = soup.find_all(<span class="hljs-string">"div"</span>, class_=<span class="hljs-string">"list-group-item list-group-item-action p-06"</span>)</span><br><span class="line">i = <span class="hljs-number">0</span></span><br><span class="line">data = []</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:</span><br><span class="line">    i += <span class="hljs-number">1</span></span><br><span class="line">    title = x.find(<span class="hljs-string">"div"</span>, class_=<span class="hljs-string">"topic_title"</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> title:</span><br><span class="line">        <span class="hljs-comment"># print(title.text.split("\n")[0])</span></span><br><span class="line">        <span class="hljs-comment"># print(x.a["href"])</span></span><br><span class="line">        <span class="hljs-comment"># print(x.strong.a.string)</span></span><br><span class="line">        <span class="hljs-comment"># print(x.p.span["title"])</span></span><br><span class="line">        data1 = &#123;<span class="hljs-string">"title"</span>: title.text.split(<span class="hljs-string">"\n"</span>)[<span class="hljs-number">0</span>], <span class="hljs-string">"href"</span>: x.a[<span class="hljs-string">"href"</span>], <span class="hljs-string">"author"</span>: x.strong.a.string,</span><br><span class="line">                 <span class="hljs-string">"date"</span>: x.p.span[<span class="hljs-string">"title"</span>]&#125;</span><br><span class="line">        data.append(data1)</span><br><span class="line"></span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"./yqpy.josn"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> fp:</span><br><span class="line">    json.dump(data,fp)</span><br></pre></td></tr></table></figure><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re</span><br><span class="line"></span><br><span class="line">var = <span class="hljs-string">"wqerqwcasqweqwe123123qweqweqweqwef3ert"</span></span><br><span class="line"></span><br><span class="line">zlw = <span class="hljs-string">"\d"</span></span><br><span class="line"><span class="hljs-comment"># (匹配规则,字符串),返回list</span></span><br><span class="line">z = re.findall(zlw, var)</span><br><span class="line"><span class="hljs-comment"># (匹配规则,字符串),返回iterator</span></span><br><span class="line"><span class="hljs-comment"># s = re.finditer(zlw,var)</span></span><br><span class="line"><span class="hljs-comment"># for x in s:</span></span><br><span class="line"><span class="hljs-comment">#     print(x.group(),x.span())</span></span><br><span class="line"><span class="hljs-comment">#搜索,在替换</span></span><br><span class="line"><span class="hljs-comment"># zzz = re.sub("\d","ZLWZLW",var)</span></span><br><span class="line"><span class="hljs-comment"># print(zzz)</span></span><br><span class="line"><span class="hljs-comment"># print(z)</span></span><br><span class="line"><span class="hljs-comment">#将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 以及其他如下描述。</span></span><br><span class="line">z = re.compile(<span class="hljs-string">"123"</span>)</span><br><span class="line">s = z.findall(var)</span><br><span class="line">print(s)</span><br><span class="line"><span class="hljs-comment"># print(s.group(1))</span></span><br><span class="line"><span class="hljs-comment"># 正则对象</span></span><br><span class="line"><span class="hljs-comment"># 搜索整个string寻找第一个匹配的位置,返回一个匹配对象,如果没有匹配就返回None</span></span><br><span class="line"><span class="hljs-comment"># (String,开始的位置索引,默认值是0)</span></span><br><span class="line">z = re.search(<span class="hljs-string">"qer"</span>, var)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 如果String的开始位置能够找到这个正则样式的任意个匹配,返回一个匹配对象,如果没有匹配就返回None</span></span><br><span class="line">s = re.match(<span class="hljs-string">"wqer"</span>, var)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># rearch()                      跟               match() 区别</span></span><br><span class="line"><span class="hljs-string">'''     </span></span><br><span class="line"><span class="hljs-string">+从字符串开始到结尾进行搜索匹配                   +要么开始位置符合,否则不符合</span></span><br><span class="line"><span class="hljs-string">+匹配成功返回Match对象,否则None                  +匹配成功返回Match对象,否则None </span></span><br><span class="line"><span class="hljs-string">+group()返回元素                                +group()返回元素</span></span><br><span class="line"><span class="hljs-string">+span()返回下标区间                              +span()返回下标区间</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"></span><br><span class="line">print(z.group())</span><br><span class="line">print(s.group())</span><br></pre></td></tr></table></figure><h2 id="用re模块爬虫的例子"><a href="#用re模块爬虫的例子" class="headerlink" title="用re模块爬虫的例子"></a>用re模块爬虫的例子</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> re,requests</span><br><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> Workbook</span><br><span class="line"><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 写入Excel</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writer</span><span class="hljs-params">(data)</span>:</span></span><br><span class="line">    workbook2 = load_workbook(<span class="hljs-string">"./zlw123123.xlsx"</span>)</span><br><span class="line">    ws = workbook2.active</span><br><span class="line">    ws.append([U<span class="hljs-string">'标题'</span>, U<span class="hljs-string">'作者'</span>, U<span class="hljs-string">'时间'</span>, U<span class="hljs-string">'地址'</span>])</span><br><span class="line">    print(data)</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(data)):</span><br><span class="line">        data1 = [data[i][<span class="hljs-number">0</span>],data[i][<span class="hljs-number">1</span>],data[i][<span class="hljs-number">2</span>],data[i][<span class="hljs-number">3</span>]]</span><br><span class="line">        print(data1)</span><br><span class="line">        ws.append(data1)</span><br><span class="line">        i += <span class="hljs-number">1</span></span><br><span class="line">    workbook2.save(<span class="hljs-string">"./zlw123123.xlsx"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#url</span></span><br><span class="line">url = <span class="hljs-string">"https://www.lmonkey.com/ask"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = requests.get(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line">print(req.status_code)</span><br><span class="line"><span class="hljs-keyword">if</span> req.status_code == <span class="hljs-number">200</span>:</span><br><span class="line">    str1 = <span class="hljs-string">'&lt;div class="topic_title mb-0 lh-180 ml-n2"&gt;(.*?)&lt;small'</span></span><br><span class="line">    title = re.findall(str1, req.text)</span><br><span class="line">    str1 = <span class="hljs-string">'&lt;strong&gt;(.*?)&lt;/strong&gt;'</span></span><br><span class="line">    aouther = re.findall(str1,req.text)</span><br><span class="line">    str1 = <span class="hljs-string">'&lt;span data-toggle="tooltip" data-placement="top" title="(.*?)"&gt;'</span></span><br><span class="line">    date = re.findall(str1, req.text)</span><br><span class="line">    str1 = <span class="hljs-string">'&lt;a href="(https://www.lmonkey.com/ask/\d+)" target="_blank"&gt;'</span></span><br><span class="line">    url1 = re.findall(str1, req.text)</span><br><span class="line">    arrayList = list(zip(title,aouther,date,url1))</span><br><span class="line">    print(arrayList[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],len(arrayList))</span><br><span class="line">    writer(arrayList)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时,以下是官方API👇:&lt;br&gt;&lt;a href=&quot;https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
