<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zlwblog</title>
  
  <subtitle>zlwblog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-15T12:09:39.278Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zlw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-入门篇7</title>
    <link href="http://yoursite.com/2019/12/15/Python-%E5%85%A5%E9%97%A8%E7%AF%877/"/>
    <id>http://yoursite.com/2019/12/15/Python-入门篇7/</id>
    <published>2019-12-15T11:59:01.000Z</published>
    <updated>2019-12-15T12:09:39.278Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是关于Python的错误、调试很测试,内容偏少</p><a id="more"></a><p>try:…except…finally…</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span>:</span><br><span class="line">    print(<span class="hljs-string">"try..."</span>)</span><br><span class="line">    a = <span class="hljs-number">10</span> / int(<span class="hljs-string">"A"</span>)  <span class="hljs-comment"># int("A")  0</span></span><br><span class="line">    print(<span class="hljs-string">"value="</span>,a)</span><br><span class="line"><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e1:</span><br><span class="line">    print(<span class="hljs-string">"except1..."</span>)</span><br><span class="line">    print(<span class="hljs-string">"error="</span>,e1)</span><br><span class="line"><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e2:</span><br><span class="line">    print(<span class="hljs-string">"except2..."</span>)</span><br><span class="line">    print(<span class="hljs-string">"error="</span>,e2)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">"no error!"</span>)</span><br><span class="line"><span class="hljs-keyword">finally</span>:</span><br><span class="line">    print(<span class="hljs-string">"finally..."</span>)</span><br><span class="line"><span class="hljs-comment">#Python的错误是class,所有的错误类型都继承自BaseException,它不但捕获该类型的错误,还把其子类也“一网打尽”.</span></span><br><span class="line"><span class="hljs-comment">#https://docs.python.org/3/library/exceptions.html#exception-hierarchy</span></span><br><span class="line">print(<span class="hljs-string">"-------------"</span>)</span><br><span class="line"><span class="hljs-comment">#好处之一就是可以跨越多层调用,</span></span><br><span class="line"><span class="hljs-comment"># 比如函数main()调用f1(),f1()调用f2(),结果f2()出错了,这时,只要main()捕获到了,就可以层层向下查出问题</span></span><br><span class="line"><span class="hljs-keyword">import</span> logging</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">   <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / int(s)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> f2(s) * <span class="hljs-number">2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        f1(<span class="hljs-string">"a"</span>)</span><br><span class="line">    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">        print(<span class="hljs-string">"error="</span>,e)</span><br><span class="line">    <span class="hljs-keyword">finally</span>:</span><br><span class="line">        print(<span class="hljs-string">"finally"</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>出错的时候,一定要分析错误的调用栈信息,才能定位错误的位置.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   f1(<span class="hljs-string">"a"</span>)</span><br><span class="line"></span><br><span class="line">main1()</span><br><span class="line"><span class="hljs-comment">#Traceback (most recent call last): 告诉我们这是错误的跟踪信息.</span></span><br><span class="line"><span class="hljs-comment"># File "D:/PythonWork/HelloPython/errorTest.py", line 40, in &lt;module&gt;</span></span><br><span class="line"><span class="hljs-comment">#    main1()</span></span><br><span class="line"><span class="hljs-comment">#  File "D:/PythonWork/HelloPython/errorTest.py", line 38, in main1</span></span><br><span class="line"><span class="hljs-comment">#    f1("a")</span></span><br><span class="line"><span class="hljs-comment">#  File "D:/PythonWork/HelloPython/errorTest.py", line 24, in f1</span></span><br><span class="line"><span class="hljs-comment">#    return f2(s) * 2</span></span><br><span class="line"><span class="hljs-comment">#  File "D:/PythonWork/HelloPython/errorTest.py", line 21, in f2</span></span><br><span class="line"><span class="hljs-comment">#    return 10 / int(s)</span></span><br><span class="line"><span class="hljs-comment">#ValueError: invalid literal for int() with base 10: 'a'</span></span><br></pre></td></tr></table></figure><h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>因为出现了错误程序停止了下了,我们把错误信息打印之后输出,同时让程序继续执行<br>Python内置的logging模块可以非常容易地记录错误信息</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">print(<span class="hljs-string">"没想到吧！,我还在执行"</span>)</span><br></pre></td></tr></table></figure><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>如果要抛出错误,首先根据需要,可以定义一个错误的class,选择好继承关系,然后,用raise语句抛出一个错误的实例</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F1Error</span><span class="hljs-params">(ZeroDivisionError)</span>:</span></span><br><span class="line">    logging.exception(ZeroDivisionError)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(i)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">raise</span> F1Error(<span class="hljs-string">"this is value=%s"</span> %i)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> /i</span><br><span class="line"><span class="hljs-comment">#print(f1(0))</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>1.用print()打印可能出现错误的地方,进而进行分析<br>2.凡是用print()来辅助查看的地方,都可以用断言（assert）来替代<br>启动Python解释器时可以用-O参数来关闭assert,关闭后,你可以把所有的assert语句当成pass来看.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f3</span><span class="hljs-params">(i)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">assert</span> i != <span class="hljs-number">0</span>,<span class="hljs-string">"this is zero!!"</span> <span class="hljs-comment">#为true继续往下执行  AssertionError: this is zero!!</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> /i</span><br><span class="line">print(f3(<span class="hljs-number">0</span>))</span><br></pre></td></tr></table></figure><p>3.logging<br>把print()替换为logging是第3种方式,和assert比,logging不会抛出错误,而且可以输出到文件：<br>print(“——-“)</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f4</span><span class="hljs-params">(i)</span>:</span></span><br><span class="line">    logging.info(<span class="hljs-string">"n = %d"</span> % i)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / i</span><br><span class="line">f4(<span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><p>4.pdb省略</p><p>5.IDE打断点(最实用的)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分主要是关于Python的错误、调试很测试,内容偏少&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇6</title>
    <link href="http://yoursite.com/2019/12/15/Python-%E5%85%A5%E9%97%A8%E7%AF%876/"/>
    <id>http://yoursite.com/2019/12/15/Python-入门篇6/</id>
    <published>2019-12-15T09:14:52.000Z</published>
    <updated>2019-12-15T09:35:09.831Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分是关于Python面向对象高级编程,有一部分不是很理解,有时间的话就补充一下内容.</p><a id="more"></a><h3 id="slots-的用法"><a href="#slots-的用法" class="headerlink" title="__slots__的用法"></a>__slots__的用法</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    __slots__ = (<span class="hljs-string">"name"</span>,<span class="hljs-string">"score"</span>,<span class="hljs-string">"age"</span>,<span class="hljs-string">"set_score"</span>) <span class="hljs-comment">#限制实例的属性,不允许随便动态绑定</span></span><br><span class="line">                                       <span class="hljs-comment">#仅对当前类有效,对子类不起作用</span></span><br><span class="line">                                       <span class="hljs-comment">#AttributeError: 'Student' object has no attribute 'zzz'</span></span><br><span class="line"><span class="hljs-comment">#绑定属性</span></span><br><span class="line">a = Student()</span><br><span class="line">a.name = <span class="hljs-string">"zlw"</span></span><br><span class="line">print(a.name)</span><br><span class="line"><span class="hljs-comment">#a.zzz = "zzz" 被限制了,无法绑定</span></span><br><span class="line"><span class="hljs-comment">#绑定方法</span></span><br><span class="line"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_score</span><span class="hljs-params">(self,score)</span>:</span></span><br><span class="line">    self.score = score</span><br><span class="line">a.set_score = MethodType(set_score,a)</span><br><span class="line">a.set_score(<span class="hljs-number">100</span>)</span><br><span class="line">print(a.score)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># AttributeError: 'Student' object has no attribute 'set_score'</span></span><br><span class="line"><span class="hljs-comment">#b = Student()</span></span><br><span class="line"><span class="hljs-comment">#b.set_score(12)</span></span><br><span class="line"><span class="hljs-comment">#print(b.score)</span></span><br><span class="line"><span class="hljs-comment"># 直接改Class绑定方法</span></span><br><span class="line">Student.set_score = set_score</span><br><span class="line">b = Student()</span><br><span class="line">b.set_score(<span class="hljs-number">12</span>)</span><br><span class="line">print(b.score)</span><br></pre></td></tr></table></figure><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#一般情况</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student1</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self,value)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(value,str):</span><br><span class="line">           <span class="hljs-keyword">raise</span>  ValueError(<span class="hljs-string">"name must be an String!"</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line">s1 = Student1();</span><br><span class="line">s1.set_name(<span class="hljs-string">"123"</span>)</span><br><span class="line">print(s1.get_name())</span><br></pre></td></tr></table></figure><p>上面的调用方法又略显复杂,没有直接用属性这么直接简单.<br>有没有既能检查参数,又可以用类似属性这样简单的方式来访问类的变量呢？</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#修改之后的</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student2</span><span class="hljs-params">()</span>:</span></span><br><span class="line"><span class="hljs-meta">    @property #把一个getter方法变成属性</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self._name</span><br><span class="line"><span class="hljs-meta">    @name.setter #@property本身又创建了另一个装饰器@name.setter,负责把一个setter方法变成属性赋值</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self,value)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(value,str):</span><br><span class="line">           <span class="hljs-keyword">raise</span>  ValueError(<span class="hljs-string">"name must be an String!"</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line">s2 = Student2()</span><br><span class="line">s2.name = <span class="hljs-string">"zlw"</span></span><br><span class="line">print(s2.name)</span><br></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>比如,让Dog除了继承自Animal外,再同时继承Canid.这种设计通常称之为MixIn.<br>MixIn的目的就是给一个类增加多个功能,这样,在设计类的时候,我们优先考虑通过多重继承来组合多个MixIn的功能,而不是设计多层次的复杂的继承关系.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Animal</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"this is Animal"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Canid</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Canid</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"this is Canid"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Feline</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Feline</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"this is Feline"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Animal,Canid)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name)</span>:</span></span><br><span class="line">        self__name = name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>  <span class="hljs-comment">#print 输出显示</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"this is __str__ "</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span> <span class="hljs-comment">#交互式的时候直接输出 d 显示</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"this is __repr__"</span></span><br><span class="line"><span class="hljs-comment">#    __str__ == __repr__()</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#__str__()返回用户看到的字符串</span></span><br><span class="line"><span class="hljs-comment"># __repr__()返回程序开发者看到的字符串,也就是说,__repr__()是为调试服务的.</span></span><br><span class="line"></span><br><span class="line">d = Dog(<span class="hljs-string">"zlw"</span>)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><h3 id="iter-用法"><a href="#iter-用法" class="headerlink" title="__iter__用法"></a>__iter__用法</h3><p>如果一个类想被用于for … in循环,类似list或tuple那样,就必须实现一个__iter__()方法,该方法<font color="red">返回一个迭代对象</font>,然后,Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值,直到遇到StopIteration错误时退出循环.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.x1 ,self.x2 = <span class="hljs-number">0</span>,<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.x1 ,self.x2 = self.x2 ,self.x1+self.x2</span><br><span class="line">        <span class="hljs-keyword">if</span>(self.x1 &gt; <span class="hljs-number">3000</span>):</span><br><span class="line">            <span class="hljs-keyword">raise</span>  StopIteration(<span class="hljs-string">""</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> self.x1</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> Fib():</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><h4 id="getitem-省略需要的时候在看"><a href="#getitem-省略需要的时候在看" class="headerlink" title="__getitem__省略需要的时候在看"></a>__getitem__省略需要的时候在看</h4><h3 id="getattr-用法"><a href="#getattr-用法" class="headerlink" title="__getattr__用法"></a>__getattr__用法</h3><p>当调用不存在的属性时,比如score,Python解释器会试图调用__getattr__(self, ‘score’)来尝试获得属性,这样就避免了查找不到属性时报错</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student3</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, attr)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> attr ==<span class="hljs-string">"score"</span>: <span class="hljs-comment">#要让class只响应特定的几个属性,我们就要按照约定,抛出AttributeError的错误</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span></span><br><span class="line">        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"!!!!"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"this is call"</span>)</span><br><span class="line"></span><br><span class="line">s = Student3(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">print(s.score)</span><br><span class="line"><span class="hljs-comment">#非常方便地调用API了</span></span><br></pre></td></tr></table></figure><h3 id="call-用法"><a href="#call-用法" class="headerlink" title="__call__用法"></a>__call__用法</h3><p>就可以直接对实例进行调用.<br>当我们调用实例方法时,我们用instance.method()来调用.<br>通过callable()函数,我们就可以判断一个对象是否是“可调用”对象.<br>print(s())<br>print(callable(s))</p><h3 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h3><p>from enum import Enum<br>Month = Enum(‘Month’, (‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))<br>省略,需要的时候在去复习</p><h3 id="type-函数"><a href="#type-函数" class="headerlink" title="type()函数"></a>type()函数</h3><p>可以查看一个类型或变量的类型,<br>Hello是一个class,它的类型就是type,而h是一个实例,它的类型就是class Hello.<br>class的定义是运行时动态创建的,而创建class的方法就是使用type()函数.<br>要创建一个class对象,type()函数依次传入3个参数：<br>1.class的名称；<br>2.继承的父类集合,注意Python支持多重继承,如果只有一个父类,别忘了tuple的单元素写法；<br>3.class的方法名称与函数绑定,这里我们把函数fn绑定到方法名hello上.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(self,name=<span class="hljs-string">"zlw"</span>)</span>:</span></span><br><span class="line">    print(<span class="hljs-string">"Hello %s"</span> %name)</span><br><span class="line">Hello = type(<span class="hljs-string">"Hello"</span>,(object,),dict(hello=f1))</span><br><span class="line">h = Hello()</span><br><span class="line">h.hello()</span><br><span class="line">print(type(Hello))</span><br><span class="line">print(type(h))</span><br></pre></td></tr></table></figure><h3 id="metaclass-元类-省略-有需要在补充"><a href="#metaclass-元类-省略-有需要在补充" class="headerlink" title="metaclass(元类)省略 有需要在补充"></a>metaclass(元类)省略 有需要在补充</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分是关于Python面向对象高级编程,有一部分不是很理解,有时间的话就补充一下内容.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇5</title>
    <link href="http://yoursite.com/2019/12/15/Python-%E5%85%A5%E9%97%A8%E7%AF%875/"/>
    <id>http://yoursite.com/2019/12/15/Python-入门篇5/</id>
    <published>2019-12-15T04:56:35.000Z</published>
    <updated>2019-12-15T09:17:46.775Z</updated>
    
    <content type="html"><![CDATA[<p>这部分主要是对于Python的面向对象编程的描述和一部分模块知识的梳理.</p><a id="more"></a><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><figure class="highlight python hljs"><figcaption><span>title:Hello.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#!/usr/bin/env python3   #可以让这个文件直接在Unix/Linux/Mac上运行</span></span><br><span class="line"><span class="hljs-comment">#-*- coding: utf-8 -*-   #表示该文件本身使用标准UTF-8编码</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-string">"this is test"</span>           <span class="hljs-comment">#表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="hljs-string">"zlw"</span>       <span class="hljs-comment">#作者</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dog</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">private_1</span><span class="hljs-params">(name)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, %s'</span> % name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">private_2</span><span class="hljs-params">(name)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi, %s'</span> % name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__test2</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"我是私有方法,只有本模块才调用"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test3</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"我是test3"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__test4</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"我是test4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#当该模块被直接执行时，条件成立，执行指定的入口模块代码，</span></span><br><span class="line"><span class="hljs-comment"># 否则什么也不做。就相当于手动给py模块指定一个main函数一样，</span></span><br><span class="line"><span class="hljs-comment"># 如果未指定直接运行py模块会从上到下依次执行。</span></span><br><span class="line"><span class="hljs-comment">#if __name__=='__main__':</span></span><br><span class="line"><span class="hljs-comment">#    test1()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是调用上面编写的模块:</p><figure class="highlight python hljs"><figcaption><span>title:test.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Hello</span><br><span class="line">print(<span class="hljs-string">"我是模块B"</span>)</span><br><span class="line">Hello.dog.private_1(<span class="hljs-string">"zlw"</span>)</span><br><span class="line">Hello.dog.test3(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。</span></span><br><span class="line"><span class="hljs-comment">#_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *</span></span><br><span class="line"><span class="hljs-comment">#__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</span></span><br><span class="line"><span class="hljs-comment">#foo:就是public方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>紧接着是(object)，表示该类是从哪个类继承下来的，如果没有合适的继承类，就使用object类，</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-comment">#创建实例的时候，就把name，score等属性绑上去</span></span><br><span class="line">    <span class="hljs-comment">#注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，</span></span><br><span class="line">    <span class="hljs-comment"># 在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</span></span><br><span class="line">    <span class="hljs-comment">#除此之外，类的方法和普通函数没有什么区别</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printScore</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"name=%s,score=%s"</span> %(self.__name,self.__score))</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.__name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_score</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.__score</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self,name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_score</span><span class="hljs-params">(self,score)</span>:</span></span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Student(<span class="hljs-string">"zlw"</span>,<span class="hljs-number">100</span>)</span><br><span class="line"><span class="hljs-comment">#绑定属性</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="hljs-comment"># print(a.name,a.score)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#数据封装 这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</span></span><br><span class="line">a.printScore()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private）</span></span><br><span class="line">print(a.get_name(),a.get_score())</span><br><span class="line">a.set_name(<span class="hljs-string">"zlwzlwzlw"</span>)</span><br><span class="line">a.set_score(<span class="hljs-number">11111</span>)</span><br><span class="line">print(a.get_name(),a.get_score())</span><br><span class="line"><span class="hljs-comment">#在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的</span></span><br><span class="line"><span class="hljs-comment"># ，是特殊变量，特殊变量是可以直接访问的，</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！</span></span><br><span class="line"><span class="hljs-comment"># 内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给a新增了一个__name变量。</span></span><br><span class="line">a.__name = <span class="hljs-string">"zzzzz"</span></span><br><span class="line">print(a.__name)</span><br><span class="line">print(a.get_name())</span><br></pre></td></tr></table></figure><h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"This is Animal"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#子类的run()覆盖了父类的run()</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><span class="hljs-params">(Animal)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span> <span class="hljs-comment">#</span></span><br><span class="line">        print(<span class="hljs-string">"This is Dog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span><span class="hljs-params">(Animal)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"This is Cat"</span>)</span><br><span class="line"></span><br><span class="line">Dog().run()</span><br><span class="line">Cat().run()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#当我们定义一个class的时候，我们实际上就定义了一种数据类型。</span></span><br><span class="line"><span class="hljs-comment"># 我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</span></span><br><span class="line">a = list()</span><br><span class="line">b = Animal()</span><br><span class="line">c = Dog()</span><br><span class="line"></span><br><span class="line">print(isinstance(a,list),isinstance(b,Animal),isinstance(c,Dog))</span><br><span class="line"><span class="hljs-comment"># 因为Dog是是从Animal继承下来的, dog本是Animal的一种,但Animal不都是dog</span></span><br><span class="line">print(isinstance(c,Animal))</span><br><span class="line">a = Animal()</span><br><span class="line">print(isinstance(a,Dog))</span><br><span class="line"><span class="hljs-comment">#对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</span></span><br><span class="line"><span class="hljs-comment">#对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Timer</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"stars!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</span></span><br><span class="line"><span class="hljs-comment">#Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</span></span><br></pre></td></tr></table></figure><p>判断对象类型<br>使用type()函数,判断一个对象是否是函数</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="hljs-number">123</span>))</span><br><span class="line">print(type(a))</span><br><span class="line">print(type(c))</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"---------------"</span>)</span><br><span class="line"><span class="hljs-comment">#types模块中定义的常量,</span></span><br><span class="line"><span class="hljs-keyword">import</span> types</span><br><span class="line">print(type(a.run())==types.FunctionType)</span><br><span class="line">print(type(<span class="hljs-keyword">lambda</span> x,y:x * y)==types.LambdaType)</span><br><span class="line">print(type(x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))==types.GeneratorType)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#isinstance</span></span><br><span class="line">print(isinstance([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],(list,tuple)))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#dir() 获得一个对象的所有属性和方法,返回一个包含字符串的list</span></span><br><span class="line">lista = dir(c)</span><br><span class="line"><span class="hljs-comment">#for x in lista:</span></span><br><span class="line"><span class="hljs-comment">#    print(x)</span></span><br><span class="line"><span class="hljs-comment">#获得指定的属性 getattr() setattr() hasattr()</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myobject</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="hljs-number">9</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">power</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">         <span class="hljs-keyword">return</span> self.x * self.x</span><br><span class="line"></span><br><span class="line">a1 = Myobject();</span><br><span class="line"><span class="hljs-comment"># self.__x 则访问不了</span></span><br><span class="line">print(getattr(a1,<span class="hljs-string">"x"</span>))</span><br><span class="line">print(setattr(a1,<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"zlwzlw"</span>))</span><br><span class="line">print(hasattr(a1,<span class="hljs-string">"zlw"</span>))</span><br><span class="line">print(getattr(a1,<span class="hljs-string">"zlw"</span>))</span><br><span class="line">print(a1.x,a1.zlw)</span><br><span class="line"><span class="hljs-comment"># AttributeError: 'Myobject' object has no attribute 'y'</span></span><br><span class="line"><span class="hljs-comment"># print(getattr(a1,"y"))</span></span><br><span class="line">print(getattr(a1,<span class="hljs-string">"power"</span>)())</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student1</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    name = <span class="hljs-string">"zlwzlw"</span> <span class="hljs-comment">#可以直接在class中定义属性，这种属性是类属性，归Student1类所有</span></span><br><span class="line">                    <span class="hljs-comment">#这个属性虽然归类所有，但类的所有实例都可以访问到</span></span><br><span class="line"></span><br><span class="line">a = Student1();</span><br><span class="line">print(a.name)</span><br><span class="line">b = Student1();</span><br><span class="line">print(b.name)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分主要是对于Python的面向对象编程的描述和一部分模块知识的梳理.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇4</title>
    <link href="http://yoursite.com/2019/12/14/Python-%E5%85%A5%E9%97%A8%E7%AF%874/"/>
    <id>http://yoursite.com/2019/12/14/Python-入门篇4/</id>
    <published>2019-12-14T09:00:53.000Z</published>
    <updated>2019-12-14T12:16:07.207Z</updated>
    
    <content type="html"><![CDATA[<p>这部分是关于函数式编程,<b>函数式编程关心数据的映射,命令式编程关心解决问题的步骤</b></p><a id="more"></a><p>函数本身也可以赋值给变量,即：变量可以指向函数。函数名其实就是指向函数的变量！<br>既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数。函数式编程就是指这种高度抽象的编程范式。</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map()函数接收两个参数,一个是函数,一个是Iterable,<br>map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x * x</span><br><span class="line">zzz = map(f,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> zzz:</span><br><span class="line">    print(x)</span><br><span class="line">z= list(map(str,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]))</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure><h3 id="reduce-跟java8中的reduce相似"><a href="#reduce-跟java8中的reduce相似" class="headerlink" title="reduce (跟java8中的reduce相似)"></a>reduce (跟java8中的reduce相似)</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(x,x1)</span>:</span> <span class="hljs-comment">#第一个参数是之前累积的数(初始值是第一个元素),第二个是下一个跟数</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + x1</span><br><span class="line">zlw = reduce(f1,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]) <span class="hljs-comment"># f1这个函数必须接收两个参数,也可以用lambda表达式来</span></span><br><span class="line">print(zlw)</span><br><span class="line">print(reduce(<span class="hljs-keyword">lambda</span> x1 ,x2: x1 *<span class="hljs-number">100</span> +x2,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]))</span><br></pre></td></tr></table></figure><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h3><p>用于过滤序列.跟java8 stream 很相似filter()函数返回的是一个Iterator,<br>也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(filter(<span class="hljs-keyword">lambda</span> n: n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>,list(range(<span class="hljs-number">1</span>,<span class="hljs-number">21</span>)))))</span><br></pre></td></tr></table></figure><h3 id="sorted-排序函数"><a href="#sorted-排序函数" class="headerlink" title="sorted()排序函数"></a>sorted()排序函数</h3><p>key函数返回的结果进行排序<br>sorted(迭代对象,key函数,reverse=True反向排序)</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([<span class="hljs-number">1</span>,<span class="hljs-number">65</span>,<span class="hljs-number">23</span>,<span class="hljs-number">91</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">48</span>,<span class="hljs-number">-99</span>]))</span><br><span class="line">print(sorted([<span class="hljs-number">1</span>,<span class="hljs-number">65</span>,<span class="hljs-number">23</span>,<span class="hljs-number">91</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">48</span>,<span class="hljs-number">-99</span>],key=abs))</span><br><span class="line">print(sorted([<span class="hljs-string">"Zlw"</span>,<span class="hljs-string">"restore"</span>,<span class="hljs-string">"Reputation"</span>,<span class="hljs-string">"abc"</span>],key=str.lower))</span><br><span class="line">print(sorted([<span class="hljs-number">1</span>,<span class="hljs-number">65</span>,<span class="hljs-number">23</span>,<span class="hljs-number">91</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">48</span>,<span class="hljs-number">-99</span>],key=abs,reverse=<span class="hljs-literal">True</span>))</span><br><span class="line">L = [(<span class="hljs-string">'Bob'</span>, <span class="hljs-number">75</span>), (<span class="hljs-string">'Adam'</span>, <span class="hljs-number">92</span>), (<span class="hljs-string">'Bart'</span>, <span class="hljs-number">66</span>), (<span class="hljs-string">'Lisa'</span>, <span class="hljs-number">88</span>)]</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">t1</span><span class="hljs-params">(L)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> L[<span class="hljs-number">1</span>];</span><br><span class="line">print(sorted(L,key=t1,reverse=<span class="hljs-literal">True</span>))</span><br></pre></td></tr></table></figure><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">(*args)</span>:</span></span><br><span class="line">    ax = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> args:</span><br><span class="line">        ax = ax + x</span><br><span class="line">    <span class="hljs-keyword">return</span> ax</span><br><span class="line">print(sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>))</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy</span><span class="hljs-params">(*args)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span>:</span></span><br><span class="line">        ax = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> args:</span><br><span class="line">            ax = ax + x</span><br><span class="line">        <span class="hljs-keyword">return</span> ax</span><br><span class="line">    <span class="hljs-keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">print(lazy(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)())</span><br></pre></td></tr></table></figure><p>我们在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,<br>当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”的程序.<br>【注】返回的函数并没有立刻执行,而是直到调用了f()才执行</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><font color="red">闭包</font></h4><p>闭包：如果在一个内部函数里对外部函数（不是在全局作用域）的变量进行引用,内部函数就被认为是闭包。</p><h4 id="闭包产生条件"><a href="#闭包产生条件" class="headerlink" title="闭包产生条件"></a>闭包产生条件</h4><p>1.必须包含一个嵌套函数<br>2.嵌套函数必须引用封闭函数中定义的值（自由变量）<br>3.封闭函数必须返回嵌套函数</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>):</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span></span><br><span class="line">            <span class="hljs-keyword">return</span> x * x</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="hljs-keyword">return</span> fs</span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(f1())</span><br><span class="line">print(f2())</span><br><span class="line">print(f3())</span><br><span class="line"><span class="hljs-comment">#返回函数不要引用任何循环变量,或者后续会发生变化的变量。</span></span><br><span class="line"><span class="hljs-comment">#因为调用count()方法for循环了三次1-&gt;2-&gt;3,i的值为三,但内嵌的函数并没执行.</span></span><br><span class="line"><span class="hljs-comment">#等到3个函数都返回时,它们所引用的变量i已经变成了3,因此最终结果为9。</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>关键字lambda表示匿名函数,冒号前面的x表示函数参数。不用写return,返回值就是该表达式的结果。</p><h3 id="装饰器-python装饰器（fuctional-decorators）"><a href="#装饰器-python装饰器（fuctional-decorators）" class="headerlink" title="装饰器 python装饰器（fuctional decorators）"></a>装饰器 python装饰器（fuctional decorators）</h3><p>就是用于拓展原来函数功能的一种函数,目的是在不改变原函数名(或类名)的情况下给函数增加新的功能。<br>在函数调用前后自动打印日志,但又不希望修改f()函数的定义<br>这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(f1)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(a)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"call %s()"</span> % f1.__name__)</span><br><span class="line">        <span class="hljs-keyword">return</span> f1(a)</span><br><span class="line">    <span class="hljs-keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@log</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">print(f1(<span class="hljs-number">10</span>),f1.__name__)</span><br><span class="line"><span class="hljs-comment">#1.带有固定参数的装饰器</span></span><br><span class="line"><span class="hljs-comment">#def wrapper(a):</span></span><br><span class="line"><span class="hljs-comment">#2.无固定参数的装饰器</span></span><br><span class="line"><span class="hljs-comment">#def wrapper(*args, **kwargs):</span></span><br><span class="line"><span class="hljs-comment">#3.使用多个装饰器,装饰一个函数（套娃）</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#import functools</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log2</span><span class="hljs-params">(zlw1)</span>:</span></span><br><span class="line"><span class="hljs-comment">#    @functools.wraps(zlw1)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="hljs-string">"call %s() "</span> % zlw1.__name__)</span><br><span class="line">        <span class="hljs-keyword">return</span> zlw1(*args, **kwargs)</span><br><span class="line">    <span class="hljs-keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logzlw</span><span class="hljs-params">(text)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log3</span><span class="hljs-params">(zlw1)</span>:</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="hljs-string">"x是百位,y是十位,z是个位 %s"</span> %text)</span><br><span class="line">            <span class="hljs-keyword">return</span> zlw1(*args, **kwargs)</span><br><span class="line">        <span class="hljs-keyword">return</span> wrapper</span><br><span class="line">    <span class="hljs-keyword">return</span> log3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@log2</span></span><br><span class="line"><span class="hljs-meta">@logzlw("zlwzlwzlw")</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zlw1</span><span class="hljs-params">(x,y,z)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> x * <span class="hljs-number">100</span> + y * <span class="hljs-number">10</span> + z</span><br><span class="line"><span class="hljs-comment"># log2(log3(zlw(9,8,7)))</span></span><br><span class="line">print(zlw1(<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>),zlw1.__name__)</span><br><span class="line"><span class="hljs-comment">#由于log()是一个decorator,返回一个函数,所以,原来的now()函数仍然存在</span></span><br><span class="line"><span class="hljs-comment">#只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数。</span></span><br></pre></td></tr></table></figure><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>import functools<br>int8 = functools.partial(int,base=8) #八进制转10<br>print(int8(“123124”))<br>int2 = functools.partial(int,base=2)#二进制转10<br>print(int2(“111111111111111”))</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分是关于函数式编程,&lt;b&gt;函数式编程关心数据的映射,命令式编程关心解决问题的步骤&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇3</title>
    <link href="http://yoursite.com/2019/12/13/Python-%E5%85%A5%E9%97%A8%E7%AF%873/"/>
    <id>http://yoursite.com/2019/12/13/Python-入门篇3/</id>
    <published>2019-12-13T09:47:36.000Z</published>
    <updated>2019-12-14T08:59:54.368Z</updated>
    
    <content type="html"><![CDATA[<p>这部分是关于Python的高级特性</p><a id="more"></a><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>就是取list跟tuple,如刀切一般,取出部分元素<br>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3,那么它同样支持倒数切片</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="hljs-string">"ZLW1"</span>,<span class="hljs-string">"ZLW2"</span>,<span class="hljs-string">"ZLW3"</span>,<span class="hljs-string">"ZLW4"</span>,<span class="hljs-string">"ZLW5"</span>,<span class="hljs-string">"ZLW6"</span>]</span><br><span class="line">print(L[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])</span><br><span class="line">print(L[<span class="hljs-number">-1</span>:])</span><br><span class="line">print(L[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-comment">#前二 跟后二</span></span><br><span class="line">print(L[:<span class="hljs-number">2</span>])</span><br><span class="line">print(L[<span class="hljs-number">-2</span>:])</span><br><span class="line"><span class="hljs-comment">#前面5,每隔2个取一个</span></span><br><span class="line">print(L[:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-comment">#所有数，每5个取一个</span></span><br><span class="line">print(L[::<span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-comment">#甚至什么都不写，只写[:]就可以原样复制一个list：</span></span><br><span class="line"><span class="hljs-comment">#tuple</span></span><br><span class="line">T = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)</span><br><span class="line">print(T[::<span class="hljs-number">2</span>])</span><br><span class="line"><span class="hljs-comment">#String也可以切片</span></span><br><span class="line">print(<span class="hljs-string">"abcdefghijklmn"</span>[:<span class="hljs-number">10</span>])</span><br><span class="line">print(<span class="hljs-string">"abcdefghijklmn"</span>[<span class="hljs-number">-10</span>:])</span><br><span class="line">print(<span class="hljs-string">"abcdefghijklmn"</span>[::<span class="hljs-number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="hljs-string">"a"</span>:<span class="hljs-number">123</span>,<span class="hljs-string">"b"</span>:<span class="hljs-number">345</span>,<span class="hljs-string">"c"</span>:<span class="hljs-number">678</span>&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> k,values <span class="hljs-keyword">in</span> d.items(): <span class="hljs-comment"># d.values()  d.items()</span></span><br><span class="line">    print(k,values)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#使用for循环时,只要作用于一个可迭代对象,for循环就可以正常运行.</span></span><br><span class="line"><span class="hljs-comment">#collections模块的Iterable类型判断 还可以判断其他类型 isinstance(x, str)</span></span><br><span class="line"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable <span class="hljs-comment">#加.abc</span></span><br><span class="line">print(isinstance(<span class="hljs-string">"ABCDEF"</span>,Iterable))</span><br><span class="line">print(isinstance([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">34</span>],Iterable))</span><br><span class="line">print(isinstance(<span class="hljs-number">1234</span>,Iterable))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python内置的enumerate函数可以把一个list变成索引-元素对,跟java一样可以用下标访问</span></span><br><span class="line">L = [<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"D"</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> x,values <span class="hljs-keyword">in</span> enumerate(L):</span><br><span class="line">    print(x,values)</span><br></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(list(range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)))</span><br><span class="line">L = []</span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):</span><br><span class="line">    L.append(x * x)</span><br><span class="line">print(L)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，</span></span><br><span class="line"><span class="hljs-comment"># 十分有用,for循环后面还可以加上if判断,还可以使用两层循环</span></span><br><span class="line">list = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]</span><br><span class="line">print(list)</span><br><span class="line">i = <span class="hljs-number">0</span></span><br><span class="line">print([A + B <span class="hljs-keyword">for</span> A <span class="hljs-keyword">in</span> <span class="hljs-string">"ABCDE"</span> <span class="hljs-keyword">for</span> B <span class="hljs-keyword">in</span> <span class="hljs-string">"FGHIJ"</span>])</span><br><span class="line"></span><br><span class="line">L = [<span class="hljs-string">"HOLLE"</span>,<span class="hljs-string">"WORD"</span>,<span class="hljs-string">"PYTHON"</span>]</span><br><span class="line">print([x.lower() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> L])</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？<br>这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>只要把一个列表生成式的[]改成()，就创建了一个generator：<br>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>))</span><br><span class="line">print(next(g),next(g),next(g),next(g),next(g)) <span class="hljs-comment">#太麻烦了,用for</span></span><br><span class="line"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:  <span class="hljs-comment">#之前</span></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#斐波拉契数列</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a+b <span class="hljs-comment">#相当于把这两个数组装了成一个tuple t = (b, a + b) # a = t[0] b =t[1]</span></span><br><span class="line">        n += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"done"</span></span><br><span class="line">fib(<span class="hljs-number">20</span>)</span><br><span class="line"><span class="hljs-comment">#可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</span></span><br><span class="line"><span class="hljs-comment">#只需要把print(b)改为yield b,如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib1</span><span class="hljs-params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="hljs-keyword">yield</span> b</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        n += <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"done"</span></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> fib1(<span class="hljs-number">10</span>):</span><br><span class="line">    print(x)</span><br><span class="line"><span class="hljs-comment">#generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</span></span><br><span class="line"><span class="hljs-comment"># 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</span></span><br><span class="line"><span class="hljs-comment">#在执行过程中，遇到yield就中断，下次又继续执行。</span></span><br><span class="line"><span class="hljs-comment">#发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value</span></span><br><span class="line">print(<span class="hljs-string">"----------------"</span>)</span><br><span class="line">g = fib1(<span class="hljs-number">10</span>)</span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:</span><br><span class="line">    <span class="hljs-keyword">try</span>:</span><br><span class="line">        print(next(g))</span><br><span class="line">    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:</span><br><span class="line">        print(<span class="hljs-string">"StopIteration!!"</span>,e.value)</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>可以直接作用于for循环的对象统称为可迭代对象：Iterable。（String,list,tuple,dict,set）,Iterable变成Iterator可以使用iter()函数：<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>可以使用isinstance()判断一个对象是否是Iterator对象：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(isinstance((x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)),Iterable))</span><br><span class="line">print(isinstance(<span class="hljs-number">123</span>,Iterable))</span><br><span class="line"></span><br><span class="line">L = iter([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])</span><br><span class="line">print(next(L))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#S = [1,2,3,4,5]</span></span><br><span class="line"><span class="hljs-comment">#print(next(S))</span></span><br><span class="line"><span class="hljs-comment">#这样会报错 TypeError: 'list' object is not an iterator 不是迭代器对象</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Iterator甚至可以表示一个无限大的数据流,同样也是堕性的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分是关于Python的高级特性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇2</title>
    <link href="http://yoursite.com/2019/12/13/Python-%E5%85%A5%E9%97%A8%E7%AF%872/"/>
    <id>http://yoursite.com/2019/12/13/Python-入门篇2/</id>
    <published>2019-12-13T02:09:21.000Z</published>
    <updated>2019-12-13T07:40:14.339Z</updated>
    
    <content type="html"><![CDATA[<p>大部分是关于函数及其参数的记录.</p><a id="more"></a><p>help() 帮助函数</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>将其他类型转化成本类型<br>int()<br>float()<br>bool()<br>str()<br>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”<br>a = max<br>print(a(1,2,3,4,99,44,77))</p><p>空函数(pass语句表示什么都不做,可以在其他语句中出现,有占位符的意思)<br>def nop():<br>pass</p><p>数据类型检查可以用内置函数isinstance()<br>if not isinstance(x, (int, float)):<br>raise TypeError(‘bad operand type’)</p><p>Python中的函数可以返回多个值(但其实这只是一种假象,Python函数返回的仍然是单一值,返回值是一个tuple！)<br>def cheng(x,y):<br>a = x * x<br>b = y * y<br>return a,b;<br>print(cheng(3,5)[0])</p><p>默认参数 (<font color="red">默认参数必须指向不变对象！</font> )<br>def d1(x,y=”zlw”):<br>print(“name”,y)<br>print(“x”,x)</p><p>d1(“qweq12123we”)<br>d1(“qweqwe”,”ZLWZLW”)<br>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。<br>d1(“qweq12123we”,y=”zlwzlw”,z=18)</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">a = max</span><br><span class="line">print(a(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">99</span>,<span class="hljs-number">44</span>,<span class="hljs-number">77</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zlw</span><span class="hljs-params">(x)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(x,(float,int)):</span><br><span class="line">        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"Type Error!"</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span>:</span><br><span class="line">        print(<span class="hljs-string">"YES! I M"</span>)</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        print(<span class="hljs-string">"NO! NO! NO!"</span>)</span><br><span class="line"></span><br><span class="line">zlw(<span class="hljs-number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nop</span><span class="hljs-params">()</span>:</span></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cheng</span><span class="hljs-params">(x,y)</span>:</span></span><br><span class="line">    a = x * x</span><br><span class="line">    b = y * y</span><br><span class="line">    <span class="hljs-keyword">return</span> a,b;</span><br><span class="line"></span><br><span class="line">print(cheng(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)[<span class="hljs-number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d1</span><span class="hljs-params">(x,z=<span class="hljs-number">18</span>,y=<span class="hljs-string">"zlw"</span>)</span>:</span></span><br><span class="line">    print(<span class="hljs-string">"name"</span>,y)</span><br><span class="line">    print(<span class="hljs-string">"age"</span>,z)</span><br><span class="line">    print(<span class="hljs-string">"x"</span>,x)</span><br><span class="line"></span><br><span class="line">d1(<span class="hljs-string">"qweq12123we"</span>,y=<span class="hljs-string">"zlwzlw"</span>,z=<span class="hljs-number">18</span>)</span><br><span class="line">d1(<span class="hljs-string">"qweqwe"</span>,<span class="hljs-number">15</span>,<span class="hljs-string">"ZLWZLW"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，</span></span><br><span class="line"><span class="hljs-comment"># 如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d2</span><span class="hljs-params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="hljs-string">"END"</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> L</span><br><span class="line">print(d2([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))</span><br><span class="line">print(d2())</span><br><span class="line">print(d2())</span><br><span class="line">print(d2())</span><br><span class="line">print(d2())</span><br><span class="line"><span class="hljs-comment">#可以用None这个不变对象</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d3</span><span class="hljs-params">(L=None)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="hljs-string">"END"</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> L</span><br><span class="line">print(d3())</span><br><span class="line">print(d3())</span><br><span class="line">print(d3())</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#可变参数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">d4</span><span class="hljs-params">(*numbers)</span>:</span> <span class="hljs-comment">#这里加*是把参数列表封装成一个tuple</span></span><br><span class="line">    sum = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> numbers:</span><br><span class="line">        print(x+sum)</span><br><span class="line">        sum += x</span><br><span class="line">d4(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span><br><span class="line"><span class="hljs-comment">#如果已经有一个list或者tuple</span></span><br><span class="line">list = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">70</span>]</span><br><span class="line">d4(*list)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#关键字参数</span></span><br><span class="line"><span class="hljs-comment">#关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person</span><span class="hljs-params">(name,age, **k)</span>:</span> <span class="hljs-comment">#def person(name, age, *, city, job):</span></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-string">"city"</span> <span class="hljs-keyword">in</span> k:</span><br><span class="line">        print(<span class="hljs-string">"YES!!"</span>)</span><br><span class="line">    print(<span class="hljs-string">"name"</span>,name,<span class="hljs-string">"age"</span>,age,<span class="hljs-string">"other"</span>,k)</span><br><span class="line"></span><br><span class="line">person(<span class="hljs-string">"zlw"</span>,<span class="hljs-number">18</span>)</span><br><span class="line">Map = &#123;<span class="hljs-string">"city"</span>:<span class="hljs-string">"jingmen"</span>,<span class="hljs-string">"job"</span>:<span class="hljs-string">"XS"</span>&#125;</span><br><span class="line"></span><br><span class="line">person(<span class="hljs-string">"zlwzlw"</span>,<span class="hljs-number">111</span>,**Map)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#参数组合</span></span><br><span class="line"><span class="hljs-comment">#在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，</span></span><br><span class="line"><span class="hljs-comment"># 这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：</span></span><br><span class="line"><span class="hljs-comment"># 必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#递归函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span><span class="hljs-params">(n)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> n * fact(n<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(fact(<span class="hljs-number">10</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分是关于函数及其参数的记录.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-入门篇1</title>
    <link href="http://yoursite.com/2019/12/12/Python-%E5%85%A5%E9%97%A8%E7%AF%871/"/>
    <id>http://yoursite.com/2019/12/12/Python-入门篇1/</id>
    <published>2019-12-12T13:28:51.000Z</published>
    <updated>2019-12-14T08:56:55.906Z</updated>
    
    <content type="html"><![CDATA[<p>因为比较好奇爬虫技术,对比了一下,Java写爬虫的话比较麻烦,所以花点时间去学习一下Python</p><a id="more"></a><p><img src="/images/Python%E5%85%A5%E9%97%A8%E5%9B%BE.jpg" alt></p><h3 id="输入函数-input"><a href="#输入函数-input" class="headerlink" title="输入函数 input()"></a>输入函数 input()</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="hljs-string">"Hello"</span>,<span class="hljs-string">"Word"</span>,<span class="hljs-string">"Python!"</span>)</span><br><span class="line">print(<span class="hljs-number">1000</span>+<span class="hljs-number">1000</span>)</span><br><span class="line"><span class="hljs-comment">#name = input("请输入名字:")</span></span><br><span class="line"><span class="hljs-comment">#print("hello:",name)</span></span><br><span class="line"><span class="hljs-comment">#print("1024*768=",1024*768)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#字符串可以用这两个表示 "" '' 如果""中有'转义字符\,例如一下</span></span><br><span class="line"><span class="hljs-comment">#\n表示换行,\t表示制表符,字符\本身也要转义,所以\\表示的字符就是\</span></span><br><span class="line">print(<span class="hljs-string">'I\'m \"OK!\"'</span>)</span><br><span class="line">print(<span class="hljs-string">'I\'m \n \"OK!\"'</span>)</span><br><span class="line">print(<span class="hljs-string">'I\'m \t \\ \"OK!\"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python还允许用r''表示''内部的字符串默认不转义</span></span><br><span class="line">print(<span class="hljs-string">r'I\'m \t \\ \"OK!\"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python允许用'''...'''的格式表示多行内容 ,在交互式命令行中  &gt;&gt;&gt; 变成 ...</span></span><br><span class="line">print(<span class="hljs-string">'''zlw1 </span></span><br><span class="line"><span class="hljs-string">zlw2</span></span><br><span class="line"><span class="hljs-string">zlw3 '''</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># True 和False , or and not</span></span><br><span class="line">print(<span class="hljs-literal">True</span>)</span><br><span class="line">print(<span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>)</span><br><span class="line">print(<span class="hljs-string">"---------------"</span>)</span><br><span class="line">print(<span class="hljs-string">"and"</span>,<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-string">"or"</span>,<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-string">"not"</span>, <span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python中空值是 None</span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>这种变量本身类型不固定的语言称之为动态语言,与之对应的是静态语言.<br>静态语言在定义变量时必须指定变量类型,如果赋值的时候类型不匹配,就会报错.<br><font color="red">Python 对缩进很敏感 tab和空格的混用会导致错误</font></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">123</span></span><br><span class="line">print(a)</span><br><span class="line">a = <span class="hljs-string">"123123"</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">x = <span class="hljs-number">10</span></span><br><span class="line">print(x)</span><br><span class="line">x = x + <span class="hljs-number">10</span></span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在Python中,通常用全部大写的变量名表示常量：</span></span><br><span class="line">PI = <span class="hljs-number">3.1415926</span></span><br><span class="line">print(PI)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在Python中,有两种除法 1./(有小数) 2.//(只有整数)</span></span><br><span class="line">print(<span class="hljs-number">10</span>/<span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">10</span>//<span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#Python中字符串是Unicode编码 ord() 获得整数的值 chr()根据整数转字符</span></span><br><span class="line">print(ord(<span class="hljs-string">"A"</span>),ord(<span class="hljs-string">"中"</span>),chr(<span class="hljs-number">65</span>),chr(<span class="hljs-number">97</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#由于Python的字符串类型是str,在内存中以Unicode表示,一个字符对应若干个字节.</span></span><br><span class="line"><span class="hljs-comment"># 如果要在网络上传输,或者保存到磁盘上,就需要把str变为以字节为单位的bytes.</span></span><br><span class="line">print(<span class="hljs-string">"周李伟"</span>.encode(<span class="hljs-string">"utf-8"</span>))</span><br><span class="line">print(len(<span class="hljs-string">"zlwzlwlaqweqwe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#第一行注释是为了告诉Linux/OS X系统,这是一个Python可执行程序,Windows系统会忽略这个注释；</span></span><br><span class="line"><span class="hljs-comment">#第二行注释是为了告诉Python解释器,按照UTF-8编码读取源代码,否则,你在源代码中写的中文输出可能会有乱码.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#格式化跟C一样 %d整数</span></span><br><span class="line"><span class="hljs-comment">#             %f浮点数</span></span><br><span class="line"><span class="hljs-comment">#             %s字符串（它会把任何数据类型转换为字符串）</span></span><br><span class="line"><span class="hljs-comment">#             %x十六进制整数</span></span><br><span class="line">print(<span class="hljs-string">"zlw是%d个%s"</span> %(<span class="hljs-number">1</span>,<span class="hljs-string">"废物"</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python中的list,list是一个可变的有序表,list里面的<font color="red">元素的数据类型也可以不同</font>,list元素也可以是另一个list</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="hljs-string">"ZLW1"</span>,<span class="hljs-string">"ZLW2"</span>,<span class="hljs-string">"ZLW3"</span>]</span><br><span class="line">print(len(list))</span><br><span class="line"><span class="hljs-comment">#print(list[2])</span></span><br><span class="line"><span class="hljs-comment">#print(list[-1]) #倒数第一个数,以此类推</span></span><br><span class="line">list.append(<span class="hljs-string">"zlw4"</span>)</span><br><span class="line">list.insert(<span class="hljs-number">1</span>,<span class="hljs-string">"zlwzlw"</span>)</span><br><span class="line">list.pop()</span><br><span class="line">list.pop(<span class="hljs-number">0</span>)</span><br><span class="line">list[<span class="hljs-number">1</span>]=<span class="hljs-string">"ZZZZZZZ"</span></span><br><span class="line"><span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> list:</span><br><span class="line">    print(z)</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"------------"</span>)</span><br><span class="line"><span class="hljs-comment">#二维数组</span></span><br><span class="line">s = [<span class="hljs-string">"JAVA"</span>,[<span class="hljs-string">"C++"</span>,<span class="hljs-string">"C#"</span>,<span class="hljs-string">"C"</span>],<span class="hljs-string">"Python"</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> s:</span><br><span class="line">    print(s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple,tuple和list非常类似,但是<font color="red">tuple一旦初始化就不能修改</font>,tuple的陷阱,<br>当你定义一个tuple时,在定义的时候,tuple的元素就必须被确定下来<br>这是因为括号()既可以表示tuple,又可以表示数学公式中的小括号,<br>这就产生了歧义,因此,Python规定,这种情况下,按小括号进行计算,计算结果自然是1.<br>所以,只有1个元素的tuple定义时必须加一个逗号,来消除歧义.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br><span class="line">t = (<span class="hljs-number">1</span>,)</span><br><span class="line"><span class="hljs-keyword">for</span> t1 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t1)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#tuple所谓的“不变”是说,tuple的每个元素,指向永远不变.那么他指向的list的不会改变,就并不代表list中的值不可改变</span></span><br><span class="line">t = (<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,[<span class="hljs-string">"ZLW"</span>,<span class="hljs-string">"ZLW"</span>])</span><br><span class="line"><span class="hljs-keyword">for</span> t2 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t2)</span><br><span class="line">t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">"周李伟是废物"</span></span><br><span class="line"><span class="hljs-keyword">for</span> t2 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t2)</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>根据Python的缩进规则,如果if语句判断是True,就把缩进的两行print语句执行了,否则,什么也不做.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">33</span>:</span><br><span class="line">    print(<span class="hljs-string">"you age"</span>,age)</span><br><span class="line"><span class="hljs-keyword">elif</span> age &gt; <span class="hljs-number">18</span>:</span><br><span class="line">    print(<span class="hljs-string">"！！！！！"</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">"?????"</span>)</span><br><span class="line"><span class="hljs-comment">#elif else if的缩写</span></span><br><span class="line"><span class="hljs-comment">#if语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else</span></span><br><span class="line"><span class="hljs-comment">#birth = input("请输入您的生日");</span></span><br><span class="line"><span class="hljs-comment"># 这里面input输入进来的是字符串类型不能直接跟Int类型对比,需要用int()函数进行转化,当然你输入的是字符也不行,也不能跟进行比较</span></span><br><span class="line"><span class="hljs-comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="hljs-comment">#  File "D:/PythonWork/Zlw.py", line 125, in &lt;module&gt;</span></span><br><span class="line"><span class="hljs-comment">#    if birth &gt; 2000:</span></span><br><span class="line"><span class="hljs-comment"># TypeError: '&gt;' not supported between instances of 'str' and 'int'</span></span><br><span class="line"><span class="hljs-comment">#if int(birth) &gt; 2000:</span></span><br><span class="line"><span class="hljs-comment">#    print("年轻人")</span></span><br><span class="line"><span class="hljs-comment">#else:</span></span><br><span class="line"><span class="hljs-comment">#    print("老逼")</span></span><br></pre></td></tr></table></figure><h3 id="dict、set和循环"><a href="#dict、set和循环" class="headerlink" title="dict、set和循环"></a>dict、set和循环</h3><p>Python内置了字典：dict的支持,在其他的语言中是Map,使用键-值（key-value）存储.具有极快的查找速度.<br>dict的key必须是不可变对象(要保证hash的正确性)<br>对于不变对象来说,调用对象自身的任意方法,也不会改变该对象自身的内容.相反,这些方法会创建新的对象并返回,这样,就保证了不可变对象本身永远是不可变的.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="hljs-string">"zlw1"</span>:<span class="hljs-number">999</span>,<span class="hljs-string">"zlw2"</span>:<span class="hljs-number">777</span>,<span class="hljs-string">"zlw3"</span>:<span class="hljs-number">222</span>&#125;</span><br><span class="line">print(d[<span class="hljs-string">"zlw1"</span>])</span><br><span class="line"><span class="hljs-comment">#避免key不存在用的错误,有两种方法</span></span><br><span class="line">print(<span class="hljs-string">"zlw"</span> <span class="hljs-keyword">in</span> d)</span><br><span class="line">print(d.get(<span class="hljs-string">"zlw"</span>))</span><br><span class="line">print(d.get(<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"?????"</span>))</span><br><span class="line">d.pop(<span class="hljs-string">"zlw1"</span>)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#set和dict类似,也是一组key的集合,但不存储value,key不能重复.要创建一个set,需要提供一个list作为输入集合</span></span><br><span class="line">d = set([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])</span><br><span class="line">s = set([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">15</span>])</span><br><span class="line">print(d)</span><br><span class="line">d.add(<span class="hljs-number">12</span>)</span><br><span class="line">print(d)</span><br><span class="line">d.remove(<span class="hljs-number">1</span>)</span><br><span class="line">print(d)</span><br><span class="line">print(d &amp; s) <span class="hljs-comment">#交集</span></span><br><span class="line">print(d | s) <span class="hljs-comment">#并集</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#循环</span></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]:</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line">n = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">while</span> sum &lt; <span class="hljs-number">100</span>:</span><br><span class="line">    n += <span class="hljs-number">3</span></span><br><span class="line">    sum += n</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">n = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">100</span>:</span><br><span class="line">    n+=<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">continue</span></span><br><span class="line">    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">50</span>:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    print(n)</span><br><span class="line">print(<span class="hljs-string">"end"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为比较好奇爬虫技术,对比了一下,Java写爬虫的话比较麻烦,所以花点时间去学习一下Python&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>java-8 stream2</title>
    <link href="http://yoursite.com/2019/12/09/java-8-stream2/"/>
    <id>http://yoursite.com/2019/12/09/java-8-stream2/</id>
    <published>2019-12-09T10:26:10.000Z</published>
    <updated>2019-12-11T10:43:35.674Z</updated>
    
    <content type="html"><![CDATA[<p>用流来收集数据<br>收集器用作高级归约预定义收集器的功能以下:<br>1.将流元素归约和汇总为一个值<br>2.元素分组<br>3.元素分区(使用谓词[返回一个布尔值的单参数函数]作为分组函数)</p><a id="more"></a><h3 id="查询流中最大值和最小值"><a href="#查询流中最大值和最小值" class="headerlink" title="查询流中最大值和最小值"></a>查询流中最大值和最小值</h3><p>Collectors.maxBy<br>Collectors.mixBy<br>都是接受一个Comparator(比较器)参数来比较流中的元素.返回一个Optional<t></t></p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>Collectors.summingInt (Double、Long)<br>可接受一个把对象映射为求和所需的int的函数,并返回一个收集器.</p><p>Collectors.averagingInt (Double、Long)<br>求平均值</p><p>Collectors.summarizingInt (Double、Long)<br>一次性 求个数,总和,平均值,最大值,最小值(通过getter取值)</p><p>joining()—&gt;字符串连接方法,方法内部使用StringBuilder拼加,joining(“, “),可以加分隔符</p><p>reducing(0,Dishes::getCalories,Integer::sum);<br>①第一个参数是初始值<br>②第二个参数是转换函数(把流中的值转化成你所需要的类型)<br>③第三个参数是累加函数<br>counting() 就是把每个元素转换成1L,然后在求和.就知道了有多少个元素</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>Collectors.groupingBy(Function[分类函数]Key,Value)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用流来收集数据&lt;br&gt;收集器用作高级归约预定义收集器的功能以下:&lt;br&gt;1.将流元素归约和汇总为一个值&lt;br&gt;2.元素分组&lt;br&gt;3.元素分区(使用谓词[返回一个布尔值的单参数函数]作为分组函数)&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>java-8 stream</title>
    <link href="http://yoursite.com/2019/12/06/java-8-stream/"/>
    <id>http://yoursite.com/2019/12/06/java-8-stream/</id>
    <published>2019-12-06T14:02:54.000Z</published>
    <updated>2019-12-10T04:18:54.565Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.<br>流是java8中一个新的概念,它允许你以<font color="red">声明性</font>方法处理数据集合<br>,类似于SQL语句,可以<font color="red">透明地</font>并行处理.<br>并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！</p><a id="more"></a><h3 id="流的带来的好处有以下"><a href="#流的带来的好处有以下" class="headerlink" title="流的带来的好处有以下:"></a>流的带来的好处有以下:</h3><p>1.声明性——更简洁,更易读<br>2.可复合——更灵活<br>3.可并行——性能更好</p><h3 id="流中的几个概念"><a href="#流中的几个概念" class="headerlink" title="流中的几个概念:"></a>流中的几个概念:</h3><p>1.元素序列—— 集合讲的是数据,流讲的是计算.<br>2.源—— 流会使用一个提供数据的源.<br>3.数据处理操作—— 流的数据处理功能支持类似于数据库的操作,以及函数式编程中常用的操作,可以是顺序或者并行执行.</p><h3 id="流操作两个重要的特点"><a href="#流操作两个重要的特点" class="headerlink" title="流操作两个重要的特点:"></a>流操作两个重要的特点:</h3><p>1.<strong><font color="red">流水线</font></strong>——很多流操作本身会返回一个流,这样多个操作就可以链接起来,形成一个大的流水线.(ps:类似于sql的查找)</p><p>2.<strong><font color="red">内部迭代</font></strong>——于使用迭代器显示迭代的集合不同,流的迭代操作是在背后进行的.</p><p>3.<strong><font color="red">流只能遍历一次,遍历完就已经被消费掉了</font></strong>,可以从原始数据源重新获得一个新的流.反正会报错.</p><p>外部迭代是用户使用Collection接口自己去做迭代.<br>内部迭代是它自动帮你把迭代做了,还把得到的流值存在某个地方,你只需要给出一个函数说要干什么就完事了,是不是很轻松.而且内部迭代是透明地并行处理,或者用更优化的顺序(某些合适你硬件的数据表示)进行处理.</p><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p><strong>中间操作</strong>——会返回另一个流,这样可以多个操作连接起来,更重要的是,<br>除非流水线上触发一个终端操作,否则中间操作不会执行任何处理——他们很懒(惰性求值).<br>这是因为中间操作一般是可以合并起来,在终端操作时一次性全部处理.</p><p><strong>终端操作</strong>——从流的流水线生成结果,<font color="red">其结果是任何不是流的值</font>.(List,Integer,甚至是void)</p><h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>1.一个数据源(如集合)来执行一个查询.<br>2.一个中间操作链,形成一条流的流水线.<br>3.一个终端操作,执行流水线,并能生成结果.</p><h4 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h4><p>用谓词筛选,筛选出各不相同的元素</p><p>filter()—-&gt;该操作会接受一个谓词(一个返回boolean的函数)作为参数,并返回一个包含所有符合谓词的元素的流.</p><p>distinct()—-&gt;它会返回一个元素各异(根据流所生成元素的hashCode和equals方法实现)的流.</p><p>limit()—-&gt;该方法会返回一个不超过给定长度的流.</p><p>skip(n)—-&gt;返回一个扔掉前n个元素的流,如果流中元素不足n个,则返回一个空流.</p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>map()—-&gt;它会接受一个函数作为参数,这个函数会被应用到每个元素上,并将其映射成一个新的元素.</p><p>flatMap()—-&gt;各个数组并不是分别映射成一个流,而是映射成流的内容.也就是生成的单个流被合并起来,即扁平化为一个流.</p><h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><p>anyMatch()—-&gt;检查谓词是否至少匹配一个元素,返回一个boolean,是一个终端操作.</p><p>allMatch()—-&gt;检查谓词是否匹配所有元素.</p><p>noneMacth()—-&gt;确保流中没有任何元素与给定的谓词匹配.<br>以上三个操作都具有<font color="red">短路</font>的特性.(当搜索的条件满足时,就不会继续下去了)</p><p>findAny()—-&gt;返回当前流中的任意元素.</p><p>findFirst()—-&gt;返回当前流中的第一个元素.</p><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>将流中所以元素反复结合起来,得到一个值.这样的查询可以被归类为归约操作.(函数编程的术语为折叠)</p><p>reduce(0,(a,b) -&gt; a + b);<br>或者直接Integer里面的静态sum方法求和<br>reduce(0,Integer::sum);<br>或者求最大值、最小值<br>reduce(0,Integer::min);<br>reduce(0,Integer::max);</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trader zlw1 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw1"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line">        Trader zlw2 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw2"</span>, <span class="hljs-string">"sz"</span>);</span><br><span class="line">        Trader zlw3 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw3"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line">        Trader zlw4 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw4"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transactions&gt; transactions1 = Arrays.asList(</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw4, <span class="hljs-number">2011</span>, <span class="hljs-number">300</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw1, <span class="hljs-number">2012</span>, <span class="hljs-number">1000</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw1, <span class="hljs-number">2011</span>, <span class="hljs-number">400</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw2, <span class="hljs-number">2012</span>, <span class="hljs-number">710</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw2, <span class="hljs-number">2012</span>, <span class="hljs-number">700</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw3, <span class="hljs-number">2012</span>, <span class="hljs-number">950</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//找出2011年发生的交易,并按交易排序(低到高)</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .filter(tran -&gt; tran.getYear() == <span class="hljs-number">2011</span>)</span><br><span class="line">                .sorted(Comparator.comparing(Transactions::getValue))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//交易员在那些不同的城市工作</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .map(transactions2 -&gt; transactions2.getTrader().getCity()).distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//返回所有湖北的交易员,并按姓名排序</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .map(Transactions::getTrader)</span><br><span class="line">                .filter(Trader -&gt; Trader.getCity().equals(<span class="hljs-string">"hb"</span>))</span><br><span class="line">                .distinct().sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//返回所以交易员的姓名字符串,按字母排序  此方法的效率不高 其reduce()中使用String拼接</span></span><br><span class="line">        String reduce = transactions1.stream()</span><br><span class="line">                .map(Transactions -&gt; Transactions.getTrader().getName()).distinct()</span><br><span class="line">                .reduce(<span class="hljs-string">""</span>, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//有没有在sz工作过的</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> sz = transactions1.stream()</span><br><span class="line">                .anyMatch(Transactions -&gt; Transactions.getTrader().getCity().equals(<span class="hljs-string">"sz1"</span>));</span><br><span class="line">        System.out.println(sz);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//打印所以在湖北的交易员的交易额</span></span><br><span class="line">        transactions1</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(transactions -&gt; transactions.getTrader().getCity().equals(<span class="hljs-string">"hb"</span>))</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//输出交易中,交易额最高的交易额</span></span><br><span class="line">        Integer max = transactions1.stream()</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .reduce(Integer::max)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//最小的交易额</span></span><br><span class="line">        Integer min = transactions1.stream()</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h3><p>之前 .reduce(0, Integer::sum),<br>有一个暗含的装箱成本,将每个Integer拆箱成一个原始类型.在进行求和,<br>所以Stream API 提供原始类型流特化,来避免<font color="red">暗含的装箱成本,自动拆箱的操作</font>. IntStream—&gt; int<br>DoubleSteam—&gt; double<br>LongStream—&gt; long</p><p>1.映射到数据流<br>mapToInt()<br>mapToDouble()<br>mapToLong()<br>以上方法很之前的map()的工方式一样,只不过他们返回的是一个特化流,而不是Stream<t>.</t></p><p>2.转换回对象流<br>boxed();<br>特化流转换回非特化流.</p><p>3.默认值OptionalInt<br>如果流为空,那sum默认返回0,那你就无法区别流中是否有元素和最大值就是0的流?<br>所以对于三个原始特化流,就分别有一个Optional原始类型特化版.<br>OptionalInt<br>OptionalDouble<br>OptionalLong</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>第一个参数接受起始值,第二个是参数接受结束值<br>range —&gt; 不包含结束值<br>rangeClosed —&gt; 包含结束值</p><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><p>1.由值创建流<br>Stream.of<br>example: Stream<string>stream = Stream.of(“java”, “c++”, “Python”, “go”);</string></p><p>2.由数组创建流<br>Arrays.stream(),参数传的是什么类型的,Stream就是XXXStream<br>int[] numbers ={1,2,3,4,5,6};<br>int asInt = Arrays.stream(numbers).max().getAsInt();</p><p>3.由文件生成流<br>Files.lines</p><p>4.由函数生成流:创建无限流<br>没有固定的长度,根据函数按需创建值,可以无尽的计算下去.这个流是无界的<br>Stream.iterate<br>新生成的值应用函数</p><figure class="highlight java hljs"><figcaption><span>title:斐波那契数列</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;t[<span class="hljs-number">1</span>],t[<span class="hljs-number">0</span>]+t[<span class="hljs-number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="hljs-number">20</span>)</span><br><span class="line">        .forEach(t -&gt; System.out.print( t[<span class="hljs-number">0</span>]+<span class="hljs-string">" "</span>));</span><br></pre></td></tr></table></figure><p>Stream.generate</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.&lt;br&gt;流是java8中一个新的概念,它允许你以&lt;font color=&quot;red&quot;&gt;声明性&lt;/font&gt;方法处理数据集合&lt;br&gt;,类似于SQL语句,可以&lt;font color=&quot;red&quot;&gt;透明地&lt;/font&gt;并行处理.&lt;br&gt;并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 线性表</title>
    <link href="http://yoursite.com/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/12/04/数据结构-线性表/</id>
    <published>2019-12-04T14:23:25.000Z</published>
    <updated>2019-12-05T15:50:35.601Z</updated>
    
    <content type="html"><![CDATA[<p>线性表的知识是之后的基础,一定要完全掌握.</p><a id="more"></a><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表是具有相同特性数据元素的一个<strong><font color="red">有序</font></strong>序列,长度为n.</p><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><p>(1)顺序存储结构(顺序表)<br><font color="red">随机访问特性<br>占用连续的存储空间<br>顺序表插入操作的时候要移动多个元素</font><br>(2)链式存储结构(链表)<br><font color="red">不支持随机访问<br>结点的存储空间利用率较顺序表稍低一些<br>动态分配<br>进行插入操作无须移动元素</font></p><h3 id="链表有以下5种"><a href="#链表有以下5种" class="headerlink" title="链表有以下5种:"></a>链表有以下5种:</h3><p>(1)单链表<br>①.带头结点的<br>头指针head指向头结点,头结点的值域<font color="red">不含任何信息</font>,从头结点的后继结点<br>开始存储数据信息,头结点始终不等于NULL,head-&gt;next==NULL的时候,链表为空.<br>②.不带头结点的<br>头指针head直接指向开始结点,head==NULL时,链表为空.<br>(2)双链表<br>除了前后结点,每个结点有两指针域分别指向前后两结点<br>(3)循环单链表<br>就是尾节点不是指向NULL,而是指向头结点,没有带头结点就指向第一个节点,头尾相邻形成一个环.<br>(4)循环双链表<br>前后结点形成环即可.<br>(5)静态链表<br>借助一维数组.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表的知识是之后的基础,一定要完全掌握.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 基本概念</title>
    <link href="http://yoursite.com/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/12/04/数据结构-基本概念/</id>
    <published>2019-12-04T11:28:39.000Z</published>
    <updated>2019-12-04T14:20:15.714Z</updated>
    
    <content type="html"><![CDATA[<p>这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。</p><a id="more"></a><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a><strong>1.数据</strong></h3><p>能<font color="red">输入</font>到计算机且能被计算机程序<font color="red">处理</font>的符号总称.(整数,字符串等)</p><h3 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2.数据元素"></a><strong>2.数据元素</strong></h3><p>是数据的基本单位,一个数据元素可能由若干个数据项组成.</p><h3 id="3-数据项"><a href="#3-数据项" class="headerlink" title="3.数据项"></a><strong>3.数据项</strong></h3><p>是数据结构中<font color="red">最小的单位</font>,是数据记录中最基本的、不可分割的数据单位.</p><h3 id="4-数据对象"><a href="#4-数据对象" class="headerlink" title="4.数据对象"></a><strong>4.数据对象</strong></h3><p>相同的数据元素的集合,是数据的一个子集.</p><h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a><strong>5.数据结构</strong></h3><p>相互之间存在一种或者多种<font color="red">特定关系</font>的数据元素的集合,包括一下三方面:<br>逻辑结构、存储结构、对数据的运算.</p><h3 id="6-数据的逻辑结构"><a href="#6-数据的逻辑结构" class="headerlink" title="6.数据的逻辑结构"></a><strong>6.数据的逻辑结构</strong></h3><p>是数据之间关系的描述,与数据的存储结构无关.</p><h4 id="①-线性结构"><a href="#①-线性结构" class="headerlink" title="①.线性结构"></a><strong>①.线性结构</strong></h4><p>是一个数据元素的有序集合,元素之间存在着”<font color="red">一对一</font>“的线性关系的数据结构，除了头尾元素,其他元素有且只有一个”前驱”和一个”后继”.</p><h4 id="②-非线性结构"><a href="#②-非线性结构" class="headerlink" title="②.非线性结构"></a><strong>②.非线性结构</strong></h4><p>与线性结构不同的是,元素之间存在”一对多”的关系.</p><h3 id="7-数据的物理结构"><a href="#7-数据的物理结构" class="headerlink" title="7.数据的物理结构"></a><strong>7.数据的物理结构</strong></h3><p>是数据的逻辑结构在计算机中的表示(映像–&gt;顺序映像和非顺序映像),包括<font color="red">数据</font>的表示和<font color="red">关系</font>的表示.</p><h4 id="①-顺序存储方法"><a href="#①-顺序存储方法" class="headerlink" title="①.顺序存储方法"></a><strong>①.顺序存储方法</strong></h4><p>把逻辑上相邻的结点存储在物理位置上相邻的存储单元上.(数组)</p><h4 id="②-链式存储方法"><a href="#②-链式存储方法" class="headerlink" title="②.链式存储方法"></a><strong>②.链式存储方法</strong></h4><p>不要求逻辑上相邻的结点在物理位置上也相邻,结点的逻辑关系是由附加的指针字段来表示的.(链表)</p><h4 id="③-索引存储方法"><a href="#③-索引存储方法" class="headerlink" title="③.索引存储方法"></a><strong>③.索引存储方法</strong></h4><p>在存储结点信息时除建立存储结点信息外,还建立附加的索引表来标识结点的地址.索引项的一般形式是&lt;关键字,地址&gt;</p><h4 id="④-散列存储方法"><a href="#④-散列存储方法" class="headerlink" title="④.散列存储方法"></a><strong>④.散列存储方法</strong></h4><p>根据结点的关键字通过散列函数直接计算出该结点的存储地址.</p><h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a><strong>算法的基本概念</strong></h1><p>1.算法的特性<br>(1)有穷性<br>(2)确定性<br>(3)输入<br>(4)输出<br>(5)可行性</p><p>2.算法的设计目标<br>(1)正确性<br>(1)可读性<br>(1)健壮性<br>(1)高效率与低存储量需求</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总体的思维导图</title>
    <link href="http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E4%BD%93%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/11/30/数据结构总体的思维导图/</id>
    <published>2019-11-30T13:17:53.000Z</published>
    <updated>2019-11-30T13:29:31.239Z</updated>
    
    <content type="html"><![CDATA[<p>自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。</p><p>这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.</p><a id="more"></a><p><img src="/images/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。&lt;/p&gt;&lt;p&gt;这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-5</title>
    <link href="http://yoursite.com/2019/11/13/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-5/"/>
    <id>http://yoursite.com/2019/11/13/Linux-学习日志-5/</id>
    <published>2019-11-13T04:21:54.000Z</published>
    <updated>2019-11-25T07:44:25.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-磁盘与文件系统管理"><a href="#Linux-磁盘与文件系统管理" class="headerlink" title="Linux 磁盘与文件系统管理"></a><strong>Linux 磁盘与文件系统管理</strong></h3><p>磁盘的组成<br>圆形的磁盘盘(主要记录数据的部分)<br>机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)<br>主轴马达,可以转动磁盘盘</p><a id="more"></a><p>磁盘盘的组成</p><ul><li>扇区(Sector)为最小的物理储存单位,目前主要有 512bytes 与4K 两张格式.</li><li>将扇区组成一个圆,那就是磁柱;</li><li>早期的分区主要是以磁柱为最小分区单位,现在的分区通常使用扇区为最小分区单位(每一个扇区都有号码)</li><li>磁盘的分区表主要有两种格式,一个是限制较多的<font color="red">MBR分区表</font>,一种是较新且限制较少的<font color="red">GPT分区表</font></li><li>MBR分区表中,第一个扇区最重要,里面有:<br>(1)主要开机区(Master boot record)及分区表(partition table) MBR 占有446bytes 而 partition table 占有 64bytes</li><li>GPT分区表除了分区数量扩展开了</li></ul><p>所有的磁盘文件名已经被模拟成<br>/dev/sd[a-p][1-128]<br>/dev/vd[a-d][1-128]</p><p>文件系统特性</p><p>superblock: 记录filesystem 的整体信息,包括inode/block的总量、使用量、剩余量,及文件系统的格式和相关信息等</p><p><img src="http://q1ika11wl.bkt.clouddn.com/43753889_p0.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux-磁盘与文件系统管理&quot;&gt;&lt;a href=&quot;#Linux-磁盘与文件系统管理&quot; class=&quot;headerlink&quot; title=&quot;Linux 磁盘与文件系统管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux 磁盘与文件系统管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;磁盘的组成&lt;br&gt;圆形的磁盘盘(主要记录数据的部分)&lt;br&gt;机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)&lt;br&gt;主轴马达,可以转动磁盘盘&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IDEA Debug调试</title>
    <link href="http://yoursite.com/2019/11/04/IDEA-Debug%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2019/11/04/IDEA-Debug调试/</id>
    <published>2019-11-04T07:48:21.000Z</published>
    <updated>2019-11-04T08:30:56.904Z</updated>
    
    <content type="html"><![CDATA[<p>Debug调试的一些技巧</p><a id="more"></a><p><img src="/images/IDEA/IDEADebug.png" alt><br>从左向右<br>1.光标在其他的行或者页面,点击可以跳转到当前代码执行的行<br>(Alt + F10)<br>2.步过,一行一行往下走,这打断点的行上面有方法不会进入方法<br>(F8)<br>3.步入,如果当前行有方法,可以进入这个方法内部,一般是自定义方法,不会是函数库里面的方法<br>(F7)<br>4.强制步入,能进入任何方法<br>(Alt+Shift+F7)<br>5.步出,从步入的方法内退出到方法调用出,此时方法已执行完毕,只是没有完成赋值<br>(Shift+F8)<br>6.回退断点<br>7.运行到光标处,而不需要打断点<br>(Alt+ F9)<br>8.计算表达式 可以直接选择某个表达式再Alt + F8 直接在窗口输出的结果,也可以自己设置参数<br>(Alt + F8)</p><p><img src="/images/IDEA/IDEADebug2.png" alt><br>1.重新运行程序,关闭服务后重新启动程序<br>2.恢复程序(F9)<br>3.暂停程序<br>4.连续按两下,关闭程序(Ctrl+F2)<br>5.查看所有断点<br>6.哑的断点,选择这个后,所有的断点变成灰色,断点失效,按F9直接运行完程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debug调试的一些技巧&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-4</title>
    <link href="http://yoursite.com/2019/11/03/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-4/"/>
    <id>http://yoursite.com/2019/11/03/Linux-学习日志-4/</id>
    <published>2019-11-03T14:30:54.000Z</published>
    <updated>2019-11-13T04:17:37.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux文件与目录的默认权限与隐藏权限"><a href="#Linux文件与目录的默认权限与隐藏权限" class="headerlink" title="Linux文件与目录的默认权限与隐藏权限"></a><strong>Linux文件与目录的默认权限与隐藏权限</strong></h3><p>目前用户在建立文件或目录时候的权限默认值<br>umask<br>数字的方式显示<br>0022 第一组是特殊权限<br>umask -S<br>字符的方式显示<br>该默认值是需要减掉的权限<br>0022</p><a id="more"></a><p>建立的文件默认权限是644(6-0,6-2,6-2)<br>建立的目录的默认 权限是755(7-0,7-2,7-2)<br>设置umask 002 就可以改变当前的默认值<br>rwxr-xr-x</p><!--more--><p>文件的隐藏属性<br>暂时不看</p><p>Set UID</p><p>查看文件类型<br>file 文件名</p><p>脚本文件名搜索<br>which [-a] command<br>a 就是all PATH中可以找到的所有指令列出来</p><p>文件的档名的搜寻<br>whereis [-bmsu] 文件或者文件名<br>[-l] 可以列出 whereis 会去查询的几个主要目录而已<br>[-b] 只找binary格式的文件<br>[-m] 只找说明文件 manual<br>[-s] 只找source来源的文件<br>[-u] 搜索不在上述三个项目当中的其他特殊文件</p><p>find指令 花费的时间很大(因为它是直接搜寻硬盘)<br>whereis指令 只找几个特定的目录而已,并没有全系统的去查询(主要是针对/bin/sbin底下的执行档)<br>locate指令 寻找的数据是在(已建立的数据库 /var/lib/mlocate/)</p><p>locate [-ir] keyword(文件的部分名称)<br>[-i] 忽略大小写<br>[-c] 不输出档名,仅计算找到的文件数目<br>[-l] 输出几行的意思 -l 5<br>[-S] 输出locate 使用的数据库文件的相关信息<br>[-r] 正规可接正规表示法显示方式<br>因为locate是经数据库来搜寻的,而数据库的建立默认是在每天执行一次,那么你新建的文件使用这个指令可能找不到,所以必须跟新数据库<br>使用updatedb来更新</p><p>find [PATH] [option] [option]<br>有 -atime, -ctime , -mtime<br>-mtime<br>n 　n为数字,意义在n天之前的[一天之内]被更动过内容的文件<br>+n 　n天<b>之前</b>被更动过内容的文件档名(不包括n天本身)<br>-n　 n天<b>之内</b>被更改内容的文件档名<br>-newer file 　 file为一个存在的文件,列出比file 还要新的文件档名<br>find / -mtime 0<br>find Desktop -newer /</p><p>与使用者或者组名有关的参数<br>-uid n　 n为数字,这个数字是用户的账号的UID<br>-gid n　 n为数字,这个数字是组名的GID<br>-user name 　name为使用者的名字<br>-group name　 name为组名<br>-nouser　 寻找文件拥有者不存在的与 /etc/passwd 的人<br>-nogroup 　寻找文件的拥有群组不存在 /etc/group 的文件</p><p>与文件的权限及名称有关的参数<br>-name filename　 搜索文件名为filename的文件<br>-size [+-]SIZE 　 搜寻比SIZE 还要大(+)或(-)的文件.<br>　 c: byte k:1024bytes 要找20KB还要大的文件<br>-size +50k<br>-type TYPE　 搜寻文件的类型为TYPE的,(一般正规文件f,装置文件b、c,d,l,s,p)<br>-perm mode　 搜寻文件权限刚好等于 mode的文件<br>-perm -mode　 搜寻文件权限[必须全部包括mode的权限]的文件<br>-perm /mode　 搜寻文件权限[包括任一mode的权限]的文件</p><p>额外可进行的动作<br>-exec command exec后面可以接其他的指令<br>-print 打印输出显示</p><p>find / size +1M -exec ls -l {} ;<br>-exec 后面的指令不支持命令别名<br>{} 代表的是[由find找到的内容],find的结果会被放置到{}位置中<br>;是关键词,表示find 额外的动作开始(-exec)到结束(;),在中间的就是find指令内的额外的动作<br>[;] 在bash环境下有特殊的意义,因此利用反斜杠来跳脱</p><p>一. 让某用户进入某目录成为[可工作目录]的基本权限<br>用户至少有对这个目录需要具有 x 权限</p><p>二.让某用户在某个目录内读取一个文件的基本权限<br>用户至少对这个目录具有x权限<br>对文件具有r权限</p><p>三.让一个用户可以修改文件的权限<br>用户至少对这个目录具有x权限<br>对文件具有r w 权限</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux文件与目录的默认权限与隐藏权限&quot;&gt;&lt;a href=&quot;#Linux文件与目录的默认权限与隐藏权限&quot; class=&quot;headerlink&quot; title=&quot;Linux文件与目录的默认权限与隐藏权限&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux文件与目录的默认权限与隐藏权限&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;目前用户在建立文件或目录时候的权限默认值&lt;br&gt;umask&lt;br&gt;数字的方式显示&lt;br&gt;0022 第一组是特殊权限&lt;br&gt;umask -S&lt;br&gt;字符的方式显示&lt;br&gt;该默认值是需要减掉的权限&lt;br&gt;0022&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-3</title>
    <link href="http://yoursite.com/2019/11/01/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-3/"/>
    <id>http://yoursite.com/2019/11/01/Linux-学习日志-3/</id>
    <published>2019-11-01T01:27:11.000Z</published>
    <updated>2019-11-03T13:55:12.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux目录管理"><a href="#Linux目录管理" class="headerlink" title="Linux目录管理"></a><strong>Linux目录管理</strong></h3><p>绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)<br>相对路径:[不是由/写起]</p><a id="more"></a><blockquote><p>. 　　 (代表此层目录 )<br>.. 　　 (代表上一层目录 )<br>- 　　 (代表签一个工作目录 )<br>~ 　　 (代表[当前用户身份]所在的家目录 )<br>~zlw 　(代表zlw这个用户的家目录 )</p></blockquote><h3 id="常用的处理目录指令"><a href="#常用的处理目录指令" class="headerlink" title="常用的处理目录指令"></a>常用的处理目录指令</h3><p>cd 变换目录</p><p>pwd 显示当前目录</p><p>mkdir 建立一个新的目录<br>[-m]创建目录的时候直接设定权限<br>[-p]直接将要创建所需要的目录递归建立起来! example:<br>mkdir -p text1/text2/text3<br>ls -ld test*</p><p>rmdir 删除一个空的目录<br>[-p] 连同[上层][空的]目录一起删除<br><strong><font color="red">被删除的目录里面必定不能存在其他的目录或者文件!</font></strong></p><p>为什么我可以在任何地方执行/bin/ls 这个指令?<br>是因为环境变量$PATH 指定了/bin/ls,若把ls文件移入到/root下,则无法使用ls指令,可以<br>PATH=”${PATH}:/root” 加入到执行文件搜寻路径PATH中</p><h2 id="文件与目录是检视-ls"><a href="#文件与目录是检视-ls" class="headerlink" title="文件与目录是检视: ls"></a>文件与目录是检视: <strong>ls</strong></h2><p><font color="red">[-a] 显示全部文件,包括隐藏档,包括(.)(..)</font><br>[-A]　　 显示全部文件,包括隐藏档,不包括(.)(..)<br><font color="red">[-d]　　 仅列出目录本身,不是目录下的文件数据(查询目录需要加)</font><br>[-r]　　 直接列出结果,不排序(ls会以档名排序)<br>[-h]　　 文件容量以人类易读的方式(GB KB)列出来<br>[-i] 　　列出inode 号码，<br>[-F] 　　根据文件,目录等信息,给予附加数据结构<br><font color="red">[-l] 　　长数据串行出</font><br>[-S] 　　以文件容量大小排序<br>[-r] 　　反序输出<br>[-t] 　　以时间排序<br>[-R] 　　连同子目录一起列出来,等于输出显示所有文件<br>[-n]　　 列出UID跟GID,(而不是使用者跟群组)<br>–color=never 不根据文件特性给予颜色显示<br>–color=always 显示颜色<br>–color=auto 系统自动判断<br>–full–time 以完整的时间模式(年月日时分)输出</p><h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 <strong>cp</strong></h3><p>cp 　 [-adfilprsu] 　 来源文件(source) 　目标文件(destination)<br>cp 　[options] 　source1 　source2 　source3… 　directory<br><font color="red">[-a] 　　相当于-dr –preserve=all的意思</font><br>[-d] 　　若来源文件为链接文件的属性(link file),则复制链接文件属性而非文件本身<br>[-f] 　　强制(force),若目标文件已经存在且无法开启,则移除后再尝试一次<br><font color="red">[-i] 　　目标文件存在,覆盖之前询问</font><br>[-l] 　　进行硬链接(hard link)的连档建立,而非复制文件本身<br><font color="red">[-p] 　　连同文件的属性(权限,用户,时间)一起复制,而非使用默认属性</font><br><font color="red">[-r] 　　递归持续复制,用于目录的复制行为</font><br>[-s] 　　复制成为符号链接文件(symbolic link),亦即[快捷方式]文件<br>[-u] 　　destination 比 source 旧才跟新 destination,或者destination 不存在的情况下才复制</p><h3 id="移除-rm"><a href="#移除-rm" class="headerlink" title="移除 rm"></a>移除 <strong>rm</strong></h3><p>rm [-fir] 文件或目录<br>[-f] 强制删除,忽略不存在的文件,不会出现警告<br>[-i] 询问<br>[-r] 递归删除! rm -r /tmp/etc<br>如果身份是root ,预计加入 -i 的选项,需要一直按y才会删除<br>可以按[Ctrl] + c 结束<br>这是一种保护动作,如果不需要<br>\rm -r /tmp/etc<br>删除档名第一个字符有[-] -aaa- 因为’-‘是选项,系统会误判<br>rm ./-aaa-</p><h3 id="移动-mv"><a href="#移动-mv" class="headerlink" title="移动 mv"></a>移动 <strong>mv</strong></h3><p>mv [-fiu] source destination<br>mv [options] source1 source2 source3 … directory<br>[-f] 强制,如果存在的文件,不会询问直接覆盖<br>[-i] 询问<br>[-u] 若目标文件存在,且source比较新,才会更新(update)</p><p>更改名字<br>mv mytest mytest1<br>取得最后的档名<br>basename<br>取得目录名<br>dirname</p><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><p>cat 由第一行开始显示文件内容<br>tac 从最后一行开始显示, tac就是cat倒着写的！<br>nl 显示行号<br>more 一页一页显示文件内容<br>less 比moreg好,可以向前翻页<br>head 只看前几行 -n (默认10行)<br>tail 只看后几行 -n (默认10行)<br>od 二进制的方式读取文件内容</p><p>cat [-AbEnTv]<br>[-A] 相当于-vET的整合<br>[-b] 列出行号,仅对非空白行,空白行不标行号<br>[-E] 结尾断行字符$显示出来<br>[-n] 打印出行号,空白行也打印<br>[-T] 将[tab]按键以 ^[显示出来<br>[-v] 列出一些看不到的特殊字符</p><p>more<br>空格 代表向下翻一页<br>Enter 代表向下翻一行<br>/字符串 [字符串]搜索<br>:f 立即显示出文件名和行数<br>q 退出<br>b 或者[Ctrl] + b 往回翻页</p><p>less<br>/字符串 向下搜索<br>?字符串 向上搜索<br>q 退出<br>g 第一行<br>G 最后一行</p><p>修改文件时间或者建置新档 touch<br>三个主要的变动时间</p><p>modification time<br>当该文件的[内容数据]变更时,就会更新这个时间<br>status time<br>当该文件的[状态]变更时,就会更新这个时间(权限或者属性)<br>access time<br>当[该文件的内容被取用]时,就会更新这个时间(cat 去读取时)</p><p>ls显示出来的是该文件的mtime,也就是这个文件上一次的内容被改动的时间。<br>如果touch的文件不存在,那么会创建一个新的空文件.如果存在那么文件的三个时间(atime,ctime,mtime)都会更新为目前的时间<br>ll===&gt; ls -l(别名)<br>[;] 代表连续指令的下达! date ; ll bashrc ; ll –time=atime bashrc; ll –time=ctime bashrc;<br>touch [-acdmt] 文件<br>[-a] 仅修改atime<br>[-c] 仅修改文件时间,文件不存在不新建<br>[-d] 后面可以接修改的日期而不是目前的日期,也可以使用 –date=”日期或者时间”<br>[-m] 仅修改mtime<br>[-t] 后面可以接修改的时间而不用目前的时间,格式为[YYYYMMDDhhmm]<br>复制一个文件时,复制所有的属性,但没办法复制ctime.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux目录管理&quot;&gt;&lt;a href=&quot;#Linux目录管理&quot; class=&quot;headerlink&quot; title=&quot;Linux目录管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux目录管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)&lt;br&gt;相对路径:[不是由/写起]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-2</title>
    <link href="http://yoursite.com/2019/10/30/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-2/"/>
    <id>http://yoursite.com/2019/10/30/Linux-学习日志-2/</id>
    <published>2019-10-30T12:18:22.000Z</published>
    <updated>2019-11-01T00:41:18.563Z</updated>
    
    <content type="html"><![CDATA[<p>Linux最优秀的地方之一就是在于多人多任务环境<br>Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.</p><a id="more"></a><p>1.文件拥有者<br>我的东西,我想给谁看给谁看,我是主宰者!</p><p>2.群组<br>就是在一个群里面,我可以使用群组的资源,其他用户也可以使用。但不在群组里面的人肯定是不能使用的。</p><p>3.其他人<br>就是我有一个发小或者朋友,那么他也可以通过我来使用群组里面的资源。那么对于这个组里面的其他人,跟我这个发小并不认识,那么,发小就是他眼中的[其他人].<br>还是就是root账户,那他就是GOD!~,可以任意访问群组,访问他想访问的任何东西!</p><p>root的相关信息<br>/etc/passwd<br>个人的密码<br>/etc/shadow<br>所有的组名<br>/etc/group</p><h3 id="Linux的文件属性"><a href="#Linux的文件属性" class="headerlink" title="Linux的文件属性"></a><strong><font color="red">Linux的文件属性</font></strong></h3><p><img src="/images/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt></p><p>- rwx rwx —</p><p>第一个字符代表这个文件的类型:<br>[d] 目录<br>[-] 文件<br>[l] 连结档<br>[b] 装置文件里面的可供储存的接口设备<br>[c] 装置文件里面的串行端口设备,例如键盘,鼠标(一次性读取装置)</p><p>[r] 可读 (权值:4)<br>[w] 可写 (权值:2)<br>[x] 可执行 (权值:1)<br><font color="red">这三个权限的位置不会改变,没有权限,就会出现减号[-]</font><br>1.数字类型改变文件权限<br>2.符号类型改变文件权限<br>例如:<br>rwx= 4+2+1 = 7<br>rw-= 4+2+0 = 6<br>—= 0+0+0 = 0<br>基本上就九个权限分别是(1)user (2)group (3)others 可以用<b>u</b>,<b>g</b>,<b>o</b>代表这三个权限,<b>a</b>则代表all全部身份! [+] 加入 [-] 除去 [=]设定<br>chmod u=rwx,go=r text.txt<br>可以给每个角色分配一个[r]权限<br>chmod a+w text.txt</p><p>文件是否能被执行,则是籍由是否具有[x]这个权限来决定的,而不是根据扩展名。<br>[w] 不具备删除该文件本身的权限<br>目录里面的[x]代表用户能是否进入该目录成为工作目录。(工作目录就是目前所在的目录)<br>假如说你的home目录下有一个你无法访问的文件,就是文件拥有者是其他人,且你也不在这个群组里面,那么你可以删除这个文件！因为你具有home目录下的rwx的完整权限当然可以删除这个对于你来说的垃圾文件。</p><p>[文件拥有者的权限]<br>[加入此群组的账号的权限]<br>[非本人没有加入本群组的其他账号的权限]</p><p>如果档名之前多一个[.],则代表这个文件为[隐藏档]<br><font color="red">root基本上是不受系统的权限所控制的</font></p><p>[chgrp] 改变文件所属群组<br>[chown] 改变文件拥有者<br>[chmod] 改变文件的权限,SUI,SGID,SBIT</p><p>cp 来源文件 目标文件</p><p>为什么在操作目录时候需要[r][x], 单纯操作目录[x]就足够了,但没有r的权限,那就无法知道里面的文件夹放在哪个地方,使用[tab],他就无法自动帮你补齐档名了。</p><h3 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a><strong>Linux文件种类与扩展名</strong></h3><h4 id="任何装置在Linux底下都是文件"><a href="#任何装置在Linux底下都是文件" class="headerlink" title="任何装置在Linux底下都是文件"></a><strong><font color="red">任何装置在Linux底下都是文件</font></strong></h4><p>[-]<br>1.纯文本档(ASCII)<br>2.二进制文件(binary)<br>3.数据格式文件(data)<br>[d](directory)<br>[l](link)<br>类似window快捷方式<br>设备与装置文件(device)<br>[b] 就是一些储存数据,以提供系统随机存取的接口设备。(硬盘与软盘)<br>[c]一些串行端口的接口设备(鼠标与键盘,一次性读取,不能够截断输出)<br>资料接口文件(sockets)<br>[s] 数据接口文件<br>数据输送文件(FIFO,PIPE)<br>[p] 特殊的文件类型,主要的目的在解决多个程序同时存取一个文件造成的错误问题</p><p>常用的扩展名:<br>*.sh<br>脚本或批处理文件,因为批处理文件是shell写的<br>*.Z 　*.tar 　*.tar.gz　*.zip　*.tgz<br>打包的压缩文件<br>*.html　*.php<br>网页相关文件</p><p>Linux文件名的限制<br>* ? &gt; &lt; ; &amp;</p><p>[./] 本目录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux最优秀的地方之一就是在于多人多任务环境&lt;br&gt;Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-1</title>
    <link href="http://yoursite.com/2019/10/30/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-1/"/>
    <id>http://yoursite.com/2019/10/30/Linux-学习日志-1/</id>
    <published>2019-10-30T12:11:57.000Z</published>
    <updated>2019-11-01T11:38:15.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要学了一些基础的指令-热键"><a href="#主要学了一些基础的指令-热键" class="headerlink" title="主要学了一些基础的指令,热键"></a><strong>主要学了一些基础的指令,热键</strong></h3><p>command [-options] parameter1 parameter2<br>指令 选项 参数1 参数2</p><a id="more"></a><p>date</p><p>date +%Y/%m/%d</p><p>date +%H:%M</p><p>cal</p><p>cal [month] [year]</p><p>bc<br>--quit 退出</p><p>热键<br>[tab] 具有[命令补全] 与 [文件补齐] 的功能! ca[tab][tab]</p><p>date --[tab][tab]</p><p>[Ctrl] + c 中断目前程序</p><p>[Ctrl] + d 键盘输入结束 可以取代(exit)</p><p>[Ctrl] + l 清屏</p><p>[shift] + [PageUP]|[Page Down] 向前/向后翻页</p><p>--help|less |more 都是可以进行翻页阅读</p><p>nano text.txt</p><p>观察系统的使用状态<br>netstat -a</p><p>sync 将数据同步写入硬盘中 (如果在内存中的没有写入硬盘,该指令就可以把内存中的数据写入硬盘)<br>shutdown (root用户下) poweroff<br>reboot halt</p><p>su - (身份变成root,底下输入root的密码)<br>shutdown 如果什么参数都没有加 则系统会在1分钟之后关机<br>-k 不是真的关机,只是发出警告！<br>-r 系统的服务停掉之后重新启动<br>-h 服务停掉之后关机<br>-c 取消shutdown指令内容</p><p>systemctl [指令]<br>halt shutdown reboot poweroff</p><p>pwd — 打印出当前工作目录名</p><p>cd — 更改目录</p><p>ls — 列出目录内容</p><p>ls — 列出目录内容</p><p>file — 确定文件类型</p><p>less — 浏览文件内容</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要学了一些基础的指令-热键&quot;&gt;&lt;a href=&quot;#主要学了一些基础的指令-热键&quot; class=&quot;headerlink&quot; title=&quot;主要学了一些基础的指令,热键&quot;&gt;&lt;/a&gt;&lt;strong&gt;主要学了一些基础的指令,热键&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;command [-options] parameter1 parameter2&lt;br&gt;指令 选项 参数1 参数2&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java-8 方法引用</title>
    <link href="http://yoursite.com/2019/10/28/java-8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/28/java-8-方法引用/</id>
    <published>2019-10-28T06:35:59.000Z</published>
    <updated>2019-10-29T11:41:20.304Z</updated>
    
    <content type="html"><![CDATA[<p>方法引用: method reference<br>方法引用实际上是个Lambda表达式的一种语法糖<br>我们可以将方法引用看作是一个[函数指针]</p><a id="more"></a><p>*方法引用<br>classname::staticmethod<br>*方法调用<br>classname.staticmethod</p><h3 id="方法引用共分为4类"><a href="#方法引用共分为4类" class="headerlink" title="方法引用共分为4类"></a><strong>方法引用共分为4类</strong></h3><ul><li>类名::静态方法名</li><li>引用名(对象名)::实例方法名</li><li>类名::实例方法名(lambda表达式的第一个参数作为这个方法的调用者,之后的参数作为这个方法的参数)</li><li>构造方法引用　类名::new</li></ul><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a><strong>默认方法</strong></h3><p><strong>什么是默认方法</strong><br>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。<br><strong>为什么出现默认方法</strong><br>为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p><h3 id="java-8抽象类与接口对比"><a href="#java-8抽象类与接口对比" class="headerlink" title="java 8抽象类与接口对比"></a><strong>java 8抽象类与接口对比</strong></h3><table><thead><tr><th><strong>相同点</strong></th><th><strong>不同点</strong></th></tr></thead><tbody><tr><td>都是抽象类型</td><td>抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）</td></tr><tr><td>都可以有实现方法（以前接口不行）</td><td>抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系</td></tr><tr><td>都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）</td><td>接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</td></tr></tbody></table><h3 id="多重继承的冲突"><a href="#多重继承的冲突" class="headerlink" title="多重继承的冲突"></a><strong>多重继承的冲突</strong></h3><p>由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：<br>1.一个声明在类里面的方法优先于任何默认方法（classes always win）<br>2.否则，则会优先选取路径最短的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod1!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod2!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错 defaultTest inherits unrelated defaults for myMethod() from types MyInterface and MyInterface1<br>如果一定要这么写呢，同时实现MyInterface,MyInterface1并且使用MyInterface1中myMethod()？可以这么写：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">defaultTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>,<span class="hljs-title">MyInterface1</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defaultTest defaultTest = <span class="hljs-keyword">new</span> defaultTest();</span><br><span class="line">        defaultTest.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MyInterface1.<span class="hljs-keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以这么写:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyInterface</span>,<span class="hljs-title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod3!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">defaultTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defaultTest defaultTest = <span class="hljs-keyword">new</span> defaultTest();</span><br><span class="line">        defaultTest.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MyInterface2.<span class="hljs-keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 myMethod3!! 可见MyInterface2.super表示的是MyInterface2接口，同时defaultTest无法访问MyInterface,MyInterface2的myMethod()</p><blockquote><p>可见MyInterface2虽然有同一个两个最短路径的myMethod(), 但是它自己有一个更高优先级的myMethod()，所以不会报错;</p></blockquote><p>默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方法引用: method reference&lt;br&gt;方法引用实际上是个Lambda表达式的一种语法糖&lt;br&gt;我们可以将方法引用看作是一个[函数指针]&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>java-8 Optional类解析</title>
    <link href="http://yoursite.com/2019/10/28/java-8-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/28/java-8-Optional类解析/</id>
    <published>2019-10-28T02:20:03.000Z</published>
    <updated>2019-10-28T04:22:10.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。<br>新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><a id="more"></a><h4 id="of"><a href="#of" class="headerlink" title="of"></a><strong>of</strong></h4><blockquote><p>为非null的值创建一个Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//调用工厂方法创建Optional实例</span></span><br><span class="line">Optional&lt;String&gt; s = Optional.of(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"><span class="hljs-comment">//传入参数为null，抛出NullPointerException.</span></span><br><span class="line">Optional&lt;String&gt; s1 = Optional.of(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a><strong>ofNullable</strong></h4><blockquote><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况</span></span><br><span class="line"><span class="hljs-comment">//下面创建了一个不包含任何值的Optional实例</span></span><br><span class="line"><span class="hljs-comment">//例如，值为'null'</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a><strong>isPresent</strong></h4><blockquote><p>如果值存在返回true，否则返回false。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//isPresent方法用来检查Optional实例中是否包含值</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"ZLW"</span>);</span><br><span class="line">        String name = <span class="hljs-string">"zlw"</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(empty.isPresent())&#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a><strong>get</strong></h4><blockquote><p>如果Optional有值则将其返回，否则抛出NoSuchElementException。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a><strong>ifPresent</strong></h4><blockquote><p>如果Optional实例有值则为其调用consumer，否则不做处理<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ifPresent方法接受lambda表达式作为参数。</span></span><br><span class="line"><span class="hljs-comment">//lambda表达式对Optional的值调用consumer进行处理。</span></span><br><span class="line">empty.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a><strong>orElse</strong></h4><blockquote><p>如果有值则将其返回，否则返回指定的其它值。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 值为 null</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br><span class="line"><span class="hljs-comment">// 值为 zlw</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a><strong>orElseGet</strong></h4><blockquote><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span></span><br><span class="line"><span class="hljs-comment">//orElseGet可以接受一个lambda表达式生成默认值。</span></span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; <span class="hljs-string">"no value!"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a><strong>orElseThrow</strong></h4><blockquote><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">  <span class="hljs-comment">//orElseThrow与orElse方法类似。与返回默认值不同，</span></span><br><span class="line">  <span class="hljs-comment">//orElseThrow会抛出lambda表达式或方法生成的异常 </span></span><br><span class="line"></span><br><span class="line">  empty.orElseThrow(ValueAbsentException::<span class="hljs-keyword">new</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="hljs-comment">//输出: No value present in the Optional instance</span></span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueAbsentException定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueAbsentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"No value present in the Optional instance"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a><strong><font color="red">map</font></strong></h4><blockquote><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span></span><br><span class="line"><span class="hljs-comment">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; newempty = empty.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(newempty.orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h4><blockquote><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span></span><br><span class="line"><span class="hljs-comment">//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span></span><br><span class="line"><span class="hljs-comment">//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span></span><br><span class="line"> Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"> System.out.println(empty.flatMap((value) -&gt; Optional.of(value.toUpperCase())).orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h4><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p><blockquote><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//filter方法检查给定的Option值是否满足某些条件。</span></span><br><span class="line"><span class="hljs-comment">//如果满足则返回同一个Option实例，否则返回空Optional。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; s = empty.filter((value) -&gt; value.length() &gt; <span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(s.orElse(<span class="hljs-string">"The name is less than 6 characters"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。&lt;br&gt;新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
</feed>
