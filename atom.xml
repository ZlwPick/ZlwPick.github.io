<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zlwblog</title>
  
  <subtitle>zlwblog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-13T01:41:21.022Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zlw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-入门篇1</title>
    <link href="http://yoursite.com/2019/12/12/Python-%E5%85%A5%E9%97%A8%E7%AF%871/"/>
    <id>http://yoursite.com/2019/12/12/Python-入门篇1/</id>
    <published>2019-12-12T13:28:51.000Z</published>
    <updated>2019-12-13T01:41:21.022Z</updated>
    
    <content type="html"><![CDATA[<p>因为比较好奇爬虫技术,对比了一下,Java写爬虫的话比较麻烦,所以花点时间去学习一下Python</p><a id="more"></a><p><img src="/images/Python%E5%85%A5%E9%97%A8%E5%9B%BE.jpg" alt></p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="hljs-string">"Hello"</span>,<span class="hljs-string">"Word"</span>,<span class="hljs-string">"Python!"</span>)</span><br><span class="line">print(<span class="hljs-number">1000</span>+<span class="hljs-number">1000</span>)</span><br><span class="line"><span class="hljs-comment"># 输入函数 input()</span></span><br><span class="line"><span class="hljs-comment">#name = input("请输入名字:")</span></span><br><span class="line"><span class="hljs-comment">#print("hello:",name)</span></span><br><span class="line"><span class="hljs-comment">#print("1024*768=",1024*768)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#字符串可以用这两个表示 "" '' 如果""中有'转义字符\,例如一下</span></span><br><span class="line"><span class="hljs-comment">#\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\</span></span><br><span class="line">print(<span class="hljs-string">'I\'m \"OK!\"'</span>)</span><br><span class="line">print(<span class="hljs-string">'I\'m \n \"OK!\"'</span>)</span><br><span class="line">print(<span class="hljs-string">'I\'m \t \\ \"OK!\"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python还允许用r''表示''内部的字符串默认不转义</span></span><br><span class="line">print(<span class="hljs-string">r'I\'m \t \\ \"OK!\"'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python允许用'''...'''的格式表示多行内容 ,在交互式命令行中  &gt;&gt;&gt; 变成 ...</span></span><br><span class="line">print(<span class="hljs-string">'''zlw1 </span></span><br><span class="line"><span class="hljs-string">zlw2</span></span><br><span class="line"><span class="hljs-string">zlw3 '''</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># True 和False , or and not</span></span><br><span class="line">print(<span class="hljs-literal">True</span>)</span><br><span class="line">print(<span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>)</span><br><span class="line">print(<span class="hljs-string">"---------------"</span>)</span><br><span class="line">print(<span class="hljs-string">"and"</span>,<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-string">"or"</span>,<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)</span><br><span class="line">print(<span class="hljs-string">"not"</span>, <span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python中空值是 None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#变量</span></span><br><span class="line"><span class="hljs-comment">#这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</span></span><br><span class="line"><span class="hljs-comment"># 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</span></span><br><span class="line"><span class="hljs-comment">#Python 对缩进很敏感 tab和空格的混用会导致错误</span></span><br><span class="line">a = <span class="hljs-number">123</span></span><br><span class="line">print(a)</span><br><span class="line">a = <span class="hljs-string">"123123"</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">x = <span class="hljs-number">10</span></span><br><span class="line">print(x)</span><br><span class="line">x = x + <span class="hljs-number">10</span></span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在Python中，通常用全部大写的变量名表示常量：</span></span><br><span class="line">PI = <span class="hljs-number">3.1415926</span></span><br><span class="line">print(PI)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在Python中，有两种除法 1./(有小数) 2.//(只有整数)</span></span><br><span class="line">print(<span class="hljs-number">10</span>/<span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">10</span>//<span class="hljs-number">3</span>)</span><br><span class="line">print(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python中字符串是Unicode编码 ord() 获得整数的值 chr()根据整数转字符</span></span><br><span class="line">print(ord(<span class="hljs-string">"A"</span>),ord(<span class="hljs-string">"中"</span>),chr(<span class="hljs-number">65</span>),chr(<span class="hljs-number">97</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。</span></span><br><span class="line"><span class="hljs-comment"># 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</span></span><br><span class="line">print(<span class="hljs-string">"周李伟"</span>.encode(<span class="hljs-string">"utf-8"</span>))</span><br><span class="line">print(len(<span class="hljs-string">"zlwzlwlaqweqwe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</span></span><br><span class="line"><span class="hljs-comment">#第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#格式化跟C一样 %d整数</span></span><br><span class="line"><span class="hljs-comment">#             %f浮点数</span></span><br><span class="line"><span class="hljs-comment">#             %s字符串（它会把任何数据类型转换为字符串）</span></span><br><span class="line"><span class="hljs-comment">#             %x十六进制整数</span></span><br><span class="line">print(<span class="hljs-string">"zlw是%d个%s"</span> %(<span class="hljs-number">1</span>,<span class="hljs-string">"废物"</span>))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#Python中的list,list是一个可变的有序表,list里面的元素的数据类型也可以不同,list元素也可以是另一个list</span></span><br><span class="line">list = [<span class="hljs-string">"ZLW1"</span>,<span class="hljs-string">"ZLW2"</span>,<span class="hljs-string">"ZLW3"</span>]</span><br><span class="line">print(len(list))</span><br><span class="line"><span class="hljs-comment">#print(list[2])</span></span><br><span class="line"><span class="hljs-comment">#print(list[-1]) #倒数第一个数,以此类推</span></span><br><span class="line">list.append(<span class="hljs-string">"zlw4"</span>)</span><br><span class="line">list.insert(<span class="hljs-number">1</span>,<span class="hljs-string">"zlwzlw"</span>)</span><br><span class="line">list.pop()</span><br><span class="line">list.pop(<span class="hljs-number">0</span>)</span><br><span class="line">list[<span class="hljs-number">1</span>]=<span class="hljs-string">"ZZZZZZZ"</span></span><br><span class="line"><span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> list:</span><br><span class="line">    print(z)</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">"------------"</span>)</span><br><span class="line"><span class="hljs-comment">#二维数组</span></span><br><span class="line">s = [<span class="hljs-string">"JAVA"</span>,[<span class="hljs-string">"C++"</span>,<span class="hljs-string">"C#"</span>,<span class="hljs-string">"C"</span>],<span class="hljs-string">"Python"</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> s:</span><br><span class="line">    print(s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># tuple,tuple和list非常类似，但是tuple一旦初始化就不能修改，</span></span><br><span class="line"><span class="hljs-comment">#tuple的陷阱,当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来</span></span><br><span class="line"><span class="hljs-comment">#这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，</span></span><br><span class="line"><span class="hljs-comment"># 这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</span></span><br><span class="line"><span class="hljs-comment">#所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</span></span><br><span class="line">t = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span><br><span class="line">t = (<span class="hljs-number">1</span>,)</span><br><span class="line"><span class="hljs-keyword">for</span> t1 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t1)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。那么他指向的list的不会改变,就并不代表list中的值不可改变</span></span><br><span class="line">t = (<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,[<span class="hljs-string">"ZLW"</span>,<span class="hljs-string">"ZLW"</span>])</span><br><span class="line"><span class="hljs-keyword">for</span> t2 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t2)</span><br><span class="line">t[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">"周李伟是废物"</span></span><br><span class="line"><span class="hljs-keyword">for</span> t2 <span class="hljs-keyword">in</span> t:</span><br><span class="line">    print(t2)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#条件判断 根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。</span></span><br><span class="line">age = <span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">33</span>:</span><br><span class="line">    print(<span class="hljs-string">"you age"</span>,age)</span><br><span class="line"><span class="hljs-keyword">elif</span> age &gt; <span class="hljs-number">18</span>:</span><br><span class="line">    print(<span class="hljs-string">"！！！！！"</span>)</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">"?????"</span>)</span><br><span class="line"><span class="hljs-comment">#elif else if的缩写</span></span><br><span class="line"><span class="hljs-comment">#if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else</span></span><br><span class="line"><span class="hljs-comment">#birth = input("请输入您的生日");</span></span><br><span class="line"><span class="hljs-comment"># 这里面input输入进来的是字符串类型不能直接跟Int类型对比,需要用int()函数进行转化,当然你输入的是字符也不行,也不能跟进行比较</span></span><br><span class="line"><span class="hljs-comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="hljs-comment">#  File "D:/PythonWork/Zlw.py", line 125, in &lt;module&gt;</span></span><br><span class="line"><span class="hljs-comment">#    if birth &gt; 2000:</span></span><br><span class="line"><span class="hljs-comment"># TypeError: '&gt;' not supported between instances of 'str' and 'int'</span></span><br><span class="line"><span class="hljs-comment">#if int(birth) &gt; 2000:</span></span><br><span class="line"><span class="hljs-comment">#    print("年轻人")</span></span><br><span class="line"><span class="hljs-comment">#else:</span></span><br><span class="line"><span class="hljs-comment">#    print("老逼")</span></span><br><span class="line"><span class="hljs-comment">#Python内置了字典：dict的支持,在其他的语言中是Map,使用键-值（key-value）存储.具有极快的查找速度.</span></span><br><span class="line"><span class="hljs-comment">#dict的key必须是不可变对象(要保证hash的正确性)</span></span><br><span class="line"><span class="hljs-comment">#对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</span></span><br><span class="line">d = &#123;<span class="hljs-string">"zlw1"</span>:<span class="hljs-number">999</span>,<span class="hljs-string">"zlw2"</span>:<span class="hljs-number">777</span>,<span class="hljs-string">"zlw3"</span>:<span class="hljs-number">222</span>&#125;</span><br><span class="line">print(d[<span class="hljs-string">"zlw1"</span>])</span><br><span class="line"><span class="hljs-comment">#避免key不存在用的错误,有两种方法</span></span><br><span class="line">print(<span class="hljs-string">"zlw"</span> <span class="hljs-keyword">in</span> d)</span><br><span class="line">print(d.get(<span class="hljs-string">"zlw"</span>))</span><br><span class="line">print(d.get(<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"?????"</span>))</span><br><span class="line">d.pop(<span class="hljs-string">"zlw1"</span>)</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#set和dict类似,也是一组key的集合,但不存储value,key不能重复.要创建一个set，需要提供一个list作为输入集合</span></span><br><span class="line">d = set([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])</span><br><span class="line">s = set([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">15</span>])</span><br><span class="line">print(d)</span><br><span class="line">d.add(<span class="hljs-number">12</span>)</span><br><span class="line">print(d)</span><br><span class="line">d.remove(<span class="hljs-number">1</span>)</span><br><span class="line">print(d)</span><br><span class="line">print(d &amp; s) <span class="hljs-comment">#交集</span></span><br><span class="line">print(d | s) <span class="hljs-comment">#并集</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#循环</span></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]:</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">sum = <span class="hljs-number">0</span></span><br><span class="line">n = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">while</span> sum &lt; <span class="hljs-number">100</span>:</span><br><span class="line">    n += <span class="hljs-number">3</span></span><br><span class="line">    sum += n</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">n = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">100</span>:</span><br><span class="line">    n+=<span class="hljs-number">1</span></span><br><span class="line">    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">continue</span></span><br><span class="line">    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">50</span>:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    print(n)</span><br><span class="line">print(<span class="hljs-string">"end"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为比较好奇爬虫技术,对比了一下,Java写爬虫的话比较麻烦,所以花点时间去学习一下Python&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>java-8 stream2</title>
    <link href="http://yoursite.com/2019/12/09/java-8-stream2/"/>
    <id>http://yoursite.com/2019/12/09/java-8-stream2/</id>
    <published>2019-12-09T10:26:10.000Z</published>
    <updated>2019-12-11T10:43:35.674Z</updated>
    
    <content type="html"><![CDATA[<p>用流来收集数据<br>收集器用作高级归约预定义收集器的功能以下:<br>1.将流元素归约和汇总为一个值<br>2.元素分组<br>3.元素分区(使用谓词[返回一个布尔值的单参数函数]作为分组函数)</p><a id="more"></a><h3 id="查询流中最大值和最小值"><a href="#查询流中最大值和最小值" class="headerlink" title="查询流中最大值和最小值"></a>查询流中最大值和最小值</h3><p>Collectors.maxBy<br>Collectors.mixBy<br>都是接受一个Comparator(比较器)参数来比较流中的元素.返回一个Optional<t></t></p><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><p>Collectors.summingInt (Double、Long)<br>可接受一个把对象映射为求和所需的int的函数,并返回一个收集器.</p><p>Collectors.averagingInt (Double、Long)<br>求平均值</p><p>Collectors.summarizingInt (Double、Long)<br>一次性 求个数,总和,平均值,最大值,最小值(通过getter取值)</p><p>joining()—&gt;字符串连接方法,方法内部使用StringBuilder拼加,joining(“, “),可以加分隔符</p><p>reducing(0,Dishes::getCalories,Integer::sum);<br>①第一个参数是初始值<br>②第二个参数是转换函数(把流中的值转化成你所需要的类型)<br>③第三个参数是累加函数<br>counting() 就是把每个元素转换成1L,然后在求和.就知道了有多少个元素</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>Collectors.groupingBy(Function[分类函数]Key,Value)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用流来收集数据&lt;br&gt;收集器用作高级归约预定义收集器的功能以下:&lt;br&gt;1.将流元素归约和汇总为一个值&lt;br&gt;2.元素分组&lt;br&gt;3.元素分区(使用谓词[返回一个布尔值的单参数函数]作为分组函数)&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>java-8 stream</title>
    <link href="http://yoursite.com/2019/12/06/java-8-stream/"/>
    <id>http://yoursite.com/2019/12/06/java-8-stream/</id>
    <published>2019-12-06T14:02:54.000Z</published>
    <updated>2019-12-10T04:18:54.565Z</updated>
    
    <content type="html"><![CDATA[<p>本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.<br>流是java8中一个新的概念,它允许你以<font color="red">声明性</font>方法处理数据集合<br>,类似于SQL语句,可以<font color="red">透明地</font>并行处理.<br>并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！</p><a id="more"></a><h3 id="流的带来的好处有以下"><a href="#流的带来的好处有以下" class="headerlink" title="流的带来的好处有以下:"></a>流的带来的好处有以下:</h3><p>1.声明性——更简洁,更易读<br>2.可复合——更灵活<br>3.可并行——性能更好</p><h3 id="流中的几个概念"><a href="#流中的几个概念" class="headerlink" title="流中的几个概念:"></a>流中的几个概念:</h3><p>1.元素序列—— 集合讲的是数据,流讲的是计算.<br>2.源—— 流会使用一个提供数据的源.<br>3.数据处理操作—— 流的数据处理功能支持类似于数据库的操作,以及函数式编程中常用的操作,可以是顺序或者并行执行.</p><h3 id="流操作两个重要的特点"><a href="#流操作两个重要的特点" class="headerlink" title="流操作两个重要的特点:"></a>流操作两个重要的特点:</h3><p>1.<strong><font color="red">流水线</font></strong>——很多流操作本身会返回一个流,这样多个操作就可以链接起来,形成一个大的流水线.(ps:类似于sql的查找)</p><p>2.<strong><font color="red">内部迭代</font></strong>——于使用迭代器显示迭代的集合不同,流的迭代操作是在背后进行的.</p><p>3.<strong><font color="red">流只能遍历一次,遍历完就已经被消费掉了</font></strong>,可以从原始数据源重新获得一个新的流.反正会报错.</p><p>外部迭代是用户使用Collection接口自己去做迭代.<br>内部迭代是它自动帮你把迭代做了,还把得到的流值存在某个地方,你只需要给出一个函数说要干什么就完事了,是不是很轻松.而且内部迭代是透明地并行处理,或者用更优化的顺序(某些合适你硬件的数据表示)进行处理.</p><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p><strong>中间操作</strong>——会返回另一个流,这样可以多个操作连接起来,更重要的是,<br>除非流水线上触发一个终端操作,否则中间操作不会执行任何处理——他们很懒(惰性求值).<br>这是因为中间操作一般是可以合并起来,在终端操作时一次性全部处理.</p><p><strong>终端操作</strong>——从流的流水线生成结果,<font color="red">其结果是任何不是流的值</font>.(List,Integer,甚至是void)</p><h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><p>1.一个数据源(如集合)来执行一个查询.<br>2.一个中间操作链,形成一条流的流水线.<br>3.一个终端操作,执行流水线,并能生成结果.</p><h4 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h4><p>用谓词筛选,筛选出各不相同的元素</p><p>filter()—-&gt;该操作会接受一个谓词(一个返回boolean的函数)作为参数,并返回一个包含所有符合谓词的元素的流.</p><p>distinct()—-&gt;它会返回一个元素各异(根据流所生成元素的hashCode和equals方法实现)的流.</p><p>limit()—-&gt;该方法会返回一个不超过给定长度的流.</p><p>skip(n)—-&gt;返回一个扔掉前n个元素的流,如果流中元素不足n个,则返回一个空流.</p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>map()—-&gt;它会接受一个函数作为参数,这个函数会被应用到每个元素上,并将其映射成一个新的元素.</p><p>flatMap()—-&gt;各个数组并不是分别映射成一个流,而是映射成流的内容.也就是生成的单个流被合并起来,即扁平化为一个流.</p><h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><p>anyMatch()—-&gt;检查谓词是否至少匹配一个元素,返回一个boolean,是一个终端操作.</p><p>allMatch()—-&gt;检查谓词是否匹配所有元素.</p><p>noneMacth()—-&gt;确保流中没有任何元素与给定的谓词匹配.<br>以上三个操作都具有<font color="red">短路</font>的特性.(当搜索的条件满足时,就不会继续下去了)</p><p>findAny()—-&gt;返回当前流中的任意元素.</p><p>findFirst()—-&gt;返回当前流中的第一个元素.</p><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><p>将流中所以元素反复结合起来,得到一个值.这样的查询可以被归类为归约操作.(函数编程的术语为折叠)</p><p>reduce(0,(a,b) -&gt; a + b);<br>或者直接Integer里面的静态sum方法求和<br>reduce(0,Integer::sum);<br>或者求最大值、最小值<br>reduce(0,Integer::min);<br>reduce(0,Integer::max);</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trader zlw1 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw1"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line">        Trader zlw2 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw2"</span>, <span class="hljs-string">"sz"</span>);</span><br><span class="line">        Trader zlw3 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw3"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line">        Trader zlw4 = <span class="hljs-keyword">new</span> Trader(<span class="hljs-string">"zlw4"</span>, <span class="hljs-string">"hb"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transactions&gt; transactions1 = Arrays.asList(</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw4, <span class="hljs-number">2011</span>, <span class="hljs-number">300</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw1, <span class="hljs-number">2012</span>, <span class="hljs-number">1000</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw1, <span class="hljs-number">2011</span>, <span class="hljs-number">400</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw2, <span class="hljs-number">2012</span>, <span class="hljs-number">710</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw2, <span class="hljs-number">2012</span>, <span class="hljs-number">700</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> Transactions(zlw3, <span class="hljs-number">2012</span>, <span class="hljs-number">950</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//找出2011年发生的交易,并按交易排序(低到高)</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .filter(tran -&gt; tran.getYear() == <span class="hljs-number">2011</span>)</span><br><span class="line">                .sorted(Comparator.comparing(Transactions::getValue))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//交易员在那些不同的城市工作</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .map(transactions2 -&gt; transactions2.getTrader().getCity()).distinct()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//返回所有湖北的交易员,并按姓名排序</span></span><br><span class="line">        transactions1.stream()</span><br><span class="line">                .map(Transactions::getTrader)</span><br><span class="line">                .filter(Trader -&gt; Trader.getCity().equals(<span class="hljs-string">"hb"</span>))</span><br><span class="line">                .distinct().sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//返回所以交易员的姓名字符串,按字母排序  此方法的效率不高 其reduce()中使用String拼接</span></span><br><span class="line">        String reduce = transactions1.stream()</span><br><span class="line">                .map(Transactions -&gt; Transactions.getTrader().getName()).distinct()</span><br><span class="line">                .reduce(<span class="hljs-string">""</span>, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//有没有在sz工作过的</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> sz = transactions1.stream()</span><br><span class="line">                .anyMatch(Transactions -&gt; Transactions.getTrader().getCity().equals(<span class="hljs-string">"sz1"</span>));</span><br><span class="line">        System.out.println(sz);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//打印所以在湖北的交易员的交易额</span></span><br><span class="line">        transactions1</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(transactions -&gt; transactions.getTrader().getCity().equals(<span class="hljs-string">"hb"</span>))</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//输出交易中,交易额最高的交易额</span></span><br><span class="line">        Integer max = transactions1.stream()</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .reduce(Integer::max)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        System.out.println(<span class="hljs-string">"-------------------"</span>);</span><br><span class="line">        <span class="hljs-comment">//最小的交易额</span></span><br><span class="line">        Integer min = transactions1.stream()</span><br><span class="line">                .map(Transactions::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(min);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h3><p>之前 .reduce(0, Integer::sum),<br>有一个暗含的装箱成本,将每个Integer拆箱成一个原始类型.在进行求和,<br>所以Stream API 提供原始类型流特化,来避免<font color="red">暗含的装箱成本,自动拆箱的操作</font>. IntStream—&gt; int<br>DoubleSteam—&gt; double<br>LongStream—&gt; long</p><p>1.映射到数据流<br>mapToInt()<br>mapToDouble()<br>mapToLong()<br>以上方法很之前的map()的工方式一样,只不过他们返回的是一个特化流,而不是Stream<t>.</t></p><p>2.转换回对象流<br>boxed();<br>特化流转换回非特化流.</p><p>3.默认值OptionalInt<br>如果流为空,那sum默认返回0,那你就无法区别流中是否有元素和最大值就是0的流?<br>所以对于三个原始特化流,就分别有一个Optional原始类型特化版.<br>OptionalInt<br>OptionalDouble<br>OptionalLong</p><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>第一个参数接受起始值,第二个是参数接受结束值<br>range —&gt; 不包含结束值<br>rangeClosed —&gt; 包含结束值</p><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><p>1.由值创建流<br>Stream.of<br>example: Stream<string>stream = Stream.of(“java”, “c++”, “Python”, “go”);</string></p><p>2.由数组创建流<br>Arrays.stream(),参数传的是什么类型的,Stream就是XXXStream<br>int[] numbers ={1,2,3,4,5,6};<br>int asInt = Arrays.stream(numbers).max().getAsInt();</p><p>3.由文件生成流<br>Files.lines</p><p>4.由函数生成流:创建无限流<br>没有固定的长度,根据函数按需创建值,可以无尽的计算下去.这个流是无界的<br>Stream.iterate<br>新生成的值应用函数</p><figure class="highlight java hljs"><figcaption><span>title:斐波那契数列</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,t -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;t[<span class="hljs-number">1</span>],t[<span class="hljs-number">0</span>]+t[<span class="hljs-number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="hljs-number">20</span>)</span><br><span class="line">        .forEach(t -&gt; System.out.print( t[<span class="hljs-number">0</span>]+<span class="hljs-string">" "</span>));</span><br></pre></td></tr></table></figure><p>Stream.generate</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.&lt;br&gt;流是java8中一个新的概念,它允许你以&lt;font color=&quot;red&quot;&gt;声明性&lt;/font&gt;方法处理数据集合&lt;br&gt;,类似于SQL语句,可以&lt;font color=&quot;red&quot;&gt;透明地&lt;/font&gt;并行处理.&lt;br&gt;并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 线性表</title>
    <link href="http://yoursite.com/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/12/04/数据结构-线性表/</id>
    <published>2019-12-04T14:23:25.000Z</published>
    <updated>2019-12-05T15:50:35.601Z</updated>
    
    <content type="html"><![CDATA[<p>线性表的知识是之后的基础,一定要完全掌握.</p><a id="more"></a><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表是具有相同特性数据元素的一个<strong><font color="red">有序</font></strong>序列,长度为n.</p><h3 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h3><p>(1)顺序存储结构(顺序表)<br><font color="red">随机访问特性<br>占用连续的存储空间<br>顺序表插入操作的时候要移动多个元素</font><br>(2)链式存储结构(链表)<br><font color="red">不支持随机访问<br>结点的存储空间利用率较顺序表稍低一些<br>动态分配<br>进行插入操作无须移动元素</font></p><h3 id="链表有以下5种"><a href="#链表有以下5种" class="headerlink" title="链表有以下5种:"></a>链表有以下5种:</h3><p>(1)单链表<br>①.带头结点的<br>头指针head指向头结点,头结点的值域<font color="red">不含任何信息</font>,从头结点的后继结点<br>开始存储数据信息,头结点始终不等于NULL,head-&gt;next==NULL的时候,链表为空.<br>②.不带头结点的<br>头指针head直接指向开始结点,head==NULL时,链表为空.<br>(2)双链表<br>除了前后结点,每个结点有两指针域分别指向前后两结点<br>(3)循环单链表<br>就是尾节点不是指向NULL,而是指向头结点,没有带头结点就指向第一个节点,头尾相邻形成一个环.<br>(4)循环双链表<br>前后结点形成环即可.<br>(5)静态链表<br>借助一维数组.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表的知识是之后的基础,一定要完全掌握.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 基本概念</title>
    <link href="http://yoursite.com/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/12/04/数据结构-基本概念/</id>
    <published>2019-12-04T11:28:39.000Z</published>
    <updated>2019-12-04T14:20:15.714Z</updated>
    
    <content type="html"><![CDATA[<p>这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。</p><a id="more"></a><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a><strong>1.数据</strong></h3><p>能<font color="red">输入</font>到计算机且能被计算机程序<font color="red">处理</font>的符号总称.(整数,字符串等)</p><h3 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2.数据元素"></a><strong>2.数据元素</strong></h3><p>是数据的基本单位,一个数据元素可能由若干个数据项组成.</p><h3 id="3-数据项"><a href="#3-数据项" class="headerlink" title="3.数据项"></a><strong>3.数据项</strong></h3><p>是数据结构中<font color="red">最小的单位</font>,是数据记录中最基本的、不可分割的数据单位.</p><h3 id="4-数据对象"><a href="#4-数据对象" class="headerlink" title="4.数据对象"></a><strong>4.数据对象</strong></h3><p>相同的数据元素的集合,是数据的一个子集.</p><h3 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5.数据结构"></a><strong>5.数据结构</strong></h3><p>相互之间存在一种或者多种<font color="red">特定关系</font>的数据元素的集合,包括一下三方面:<br>逻辑结构、存储结构、对数据的运算.</p><h3 id="6-数据的逻辑结构"><a href="#6-数据的逻辑结构" class="headerlink" title="6.数据的逻辑结构"></a><strong>6.数据的逻辑结构</strong></h3><p>是数据之间关系的描述,与数据的存储结构无关.</p><h4 id="①-线性结构"><a href="#①-线性结构" class="headerlink" title="①.线性结构"></a><strong>①.线性结构</strong></h4><p>是一个数据元素的有序集合,元素之间存在着”<font color="red">一对一</font>“的线性关系的数据结构，除了头尾元素,其他元素有且只有一个”前驱”和一个”后继”.</p><h4 id="②-非线性结构"><a href="#②-非线性结构" class="headerlink" title="②.非线性结构"></a><strong>②.非线性结构</strong></h4><p>与线性结构不同的是,元素之间存在”一对多”的关系.</p><h3 id="7-数据的物理结构"><a href="#7-数据的物理结构" class="headerlink" title="7.数据的物理结构"></a><strong>7.数据的物理结构</strong></h3><p>是数据的逻辑结构在计算机中的表示(映像–&gt;顺序映像和非顺序映像),包括<font color="red">数据</font>的表示和<font color="red">关系</font>的表示.</p><h4 id="①-顺序存储方法"><a href="#①-顺序存储方法" class="headerlink" title="①.顺序存储方法"></a><strong>①.顺序存储方法</strong></h4><p>把逻辑上相邻的结点存储在物理位置上相邻的存储单元上.(数组)</p><h4 id="②-链式存储方法"><a href="#②-链式存储方法" class="headerlink" title="②.链式存储方法"></a><strong>②.链式存储方法</strong></h4><p>不要求逻辑上相邻的结点在物理位置上也相邻,结点的逻辑关系是由附加的指针字段来表示的.(链表)</p><h4 id="③-索引存储方法"><a href="#③-索引存储方法" class="headerlink" title="③.索引存储方法"></a><strong>③.索引存储方法</strong></h4><p>在存储结点信息时除建立存储结点信息外,还建立附加的索引表来标识结点的地址.索引项的一般形式是&lt;关键字,地址&gt;</p><h4 id="④-散列存储方法"><a href="#④-散列存储方法" class="headerlink" title="④.散列存储方法"></a><strong>④.散列存储方法</strong></h4><p>根据结点的关键字通过散列函数直接计算出该结点的存储地址.</p><h1 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a><strong>算法的基本概念</strong></h1><p>1.算法的特性<br>(1)有穷性<br>(2)确定性<br>(3)输入<br>(4)输出<br>(5)可行性</p><p>2.算法的设计目标<br>(1)正确性<br>(1)可读性<br>(1)健壮性<br>(1)高效率与低存储量需求</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构总体的思维导图</title>
    <link href="http://yoursite.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E4%BD%93%E7%9A%84%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/11/30/数据结构总体的思维导图/</id>
    <published>2019-11-30T13:17:53.000Z</published>
    <updated>2019-11-30T13:29:31.239Z</updated>
    
    <content type="html"><![CDATA[<p>自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。</p><p>这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.</p><a id="more"></a><p><img src="/images/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。&lt;/p&gt;&lt;p&gt;这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-5</title>
    <link href="http://yoursite.com/2019/11/13/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-5/"/>
    <id>http://yoursite.com/2019/11/13/Linux-学习日志-5/</id>
    <published>2019-11-13T04:21:54.000Z</published>
    <updated>2019-11-25T07:44:25.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-磁盘与文件系统管理"><a href="#Linux-磁盘与文件系统管理" class="headerlink" title="Linux 磁盘与文件系统管理"></a><strong>Linux 磁盘与文件系统管理</strong></h3><p>磁盘的组成<br>圆形的磁盘盘(主要记录数据的部分)<br>机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)<br>主轴马达,可以转动磁盘盘</p><a id="more"></a><p>磁盘盘的组成</p><ul><li>扇区(Sector)为最小的物理储存单位,目前主要有 512bytes 与4K 两张格式.</li><li>将扇区组成一个圆,那就是磁柱;</li><li>早期的分区主要是以磁柱为最小分区单位,现在的分区通常使用扇区为最小分区单位(每一个扇区都有号码)</li><li>磁盘的分区表主要有两种格式,一个是限制较多的<font color="red">MBR分区表</font>,一种是较新且限制较少的<font color="red">GPT分区表</font></li><li>MBR分区表中,第一个扇区最重要,里面有:<br>(1)主要开机区(Master boot record)及分区表(partition table) MBR 占有446bytes 而 partition table 占有 64bytes</li><li>GPT分区表除了分区数量扩展开了</li></ul><p>所有的磁盘文件名已经被模拟成<br>/dev/sd[a-p][1-128]<br>/dev/vd[a-d][1-128]</p><p>文件系统特性</p><p>superblock: 记录filesystem 的整体信息,包括inode/block的总量、使用量、剩余量,及文件系统的格式和相关信息等</p><p><img src="http://q1ika11wl.bkt.clouddn.com/43753889_p0.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux-磁盘与文件系统管理&quot;&gt;&lt;a href=&quot;#Linux-磁盘与文件系统管理&quot; class=&quot;headerlink&quot; title=&quot;Linux 磁盘与文件系统管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux 磁盘与文件系统管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;磁盘的组成&lt;br&gt;圆形的磁盘盘(主要记录数据的部分)&lt;br&gt;机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)&lt;br&gt;主轴马达,可以转动磁盘盘&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IDEA Debug调试</title>
    <link href="http://yoursite.com/2019/11/04/IDEA-Debug%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2019/11/04/IDEA-Debug调试/</id>
    <published>2019-11-04T07:48:21.000Z</published>
    <updated>2019-11-04T08:30:56.904Z</updated>
    
    <content type="html"><![CDATA[<p>Debug调试的一些技巧</p><a id="more"></a><p><img src="/images/IDEA/IDEADebug.png" alt><br>从左向右<br>1.光标在其他的行或者页面,点击可以跳转到当前代码执行的行<br>(Alt + F10)<br>2.步过,一行一行往下走,这打断点的行上面有方法不会进入方法<br>(F8)<br>3.步入,如果当前行有方法,可以进入这个方法内部,一般是自定义方法,不会是函数库里面的方法<br>(F7)<br>4.强制步入,能进入任何方法<br>(Alt+Shift+F7)<br>5.步出,从步入的方法内退出到方法调用出,此时方法已执行完毕,只是没有完成赋值<br>(Shift+F8)<br>6.回退断点<br>7.运行到光标处,而不需要打断点<br>(Alt+ F9)<br>8.计算表达式 可以直接选择某个表达式再Alt + F8 直接在窗口输出的结果,也可以自己设置参数<br>(Alt + F8)</p><p><img src="/images/IDEA/IDEADebug2.png" alt><br>1.重新运行程序,关闭服务后重新启动程序<br>2.恢复程序(F9)<br>3.暂停程序<br>4.连续按两下,关闭程序(Ctrl+F2)<br>5.查看所有断点<br>6.哑的断点,选择这个后,所有的断点变成灰色,断点失效,按F9直接运行完程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Debug调试的一些技巧&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-4</title>
    <link href="http://yoursite.com/2019/11/03/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-4/"/>
    <id>http://yoursite.com/2019/11/03/Linux-学习日志-4/</id>
    <published>2019-11-03T14:30:54.000Z</published>
    <updated>2019-11-13T04:17:37.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux文件与目录的默认权限与隐藏权限"><a href="#Linux文件与目录的默认权限与隐藏权限" class="headerlink" title="Linux文件与目录的默认权限与隐藏权限"></a><strong>Linux文件与目录的默认权限与隐藏权限</strong></h3><p>目前用户在建立文件或目录时候的权限默认值<br>umask<br>数字的方式显示<br>0022 第一组是特殊权限<br>umask -S<br>字符的方式显示<br>该默认值是需要减掉的权限<br>0022</p><a id="more"></a><p>建立的文件默认权限是644(6-0,6-2,6-2)<br>建立的目录的默认 权限是755(7-0,7-2,7-2)<br>设置umask 002 就可以改变当前的默认值<br>rwxr-xr-x</p><!--more--><p>文件的隐藏属性<br>暂时不看</p><p>Set UID</p><p>查看文件类型<br>file 文件名</p><p>脚本文件名搜索<br>which [-a] command<br>a 就是all PATH中可以找到的所有指令列出来</p><p>文件的档名的搜寻<br>whereis [-bmsu] 文件或者文件名<br>[-l] 可以列出 whereis 会去查询的几个主要目录而已<br>[-b] 只找binary格式的文件<br>[-m] 只找说明文件 manual<br>[-s] 只找source来源的文件<br>[-u] 搜索不在上述三个项目当中的其他特殊文件</p><p>find指令 花费的时间很大(因为它是直接搜寻硬盘)<br>whereis指令 只找几个特定的目录而已,并没有全系统的去查询(主要是针对/bin/sbin底下的执行档)<br>locate指令 寻找的数据是在(已建立的数据库 /var/lib/mlocate/)</p><p>locate [-ir] keyword(文件的部分名称)<br>[-i] 忽略大小写<br>[-c] 不输出档名,仅计算找到的文件数目<br>[-l] 输出几行的意思 -l 5<br>[-S] 输出locate 使用的数据库文件的相关信息<br>[-r] 正规可接正规表示法显示方式<br>因为locate是经数据库来搜寻的,而数据库的建立默认是在每天执行一次,那么你新建的文件使用这个指令可能找不到,所以必须跟新数据库<br>使用updatedb来更新</p><p>find [PATH] [option] [option]<br>有 -atime, -ctime , -mtime<br>-mtime<br>n 　n为数字,意义在n天之前的[一天之内]被更动过内容的文件<br>+n 　n天<b>之前</b>被更动过内容的文件档名(不包括n天本身)<br>-n　 n天<b>之内</b>被更改内容的文件档名<br>-newer file 　 file为一个存在的文件,列出比file 还要新的文件档名<br>find / -mtime 0<br>find Desktop -newer /</p><p>与使用者或者组名有关的参数<br>-uid n　 n为数字,这个数字是用户的账号的UID<br>-gid n　 n为数字,这个数字是组名的GID<br>-user name 　name为使用者的名字<br>-group name　 name为组名<br>-nouser　 寻找文件拥有者不存在的与 /etc/passwd 的人<br>-nogroup 　寻找文件的拥有群组不存在 /etc/group 的文件</p><p>与文件的权限及名称有关的参数<br>-name filename　 搜索文件名为filename的文件<br>-size [+-]SIZE 　 搜寻比SIZE 还要大(+)或(-)的文件.<br>　 c: byte k:1024bytes 要找20KB还要大的文件<br>-size +50k<br>-type TYPE　 搜寻文件的类型为TYPE的,(一般正规文件f,装置文件b、c,d,l,s,p)<br>-perm mode　 搜寻文件权限刚好等于 mode的文件<br>-perm -mode　 搜寻文件权限[必须全部包括mode的权限]的文件<br>-perm /mode　 搜寻文件权限[包括任一mode的权限]的文件</p><p>额外可进行的动作<br>-exec command exec后面可以接其他的指令<br>-print 打印输出显示</p><p>find / size +1M -exec ls -l {} ;<br>-exec 后面的指令不支持命令别名<br>{} 代表的是[由find找到的内容],find的结果会被放置到{}位置中<br>;是关键词,表示find 额外的动作开始(-exec)到结束(;),在中间的就是find指令内的额外的动作<br>[;] 在bash环境下有特殊的意义,因此利用反斜杠来跳脱</p><p>一. 让某用户进入某目录成为[可工作目录]的基本权限<br>用户至少有对这个目录需要具有 x 权限</p><p>二.让某用户在某个目录内读取一个文件的基本权限<br>用户至少对这个目录具有x权限<br>对文件具有r权限</p><p>三.让一个用户可以修改文件的权限<br>用户至少对这个目录具有x权限<br>对文件具有r w 权限</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux文件与目录的默认权限与隐藏权限&quot;&gt;&lt;a href=&quot;#Linux文件与目录的默认权限与隐藏权限&quot; class=&quot;headerlink&quot; title=&quot;Linux文件与目录的默认权限与隐藏权限&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux文件与目录的默认权限与隐藏权限&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;目前用户在建立文件或目录时候的权限默认值&lt;br&gt;umask&lt;br&gt;数字的方式显示&lt;br&gt;0022 第一组是特殊权限&lt;br&gt;umask -S&lt;br&gt;字符的方式显示&lt;br&gt;该默认值是需要减掉的权限&lt;br&gt;0022&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-3</title>
    <link href="http://yoursite.com/2019/11/01/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-3/"/>
    <id>http://yoursite.com/2019/11/01/Linux-学习日志-3/</id>
    <published>2019-11-01T01:27:11.000Z</published>
    <updated>2019-11-03T13:55:12.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux目录管理"><a href="#Linux目录管理" class="headerlink" title="Linux目录管理"></a><strong>Linux目录管理</strong></h3><p>绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)<br>相对路径:[不是由/写起]</p><a id="more"></a><blockquote><p>. 　　 (代表此层目录 )<br>.. 　　 (代表上一层目录 )<br>- 　　 (代表签一个工作目录 )<br>~ 　　 (代表[当前用户身份]所在的家目录 )<br>~zlw 　(代表zlw这个用户的家目录 )</p></blockquote><h3 id="常用的处理目录指令"><a href="#常用的处理目录指令" class="headerlink" title="常用的处理目录指令"></a>常用的处理目录指令</h3><p>cd 变换目录</p><p>pwd 显示当前目录</p><p>mkdir 建立一个新的目录<br>[-m]创建目录的时候直接设定权限<br>[-p]直接将要创建所需要的目录递归建立起来! example:<br>mkdir -p text1/text2/text3<br>ls -ld test*</p><p>rmdir 删除一个空的目录<br>[-p] 连同[上层][空的]目录一起删除<br><strong><font color="red">被删除的目录里面必定不能存在其他的目录或者文件!</font></strong></p><p>为什么我可以在任何地方执行/bin/ls 这个指令?<br>是因为环境变量$PATH 指定了/bin/ls,若把ls文件移入到/root下,则无法使用ls指令,可以<br>PATH=”${PATH}:/root” 加入到执行文件搜寻路径PATH中</p><h2 id="文件与目录是检视-ls"><a href="#文件与目录是检视-ls" class="headerlink" title="文件与目录是检视: ls"></a>文件与目录是检视: <strong>ls</strong></h2><p><font color="red">[-a] 显示全部文件,包括隐藏档,包括(.)(..)</font><br>[-A]　　 显示全部文件,包括隐藏档,不包括(.)(..)<br><font color="red">[-d]　　 仅列出目录本身,不是目录下的文件数据(查询目录需要加)</font><br>[-r]　　 直接列出结果,不排序(ls会以档名排序)<br>[-h]　　 文件容量以人类易读的方式(GB KB)列出来<br>[-i] 　　列出inode 号码，<br>[-F] 　　根据文件,目录等信息,给予附加数据结构<br><font color="red">[-l] 　　长数据串行出</font><br>[-S] 　　以文件容量大小排序<br>[-r] 　　反序输出<br>[-t] 　　以时间排序<br>[-R] 　　连同子目录一起列出来,等于输出显示所有文件<br>[-n]　　 列出UID跟GID,(而不是使用者跟群组)<br>–color=never 不根据文件特性给予颜色显示<br>–color=always 显示颜色<br>–color=auto 系统自动判断<br>–full–time 以完整的时间模式(年月日时分)输出</p><h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 <strong>cp</strong></h3><p>cp 　 [-adfilprsu] 　 来源文件(source) 　目标文件(destination)<br>cp 　[options] 　source1 　source2 　source3… 　directory<br><font color="red">[-a] 　　相当于-dr –preserve=all的意思</font><br>[-d] 　　若来源文件为链接文件的属性(link file),则复制链接文件属性而非文件本身<br>[-f] 　　强制(force),若目标文件已经存在且无法开启,则移除后再尝试一次<br><font color="red">[-i] 　　目标文件存在,覆盖之前询问</font><br>[-l] 　　进行硬链接(hard link)的连档建立,而非复制文件本身<br><font color="red">[-p] 　　连同文件的属性(权限,用户,时间)一起复制,而非使用默认属性</font><br><font color="red">[-r] 　　递归持续复制,用于目录的复制行为</font><br>[-s] 　　复制成为符号链接文件(symbolic link),亦即[快捷方式]文件<br>[-u] 　　destination 比 source 旧才跟新 destination,或者destination 不存在的情况下才复制</p><h3 id="移除-rm"><a href="#移除-rm" class="headerlink" title="移除 rm"></a>移除 <strong>rm</strong></h3><p>rm [-fir] 文件或目录<br>[-f] 强制删除,忽略不存在的文件,不会出现警告<br>[-i] 询问<br>[-r] 递归删除! rm -r /tmp/etc<br>如果身份是root ,预计加入 -i 的选项,需要一直按y才会删除<br>可以按[Ctrl] + c 结束<br>这是一种保护动作,如果不需要<br>\rm -r /tmp/etc<br>删除档名第一个字符有[-] -aaa- 因为’-‘是选项,系统会误判<br>rm ./-aaa-</p><h3 id="移动-mv"><a href="#移动-mv" class="headerlink" title="移动 mv"></a>移动 <strong>mv</strong></h3><p>mv [-fiu] source destination<br>mv [options] source1 source2 source3 … directory<br>[-f] 强制,如果存在的文件,不会询问直接覆盖<br>[-i] 询问<br>[-u] 若目标文件存在,且source比较新,才会更新(update)</p><p>更改名字<br>mv mytest mytest1<br>取得最后的档名<br>basename<br>取得目录名<br>dirname</p><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><p>cat 由第一行开始显示文件内容<br>tac 从最后一行开始显示, tac就是cat倒着写的！<br>nl 显示行号<br>more 一页一页显示文件内容<br>less 比moreg好,可以向前翻页<br>head 只看前几行 -n (默认10行)<br>tail 只看后几行 -n (默认10行)<br>od 二进制的方式读取文件内容</p><p>cat [-AbEnTv]<br>[-A] 相当于-vET的整合<br>[-b] 列出行号,仅对非空白行,空白行不标行号<br>[-E] 结尾断行字符$显示出来<br>[-n] 打印出行号,空白行也打印<br>[-T] 将[tab]按键以 ^[显示出来<br>[-v] 列出一些看不到的特殊字符</p><p>more<br>空格 代表向下翻一页<br>Enter 代表向下翻一行<br>/字符串 [字符串]搜索<br>:f 立即显示出文件名和行数<br>q 退出<br>b 或者[Ctrl] + b 往回翻页</p><p>less<br>/字符串 向下搜索<br>?字符串 向上搜索<br>q 退出<br>g 第一行<br>G 最后一行</p><p>修改文件时间或者建置新档 touch<br>三个主要的变动时间</p><p>modification time<br>当该文件的[内容数据]变更时,就会更新这个时间<br>status time<br>当该文件的[状态]变更时,就会更新这个时间(权限或者属性)<br>access time<br>当[该文件的内容被取用]时,就会更新这个时间(cat 去读取时)</p><p>ls显示出来的是该文件的mtime,也就是这个文件上一次的内容被改动的时间。<br>如果touch的文件不存在,那么会创建一个新的空文件.如果存在那么文件的三个时间(atime,ctime,mtime)都会更新为目前的时间<br>ll===&gt; ls -l(别名)<br>[;] 代表连续指令的下达! date ; ll bashrc ; ll –time=atime bashrc; ll –time=ctime bashrc;<br>touch [-acdmt] 文件<br>[-a] 仅修改atime<br>[-c] 仅修改文件时间,文件不存在不新建<br>[-d] 后面可以接修改的日期而不是目前的日期,也可以使用 –date=”日期或者时间”<br>[-m] 仅修改mtime<br>[-t] 后面可以接修改的时间而不用目前的时间,格式为[YYYYMMDDhhmm]<br>复制一个文件时,复制所有的属性,但没办法复制ctime.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux目录管理&quot;&gt;&lt;a href=&quot;#Linux目录管理&quot; class=&quot;headerlink&quot; title=&quot;Linux目录管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux目录管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)&lt;br&gt;相对路径:[不是由/写起]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-2</title>
    <link href="http://yoursite.com/2019/10/30/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-2/"/>
    <id>http://yoursite.com/2019/10/30/Linux-学习日志-2/</id>
    <published>2019-10-30T12:18:22.000Z</published>
    <updated>2019-11-01T00:41:18.563Z</updated>
    
    <content type="html"><![CDATA[<p>Linux最优秀的地方之一就是在于多人多任务环境<br>Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.</p><a id="more"></a><p>1.文件拥有者<br>我的东西,我想给谁看给谁看,我是主宰者!</p><p>2.群组<br>就是在一个群里面,我可以使用群组的资源,其他用户也可以使用。但不在群组里面的人肯定是不能使用的。</p><p>3.其他人<br>就是我有一个发小或者朋友,那么他也可以通过我来使用群组里面的资源。那么对于这个组里面的其他人,跟我这个发小并不认识,那么,发小就是他眼中的[其他人].<br>还是就是root账户,那他就是GOD!~,可以任意访问群组,访问他想访问的任何东西!</p><p>root的相关信息<br>/etc/passwd<br>个人的密码<br>/etc/shadow<br>所有的组名<br>/etc/group</p><h3 id="Linux的文件属性"><a href="#Linux的文件属性" class="headerlink" title="Linux的文件属性"></a><strong><font color="red">Linux的文件属性</font></strong></h3><p><img src="/images/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt></p><p>- rwx rwx —</p><p>第一个字符代表这个文件的类型:<br>[d] 目录<br>[-] 文件<br>[l] 连结档<br>[b] 装置文件里面的可供储存的接口设备<br>[c] 装置文件里面的串行端口设备,例如键盘,鼠标(一次性读取装置)</p><p>[r] 可读 (权值:4)<br>[w] 可写 (权值:2)<br>[x] 可执行 (权值:1)<br><font color="red">这三个权限的位置不会改变,没有权限,就会出现减号[-]</font><br>1.数字类型改变文件权限<br>2.符号类型改变文件权限<br>例如:<br>rwx= 4+2+1 = 7<br>rw-= 4+2+0 = 6<br>—= 0+0+0 = 0<br>基本上就九个权限分别是(1)user (2)group (3)others 可以用<b>u</b>,<b>g</b>,<b>o</b>代表这三个权限,<b>a</b>则代表all全部身份! [+] 加入 [-] 除去 [=]设定<br>chmod u=rwx,go=r text.txt<br>可以给每个角色分配一个[r]权限<br>chmod a+w text.txt</p><p>文件是否能被执行,则是籍由是否具有[x]这个权限来决定的,而不是根据扩展名。<br>[w] 不具备删除该文件本身的权限<br>目录里面的[x]代表用户能是否进入该目录成为工作目录。(工作目录就是目前所在的目录)<br>假如说你的home目录下有一个你无法访问的文件,就是文件拥有者是其他人,且你也不在这个群组里面,那么你可以删除这个文件！因为你具有home目录下的rwx的完整权限当然可以删除这个对于你来说的垃圾文件。</p><p>[文件拥有者的权限]<br>[加入此群组的账号的权限]<br>[非本人没有加入本群组的其他账号的权限]</p><p>如果档名之前多一个[.],则代表这个文件为[隐藏档]<br><font color="red">root基本上是不受系统的权限所控制的</font></p><p>[chgrp] 改变文件所属群组<br>[chown] 改变文件拥有者<br>[chmod] 改变文件的权限,SUI,SGID,SBIT</p><p>cp 来源文件 目标文件</p><p>为什么在操作目录时候需要[r][x], 单纯操作目录[x]就足够了,但没有r的权限,那就无法知道里面的文件夹放在哪个地方,使用[tab],他就无法自动帮你补齐档名了。</p><h3 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a><strong>Linux文件种类与扩展名</strong></h3><h4 id="任何装置在Linux底下都是文件"><a href="#任何装置在Linux底下都是文件" class="headerlink" title="任何装置在Linux底下都是文件"></a><strong><font color="red">任何装置在Linux底下都是文件</font></strong></h4><p>[-]<br>1.纯文本档(ASCII)<br>2.二进制文件(binary)<br>3.数据格式文件(data)<br>[d](directory)<br>[l](link)<br>类似window快捷方式<br>设备与装置文件(device)<br>[b] 就是一些储存数据,以提供系统随机存取的接口设备。(硬盘与软盘)<br>[c]一些串行端口的接口设备(鼠标与键盘,一次性读取,不能够截断输出)<br>资料接口文件(sockets)<br>[s] 数据接口文件<br>数据输送文件(FIFO,PIPE)<br>[p] 特殊的文件类型,主要的目的在解决多个程序同时存取一个文件造成的错误问题</p><p>常用的扩展名:<br>*.sh<br>脚本或批处理文件,因为批处理文件是shell写的<br>*.Z 　*.tar 　*.tar.gz　*.zip　*.tgz<br>打包的压缩文件<br>*.html　*.php<br>网页相关文件</p><p>Linux文件名的限制<br>* ? &gt; &lt; ; &amp;</p><p>[./] 本目录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux最优秀的地方之一就是在于多人多任务环境&lt;br&gt;Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 学习日志-1</title>
    <link href="http://yoursite.com/2019/10/30/Linux-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-1/"/>
    <id>http://yoursite.com/2019/10/30/Linux-学习日志-1/</id>
    <published>2019-10-30T12:11:57.000Z</published>
    <updated>2019-11-01T11:38:15.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要学了一些基础的指令-热键"><a href="#主要学了一些基础的指令-热键" class="headerlink" title="主要学了一些基础的指令,热键"></a><strong>主要学了一些基础的指令,热键</strong></h3><p>command [-options] parameter1 parameter2<br>指令 选项 参数1 参数2</p><a id="more"></a><p>date</p><p>date +%Y/%m/%d</p><p>date +%H:%M</p><p>cal</p><p>cal [month] [year]</p><p>bc<br>--quit 退出</p><p>热键<br>[tab] 具有[命令补全] 与 [文件补齐] 的功能! ca[tab][tab]</p><p>date --[tab][tab]</p><p>[Ctrl] + c 中断目前程序</p><p>[Ctrl] + d 键盘输入结束 可以取代(exit)</p><p>[Ctrl] + l 清屏</p><p>[shift] + [PageUP]|[Page Down] 向前/向后翻页</p><p>--help|less |more 都是可以进行翻页阅读</p><p>nano text.txt</p><p>观察系统的使用状态<br>netstat -a</p><p>sync 将数据同步写入硬盘中 (如果在内存中的没有写入硬盘,该指令就可以把内存中的数据写入硬盘)<br>shutdown (root用户下) poweroff<br>reboot halt</p><p>su - (身份变成root,底下输入root的密码)<br>shutdown 如果什么参数都没有加 则系统会在1分钟之后关机<br>-k 不是真的关机,只是发出警告！<br>-r 系统的服务停掉之后重新启动<br>-h 服务停掉之后关机<br>-c 取消shutdown指令内容</p><p>systemctl [指令]<br>halt shutdown reboot poweroff</p><p>pwd — 打印出当前工作目录名</p><p>cd — 更改目录</p><p>ls — 列出目录内容</p><p>ls — 列出目录内容</p><p>file — 确定文件类型</p><p>less — 浏览文件内容</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主要学了一些基础的指令-热键&quot;&gt;&lt;a href=&quot;#主要学了一些基础的指令-热键&quot; class=&quot;headerlink&quot; title=&quot;主要学了一些基础的指令,热键&quot;&gt;&lt;/a&gt;&lt;strong&gt;主要学了一些基础的指令,热键&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;command [-options] parameter1 parameter2&lt;br&gt;指令 选项 参数1 参数2&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java-8 方法引用</title>
    <link href="http://yoursite.com/2019/10/28/java-8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/28/java-8-方法引用/</id>
    <published>2019-10-28T06:35:59.000Z</published>
    <updated>2019-10-29T11:41:20.304Z</updated>
    
    <content type="html"><![CDATA[<p>方法引用: method reference<br>方法引用实际上是个Lambda表达式的一种语法糖<br>我们可以将方法引用看作是一个[函数指针]</p><a id="more"></a><p>*方法引用<br>classname::staticmethod<br>*方法调用<br>classname.staticmethod</p><h3 id="方法引用共分为4类"><a href="#方法引用共分为4类" class="headerlink" title="方法引用共分为4类"></a><strong>方法引用共分为4类</strong></h3><ul><li>类名::静态方法名</li><li>引用名(对象名)::实例方法名</li><li>类名::实例方法名(lambda表达式的第一个参数作为这个方法的调用者,之后的参数作为这个方法的参数)</li><li>构造方法引用　类名::new</li></ul><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a><strong>默认方法</strong></h3><p><strong>什么是默认方法</strong><br>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。<br><strong>为什么出现默认方法</strong><br>为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p><h3 id="java-8抽象类与接口对比"><a href="#java-8抽象类与接口对比" class="headerlink" title="java 8抽象类与接口对比"></a><strong>java 8抽象类与接口对比</strong></h3><table><thead><tr><th><strong>相同点</strong></th><th><strong>不同点</strong></th></tr></thead><tbody><tr><td>都是抽象类型</td><td>抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）</td></tr><tr><td>都可以有实现方法（以前接口不行）</td><td>抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系</td></tr><tr><td>都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）</td><td>接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</td></tr></tbody></table><h3 id="多重继承的冲突"><a href="#多重继承的冲突" class="headerlink" title="多重继承的冲突"></a><strong>多重继承的冲突</strong></h3><p>由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：<br>1.一个声明在类里面的方法优先于任何默认方法（classes always win）<br>2.否则，则会优先选取路径最短的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod1!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod2!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错 defaultTest inherits unrelated defaults for myMethod() from types MyInterface and MyInterface1<br>如果一定要这么写呢，同时实现MyInterface,MyInterface1并且使用MyInterface1中myMethod()？可以这么写：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">defaultTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface</span>,<span class="hljs-title">MyInterface1</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defaultTest defaultTest = <span class="hljs-keyword">new</span> defaultTest();</span><br><span class="line">        defaultTest.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MyInterface1.<span class="hljs-keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以这么写:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyInterface</span>,<span class="hljs-title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"myMethod3!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">defaultTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyInterface2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defaultTest defaultTest = <span class="hljs-keyword">new</span> defaultTest();</span><br><span class="line">        defaultTest.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MyInterface2.<span class="hljs-keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 myMethod3!! 可见MyInterface2.super表示的是MyInterface2接口，同时defaultTest无法访问MyInterface,MyInterface2的myMethod()</p><blockquote><p>可见MyInterface2虽然有同一个两个最短路径的myMethod(), 但是它自己有一个更高优先级的myMethod()，所以不会报错;</p></blockquote><p>默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;方法引用: method reference&lt;br&gt;方法引用实际上是个Lambda表达式的一种语法糖&lt;br&gt;我们可以将方法引用看作是一个[函数指针]&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>java-8 Optional类解析</title>
    <link href="http://yoursite.com/2019/10/28/java-8-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/28/java-8-Optional类解析/</id>
    <published>2019-10-28T02:20:03.000Z</published>
    <updated>2019-10-28T04:22:10.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。<br>新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><a id="more"></a><h4 id="of"><a href="#of" class="headerlink" title="of"></a><strong>of</strong></h4><blockquote><p>为非null的值创建一个Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//调用工厂方法创建Optional实例</span></span><br><span class="line">Optional&lt;String&gt; s = Optional.of(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"><span class="hljs-comment">//传入参数为null，抛出NullPointerException.</span></span><br><span class="line">Optional&lt;String&gt; s1 = Optional.of(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a><strong>ofNullable</strong></h4><blockquote><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况</span></span><br><span class="line"><span class="hljs-comment">//下面创建了一个不包含任何值的Optional实例</span></span><br><span class="line"><span class="hljs-comment">//例如，值为'null'</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a><strong>isPresent</strong></h4><blockquote><p>如果值存在返回true，否则返回false。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//isPresent方法用来检查Optional实例中是否包含值</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"ZLW"</span>);</span><br><span class="line">        String name = <span class="hljs-string">"zlw"</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(empty.isPresent())&#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a><strong>get</strong></h4><blockquote><p>如果Optional有值则将其返回，否则抛出NoSuchElementException。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a><strong>ifPresent</strong></h4><blockquote><p>如果Optional实例有值则为其调用consumer，否则不做处理<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ifPresent方法接受lambda表达式作为参数。</span></span><br><span class="line"><span class="hljs-comment">//lambda表达式对Optional的值调用consumer进行处理。</span></span><br><span class="line">empty.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a><strong>orElse</strong></h4><blockquote><p>如果有值则将其返回，否则返回指定的其它值。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 值为 null</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br><span class="line"><span class="hljs-comment">// 值为 zlw</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a><strong>orElseGet</strong></h4><blockquote><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span></span><br><span class="line"><span class="hljs-comment">//orElseGet可以接受一个lambda表达式生成默认值。</span></span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; <span class="hljs-string">"no value!"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a><strong>orElseThrow</strong></h4><blockquote><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">  <span class="hljs-comment">//orElseThrow与orElse方法类似。与返回默认值不同，</span></span><br><span class="line">  <span class="hljs-comment">//orElseThrow会抛出lambda表达式或方法生成的异常 </span></span><br><span class="line"></span><br><span class="line">  empty.orElseThrow(ValueAbsentException::<span class="hljs-keyword">new</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="hljs-comment">//输出: No value present in the Optional instance</span></span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueAbsentException定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueAbsentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"No value present in the Optional instance"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a><strong><font color="red">map</font></strong></h4><blockquote><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span></span><br><span class="line"><span class="hljs-comment">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; newempty = empty.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(newempty.orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h4><blockquote><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span></span><br><span class="line"><span class="hljs-comment">//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span></span><br><span class="line"><span class="hljs-comment">//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span></span><br><span class="line"> Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"> System.out.println(empty.flatMap((value) -&gt; Optional.of(value.toUpperCase())).orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h4><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p><blockquote><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//filter方法检查给定的Option值是否满足某些条件。</span></span><br><span class="line"><span class="hljs-comment">//如果满足则返回同一个Option实例，否则返回空Optional。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; s = empty.filter((value) -&gt; value.length() &gt; <span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(s.orElse(<span class="hljs-string">"The name is less than 6 characters"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。&lt;br&gt;新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>java-8 lambda 2</title>
    <link href="http://yoursite.com/2019/10/26/java-8-lambda-2/"/>
    <id>http://yoursite.com/2019/10/26/java-8-lambda-2/</id>
    <published>2019-10-26T08:31:28.000Z</published>
    <updated>2019-10-28T02:18:31.691Z</updated>
    
    <content type="html"><![CDATA[<p>关于函数式接口:</p><h5 id="1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。"><a href="#1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。" class="headerlink" title="1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。"></a>1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。</h5><h5 id="2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。"><a href="#2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。" class="headerlink" title="2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。"></a>2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。</h5><h5 id="3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。"><a href="#3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。" class="headerlink" title="3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。"></a>3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。</h5><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterfae</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-comment">// java.lang.Object 是所以类的父类 MyInterfae的实现类一点会直接或者间接的继承Object类 toString</span></span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他有lambda表达式语言中,lambda表达式的类型是函数,但在java中，Lambda表达式是对象,他们必须依附于一类特别的对象类型————函数式接口(functional interface)</p><h3 id="外部迭代"><a href="#外部迭代" class="headerlink" title="外部迭代"></a><strong>外部迭代</strong></h3><p>最传统的方法是用Iterator，当然还以用for i、增强for循环等等。这一类方法叫做外部迭代，意为显式地进行迭代操作，即集合中的元素访问是由一个处于集合外部的东西来控制的，在这里控制着循环的东西就是迭代器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = Arrays.asList(<span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> &#125;);</span><br><span class="line"><span class="hljs-keyword">for</span> (String letter : alphabets) &#123;</span><br><span class="line">    System.out.println(letter.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部迭代"><a href="#内部迭代" class="headerlink" title="内部迭代"></a><strong>内部迭代</strong></h3><p>顾名思义，这种方式的遍历将在集合内部进行，我们不会显式地去控制这个循环。无需关心遍历元素的顺序，我们只需要定义对其中每一个元素进行什么样的操作。注意在这种设定下可能无法直接获取到当前元素的下标。<br>比如JDK8提供的最新的Collection.forEach(…)方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alphabets.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a><strong>Function接口</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 代表这一个方法，能够接受一个参数，并且返回一个结果</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 将参数赋予给相应方法</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 先执行参数(即也是一个Function)的，再执行调用者(同样是一个Function)</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 先执行调用者，再执行参数，和compose相反。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 返回当前正在执行的方法</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[例子]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextIDEA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TextIDEA TextIDEA = <span class="hljs-keyword">new</span> TextIDEA();</span><br><span class="line">        System.out.println(TextIDEA.compute(<span class="hljs-number">2</span>,(value) -&gt; value * <span class="hljs-number">3</span>,(value) -&gt; value * value)); <span class="hljs-comment">// 12</span></span><br><span class="line">        System.out.println(TextIDEA.compute1(<span class="hljs-number">2</span>,(value) -&gt; value * <span class="hljs-number">3</span>,(value) -&gt; value * value));<span class="hljs-comment">// 36</span></span><br><span class="line">        System.out.println(TextIDEA.compute2(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,(value1,value2) -&gt; value1 * value2)); <span class="hljs-comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b, BiFunction&lt;Integer,Integer,Integer&gt; biFunction)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> biFunction.apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-comment">//唯一的抽象方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//且操作，既满足A也满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//且操作，既满足A也满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//或操作，满足A条件或者满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//静态方法，判定是否相等</span></span><br><span class="line">    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Predicate-1"><a href="#Predicate-1" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *这个接口是一个提供者的意思，只有一个get的抽象类，</span></span><br><span class="line"><span class="hljs-comment"> *没有默认的方法以及静态的方法，传入一个泛型T的，get方法，返回一个泛型T</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BinaryOperator"><a href="#BinaryOperator" class="headerlink" title="BinaryOperator"></a><strong>BinaryOperator</strong></h3><p>BinaryOperator:对同一类型的两个参数的操作比较操作,返回的和传入参数时相同的 ;<br>binaryOperator 继承制BiFunciton<br>方法1: minBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最小的对象<br>方法1: maxBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最大的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于函数式接口:&lt;/p&gt;&lt;h5 id=&quot;1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。&quot;&gt;&lt;a href=&quot;#1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。&quot; class=&quot;headerlink&quot; title=&quot;1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。&quot;&gt;&lt;/a&gt;1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。&lt;/h5&gt;&lt;h5 id=&quot;2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。&quot;&gt;&lt;a href=&quot;#2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。&quot; class=&quot;headerlink&quot; title=&quot;2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。&quot;&gt;&lt;/a&gt;2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。&lt;/h5&gt;&lt;h5 id=&quot;3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。&quot;&gt;&lt;a href=&quot;#3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。&quot; class=&quot;headerlink&quot; title=&quot;3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。&quot;&gt;&lt;/a&gt;3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。&lt;/h5&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 后缀补全</title>
    <link href="http://yoursite.com/2019/10/26/IDEA-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8/"/>
    <id>http://yoursite.com/2019/10/26/IDEA-后缀补全/</id>
    <published>2019-10-26T06:26:33.000Z</published>
    <updated>2019-11-04T07:40:51.770Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA 有个很厉害的功能，那就是后缀补全（不是自动补全），<br>这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。</p><p>使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。</p><a id="more"></a><ol><li><h3 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a><strong>var 声明</strong></h3><p><img src="/images/IDEA/var.gif" alt></p></li><li><h3 id="null判断"><a href="#null判断" class="headerlink" title="null判断"></a><strong>null判断</strong></h3><p><img src="/images/IDEA/null.gif" alt></p></li><li><h3 id="notnull判断"><a href="#notnull判断" class="headerlink" title="notnull判断"></a><strong>notnull判断</strong></h3><p><img src="/images/IDEA/notnull.gif" alt></p></li><li><h3 id="nn判断"><a href="#nn判断" class="headerlink" title="nn判断"></a><strong>nn判断</strong></h3><p><img src="/images/IDEA/nn.gif" alt></p></li><li><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><p><img src="/images/IDEA/if.gif" alt></p></li><li><h3 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h3><p><img src="/images/IDEA/return.gif" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA 有个很厉害的功能，那就是后缀补全（不是自动补全），&lt;br&gt;这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。&lt;/p&gt;&lt;p&gt;使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - 函数编程（lambda表达式）</title>
    <link href="http://yoursite.com/2019/10/25/Java-8-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%EF%BC%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/25/Java-8-函数编程（lambda表达式）/</id>
    <published>2019-10-25T11:16:08.000Z</published>
    <updated>2019-10-28T02:18:24.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p><strong>超过3行的逻辑就不适用Lambda表达式了</strong>。虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖(用更简练的言语表达较复杂的含义)”,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘.)<br>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口.lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</p><a id="more"></a><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><blockquote><p><font color="orange">(parameters) -&gt; expression</font><br>或(请注意语句的花括号)<br><font color="green">(parameters) -&gt; {expression}</font></p></blockquote><p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：<br>public int add(int x, int y) {<br>return x + y;<br>}<br>转成λ表达式后是这个样子：<br>(int x, int y) -&gt; x + y;<br>参数类型也可以省略，Java编译器会根据上下文推断出来：<br>(x, y) -&gt; x + y; //返回两数之和<br>或者<br>(x, y) -&gt; { return x + y; } //显式指明返回值<br>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。<br>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：<br>() -&gt; { System.out.println(“Hello Lambda!”); }<br>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：<br>c -&gt; { return c.size(); }</p><figure class="highlight java hljs"><figcaption><span>[lambda简单例子]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1.不需要参数 返回值 7</span></span><br><span class="line">() -&gt; <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-comment">// 2. 接受两个int类型参数 返回值 为 两者之和</span></span><br><span class="line">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) -&gt; x+y</span><br><span class="line"><span class="hljs-comment">// 3. 接受一个string类型参数,并进行打印,没有返回值</span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[循环输出]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 随便定义的数据</span></span><br><span class="line">        String[] str = &#123;<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"joe"</span>,<span class="hljs-string">"qjl"</span>,<span class="hljs-string">"lxl"</span>,<span class="hljs-string">"zc"</span>,<span class="hljs-string">"sam"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; players = Arrays.asList(str);</span><br><span class="line">        <span class="hljs-comment">// 以前的循环方式</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (String player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="hljs-string">"--------------"</span>);</span><br><span class="line">        <span class="hljs-comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">        players.forEach((player) -&gt; System.out.println(player));</span><br><span class="line">        System.out.println(<span class="hljs-string">"--------------"</span>);</span><br><span class="line">        <span class="hljs-comment">// 在 Java 8 中使用双冒号操作符(double colon operator)</span></span><br><span class="line">        players.forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[使用lambdas 来实现 Runnable接口]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 使用匿名内部类 1.1</span></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"Hello lambda1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式1.2</span></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Hello lambda2"</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用匿名内部类 2.1</span></span><br><span class="line">        Runnable hello_zlw_lambda1 = <span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"Hello zlw lambda1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式2.2</span></span><br><span class="line">        Runnable hello_zlw_lambda2 = () -&gt; System.out.println(<span class="hljs-string">"Hello zlw lambda2"</span>);</span><br><span class="line">        </span><br><span class="line">        hello_zlw_lambda1.run();</span><br><span class="line">        hello_zlw_lambda2.run();</span><br></pre></td></tr></table></figure><p><strong>使用Lambdas排序集合</strong><br>在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1.1 使用匿名内部类根据 name 排序</span></span><br><span class="line">String[] players = &#123;<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"joe"</span>,<span class="hljs-string">"qjl"</span>,<span class="hljs-string">"lxl"</span>,<span class="hljs-string">"zc"</span>,<span class="hljs-string">"sam"</span>&#125;;</span><br><span class="line">Arrays.sort(players, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (o1.compareTo(o2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">Comparator&lt;String&gt; sortName = (String o1, String o2) -&gt; o1.compareTo(o2);</span><br><span class="line">Arrays.sort(players,sortName);</span><br><span class="line"></span><br><span class="line">Arrays.sort(players,(String o1,String o2) -&gt; o1.compareTo(o2));</span><br><span class="line">System.out.println(Arrays.toString(players));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超过3行的逻辑就不适用Lambda表达式了&lt;/strong&gt;。虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖(用更简练的言语表达较复杂的含义)”,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘.)&lt;br&gt;Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口.lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java 8" scheme="http://yoursite.com/tags/java-8/"/>
    
  </entry>
  
  <entry>
    <title>平时看的好文章</title>
    <link href="http://yoursite.com/2019/10/24/%E5%B9%B3%E6%97%B6%E7%9C%8B%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/10/24/平时看的好文章/</id>
    <published>2019-10-24T11:56:37.000Z</published>
    <updated>2019-10-29T12:27:37.742Z</updated>
    
    <content type="html"><![CDATA[<p>技术人员的发展之路 –陈皓<br><a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17583.html</a></p><p>计算机专业学历重不重要<br><a href="https://zhuanlan.zhihu.com/p/84350029" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84350029</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术人员的发展之路 –陈皓&lt;br&gt;&lt;a href=&quot;https://coolshell.cn/articles/17583.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coolshell.cn/articles/17583.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;计算机专业学历重不重要&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/84350029&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/84350029&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="好文章" scheme="http://yoursite.com/tags/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+coding+github加速博客访问</title>
    <link href="http://yoursite.com/2019/10/24/Hexo-coding-github%E5%8A%A0%E9%80%9F%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2019/10/24/Hexo-coding-github加速博客访问/</id>
    <published>2019-10-24T05:09:05.000Z</published>
    <updated>2019-10-24T05:51:02.802Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用Hexo+github建立后访问博客速慢,是因为github服务器在国外，可能访问量太大，国内访问速度有些慢;<br>然后改用coding 托管代码</p><a id="more"></a><h1 id="什么是coding？"><a href="#什么是coding？" class="headerlink" title="什么是coding？"></a><strong>什么是coding？</strong></h1><p>简单的说coding就是类似于github的开源代码仓库，几乎是完全仿照github做的；虽然现在代码量并不多，但是部分地方还是比github方便一些的：</p><ul><li>中文界面，对我们来用起来更加方便；</li><li>可以免费创建私有仓库；</li><li>虽然服务器也在国外，但访问速度比github要快不少</li></ul><h1 id="注册coding并创建项目"><a href="#注册coding并创建项目" class="headerlink" title="注册coding并创建项目"></a><strong>注册coding并创建项目</strong></h1><p>这一部分很简单，不多说。需要注意的是创建项目的时候项目名称跟我们在github上创建时候类似，<br>项目名一定要是：用户名 + coding.me<br>创建Coding项目<br>创建完成之后，先完成下一步在进行其他步骤</p><h1 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a><strong>配置SSH Key</strong></h1><p>只是把其中的添加SSH key添加到GitHub的步骤换成下面的就行,添加SSH key到Coding<br>将上面生产的id_rsa.pub中的内容<br>添加SSH Key到Coding<br>coding 　　---&gt; 个人账户　　 ---&gt; SSH公钥 　　 ---&gt; 添加公钥<br>测试SSH Key 是否配置成功</p><figure class="highlight plain hljs"><figcaption><span>[git bash]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h1 id="Hexo部署添加Coding仓库"><a href="#Hexo部署添加Coding仓库" class="headerlink" title="Hexo部署添加Coding仓库"></a><strong>Hexo部署添加Coding仓库</strong></h1><p>修改Hexo博客目录下的站点配置文件_config.yml中的部署配置</p><figure class="highlight plain hljs"><figcaption><span>[_config.yml]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/ZlwPick/ZlwPick.github.io.git</span><br><span class="line">    coding: https://e.coding.net/zlwblog/zlw.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>重新执行Hexo部署命令，此时就会将Hexo博客部署到GitHub和Coding上了<br>hexo d<br>部署结束之后，Coding项目master分支下面就会有代码了<br>左侧菜单 　　---&gt; 部署 　　---&gt; 静态网址 　　---&gt; 把代码库里面的项目部署一下</p><h1 id="配置域名分流解析"><a href="#配置域名分流解析" class="headerlink" title="配置域名分流解析"></a><strong>配置域名分流解析</strong></h1><p><img src="/images/dns%E8%A7%A3%E6%9E%90.png" alt><br>dns修改之后需要一点时间刷新,之后在静态网页设置里面申请SSL证书(一定先把DNS中GitHub的解析关了,要不然申请失败),在下方打开https</p><h1 id="自动最小化静态文件"><a href="#自动最小化静态文件" class="headerlink" title="自动最小化静态文件"></a><strong>自动最小化静态文件</strong></h1><p>Chrome 开发者工具中提供的 Network 选项卡可以很方便的检测整个网站的文件传输情况。<br>通过输入 domain:kaitohh.com 筛选仅来自于源站的文件，可以看到所有来自于源站的文件及大小。<br>可以发现绝大部分文件都是一些网站本身的 CSS 和 JS，最大的文件是当前网站的 HTML 代码，这些文件由于经常会发生变动，<br>因此不能直接存在对象存储中。接下来，逐个预览这些文件，发现这些文件居然都没有最小化！<br>安装插件 <a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">https://github.com/chenzhutian/hexo-all-minifier</a></p><blockquote><p>$ npm install hexo-all-minifier –save</p></blockquote><p>_config.yml</p><blockquote><p>all_minifier: true</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用Hexo+github建立后访问博客速慢,是因为github服务器在国外，可能访问量太大，国内访问速度有些慢;&lt;br&gt;然后改用coding 托管代码&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 58.Length of Last Word</title>
    <link href="http://yoursite.com/2019/10/23/LeetCode-58-Length-of-Last-Word/"/>
    <id>http://yoursite.com/2019/10/23/LeetCode-58-Length-of-Last-Word/</id>
    <published>2019-10-23T11:08:28.000Z</published>
    <updated>2019-10-23T11:23:58.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Length-of-Last-Word-最后一个单词长度"><a href="#Length-of-Last-Word-最后一个单词长度" class="headerlink" title="Length of Last Word(最后一个单词长度)"></a><strong>Length of Last Word(最后一个单词长度)</strong></h1><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br><strong>示例</strong></p><blockquote><p><strong>输入:</strong> “Hello World”<br><strong>输出: 5</strong></p></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接从字符串最后开始先前找,总长度–,找到后记录那就是’ ‘之前的长度,再去用　　<br>总长度 - 去’ ‘之前的长度　=　最后一个单词的长度</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span> || s.length()==<span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">String trim = s.trim();　　<span class="hljs-comment">//去掉字符串两边的' '空格</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(trim.length()==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="hljs-keyword">int</span> n = trim.length() -<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (n&gt;=<span class="hljs-number">0</span> &amp;&amp; trim.charAt(n)!=<span class="hljs-string">' '</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> trim.length() - <span class="hljs-number">1</span> -n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Length-of-Last-Word-最后一个单词长度&quot;&gt;&lt;a href=&quot;#Length-of-Last-Word-最后一个单词长度&quot; class=&quot;headerlink&quot; title=&quot;Length of Last Word(最后一个单词长度)&quot;&gt;&lt;/a&gt;&lt;strong&gt;Length of Last Word(最后一个单词长度)&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。&lt;br&gt;如果不存在最后一个单词，请返回 0 。&lt;br&gt;说明：一个单词是指由字母组成，但不包含任何空格的字符串。&lt;br&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; “Hello World”&lt;br&gt;&lt;strong&gt;输出: 5&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
