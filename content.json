{"pages":[],"posts":[{"title":"Hexo+coding+github加速博客访问","text":"之前使用Hexo+github建立后访问博客速慢,是因为github服务器在国外，可能访问量太大，国内访问速度有些慢;然后改用coding 托管代码什么是coding？简单的说coding就是类似于github的开源代码仓库，几乎是完全仿照github做的；虽然现在代码量并不多，但是部分地方还是比github方便一些的：中文界面，对我们来用起来更加方便；可以免费创建私有仓库；虽然服务器也在国外，但访问速度比github要快不少注册coding并创建项目这一部分很简单，不多说。需要注意的是创建项目的时候项目名称跟我们在github上创建时候类似，项目名一定要是：用户名 + coding.me创建Coding项目创建完成之后，先完成下一步在进行其他步骤配置SSH Key只是把其中的添加SSH key添加到GitHub的步骤换成下面的就行,添加SSH key到Coding将上面生产的id_rsa.pub中的内容添加SSH Key到Codingcoding ---&gt; 个人账户 ---&gt; SSH公钥 ---&gt; 添加公钥测试SSH Key 是否配置成功[git bash]1$ ssh -T git@github.comHexo部署添加Coding仓库修改Hexo博客目录下的站点配置文件_config.yml中的部署配置[_config.yml]123456deploy: type: git repo: github: https://github.com/ZlwPick/ZlwPick.github.io.git coding: https://e.coding.net/zlwblog/zlw.git branch: master重新执行Hexo部署命令，此时就会将Hexo博客部署到GitHub和Coding上了hexo d部署结束之后，Coding项目master分支下面就会有代码了左侧菜单 ---&gt; 部署 ---&gt; 静态网址 ---&gt; 把代码库里面的项目部署一下配置域名分流解析dns修改之后需要一点时间刷新,之后在静态网页设置里面申请SSL证书(一定先把DNS中GitHub的解析关了,要不然申请失败),在下方打开https自动最小化静态文件Chrome 开发者工具中提供的 Network 选项卡可以很方便的检测整个网站的文件传输情况。通过输入 domain:kaitohh.com 筛选仅来自于源站的文件，可以看到所有来自于源站的文件及大小。可以发现绝大部分文件都是一些网站本身的 CSS 和 JS，最大的文件是当前网站的 HTML 代码，这些文件由于经常会发生变动，因此不能直接存在对象存储中。接下来，逐个预览这些文件，发现这些文件居然都没有最小化！安装插件 https://github.com/chenzhutian/hexo-all-minifier$ npm install hexo-all-minifier –save_config.ymlall_minifier: true","link":"/2019/10/24/Hexo-coding-github加速博客访问/"},{"title":"IDEA Debug调试","text":"Debug调试的一些技巧从左向右1.光标在其他的行或者页面,点击可以跳转到当前代码执行的行(Alt + F10)2.步过,一行一行往下走,这打断点的行上面有方法不会进入方法(F8)3.步入,如果当前行有方法,可以进入这个方法内部,一般是自定义方法,不会是函数库里面的方法(F7)4.强制步入,能进入任何方法(Alt+Shift+F7)5.步出,从步入的方法内退出到方法调用出,此时方法已执行完毕,只是没有完成赋值(Shift+F8)6.回退断点7.运行到光标处,而不需要打断点(Alt+ F9)8.计算表达式 可以直接选择某个表达式再Alt + F8 直接在窗口输出的结果,也可以自己设置参数(Alt + F8)1.重新运行程序,关闭服务后重新启动程序2.恢复程序(F9)3.暂停程序4.连续按两下,关闭程序(Ctrl+F2)5.查看所有断点6.哑的断点,选择这个后,所有的断点变成灰色,断点失效,按F9直接运行完程序。","link":"/2019/11/04/IDEA-Debug调试/"},{"title":"IDEA 后缀补全","text":"IDEA 有个很厉害的功能，那就是后缀补全（不是自动补全），这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。var 声明null判断notnull判断nn判断ifreturn","link":"/2019/10/26/IDEA-后缀补全/"},{"title":"IDEA 常用的快捷键","text":"一键格式化代碼： Ctrl+Alt+L全局搜索替换：ctrl+shift+r强大的搜索功能，shift+shift (无论您想要搜啥都能找到)ctrl+shift+R:搜索类 &emsp;&emsp; CTRL+N：按照类名搜索类[常规]Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 - 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-“，当前方法展开、折叠Ctrl+Shift+”+/-“，全部展开、折叠[调试部分、编译]Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器[重构]Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联[查找]Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法[VCS]Alt+~，VCS 操作菜单Ctrl+K，提交更改Ctrl+T，更新项目Ctrl+Alt+Shift+D，显示变化-# [平时自己用的]复制提示信息 alt+左键","link":"/2019/10/20/IDEA-常用的快捷键/"},{"title":"Java 8 - 函数编程（lambda表达式）","text":"简介超过3行的逻辑就不适用Lambda表达式了。虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖(用更简练的言语表达较复杂的含义)”,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘.)Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口.lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。基本语法(parameters) -&gt; expression或(请注意语句的花括号)(parameters) -&gt; {expression}λ表达式本质上是一个匿名方法。让我们来看下面这个例子：public int add(int x, int y) {return x + y;}转成λ表达式后是这个样子：(int x, int y) -&gt; x + y;参数类型也可以省略，Java编译器会根据上下文推断出来：(x, y) -&gt; x + y; //返回两数之和或者(x, y) -&gt; { return x + y; } //显式指明返回值可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：() -&gt; { System.out.println(“Hello Lambda!”); }如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：c -&gt; { return c.size(); }[lambda简单例子]123456// 1.不需要参数 返回值 7() -&gt; 7// 2. 接受两个int类型参数 返回值 为 两者之和(int x,int y) -&gt; x+y// 3. 接受一个string类型参数,并进行打印,没有返回值(String s) -&gt; System.out.print(s)[循环输出]12345678910111213// 随便定义的数据 String[] str = {\"zlw\",\"joe\",\"qjl\",\"lxl\",\"zc\",\"sam\"}; List&lt;String&gt; players = Arrays.asList(str); // 以前的循环方式 for (String player : players) { System.out.println(player); } System.out.println(\"--------------\"); // 使用 lambda 表达式以及函数操作(functional operation) players.forEach((player) -&gt; System.out.println(player)); System.out.println(\"--------------\"); // 在 Java 8 中使用双冒号操作符(double colon operator) players.forEach(System.out::println);[使用lambdas 来实现 Runnable接口]12345678910111213141516171819202122// 使用匿名内部类 1.1 new Thread(new Runnable() { @Override public void run() { System.out.println(\"Hello lambda1\"); } }).start();// 使用 lambda 表达式1.2 new Thread(() -&gt; System.out.println(\"Hello lambda2\")).start();// 使用匿名内部类 2.1 Runnable hello_zlw_lambda1 = new Runnable() { @Override public void run() { System.out.println(\"Hello zlw lambda1\"); } };// 使用 lambda 表达式2.2 Runnable hello_zlw_lambda2 = () -&gt; System.out.println(\"Hello zlw lambda2\"); hello_zlw_lambda1.run(); hello_zlw_lambda2.run();使用Lambdas排序集合在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。123456789101112131415// 1.1 使用匿名内部类根据 name 排序String[] players = {\"zlw\",\"joe\",\"qjl\",\"lxl\",\"zc\",\"sam\"};Arrays.sort(players, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return (o1.compareTo(o2)); }});// 使用 lambda 表达式以及函数操作(functional operation)Comparator&lt;String&gt; sortName = (String o1, String o2) -&gt; o1.compareTo(o2);Arrays.sort(players,sortName);Arrays.sort(players,(String o1,String o2) -&gt; o1.compareTo(o2));System.out.println(Arrays.toString(players));","link":"/2019/10/25/Java-8-函数编程（lambda表达式）/"},{"title":"LeetCode 1.Two Sum","text":"Two Sum题目描述:给定一个整数数组和一个目标值,找出数组中和为目标值的 两个 数你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例给定 nums = [2,7,11,15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0,1]解法一[暴力破解法]123456789public static int[] Solution(int[] nums, int target) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (target == nums[i] + nums[j]) return new int[]{i, j}; } } throw new IllegalArgumentException(\"not two sum solution\");}解法二[一遍哈希表]12345678910public static int[] Solution2(int[] nums,int target){ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt; nums.length; i++) { if(map.containsKey(target - nums[i])) { return new int[] {map.get(target-nums[i]),i}; } map.put(nums[i], i); } throw new IllegalArgumentException(\"No two sum solution\"); }","link":"/2019/10/20/LeetCode-1-Two-Sum/"},{"title":"LeetCode 13.Roman to Integer","text":"Roman to Integer罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: “III”输出: 3示例 2:输入: “IV”输出: 4示例 3:输入: “IX”输出: 9示例 4:输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.1234567891011121314151617181920public static int romanToInt(String s) { Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result = 0; for (int i = 0; i &lt; s.length(); i++) { if(i&gt;0 &amp;&amp; map.get(s.charAt(i)) &gt; map.get(s.charAt(i-1))){ result += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i-1)); }else{ result += map.get(s.charAt(i)); } } return result; }","link":"/2019/10/21/LeetCode-13-Roman-to-Integer/"},{"title":"LeetCode 20.Valid Paretheses","text":"Valid Paretheses(有效的括号)题目描述:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: “()”输出: true示例 2:输入: “()[]{}”输出: true示例 3:输入: “(]”输出: false示例 4:输入: “([)]”输出: false示例 5:输入: “{[]}”输出: true12345678910111213141516171819202122public boolean isValid(String s) { Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') { stack.push(s.charAt(i)); } else { if (stack.isEmpty()) { return false; } else { if (stack.peek() == '{' &amp;&amp; s.charAt(i) != '}') { return false; } else if (stack.peek() == '(' &amp;&amp; s.charAt(i) != ')') { return false; } else if (stack.peek() == '[' &amp;&amp; s.charAt(i) != ']') { return false; } } stack.pop(); } } return stack.isEmpty(); }","link":"/2019/10/22/LeetCode-20-Valid-Paretheses/"},{"title":"LeetCode 58.Length of Last Word","text":"Length of Last Word(最后一个单词长度)给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。示例输入: “Hello World”输出: 5解题思路直接从字符串最后开始先前找,总长度–,找到后记录那就是’ ‘之前的长度,再去用 总长度 - 去’ ‘之前的长度 = 最后一个单词的长度12345678910111213public int lengthOfLastWord(String s) { if(s==null || s.length()==0) return 0; String trim = s.trim(); //去掉字符串两边的' '空格 if(trim.length()==0){ return 0; } int n = trim.length() -1; while (n&gt;=0 &amp;&amp; trim.charAt(n)!=' ') { n--; } return trim.length() - 1 -n; }","link":"/2019/10/23/LeetCode-58-Length-of-Last-Word/"},{"title":"LeetCode 66.Plus One","text":"Plus One题目描述:给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。示例 1:输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。12345678910111213141516171819202122232425262728293031323334public int[] plusOne(int[] digits) { boolean flag = false; int len = digits.length; int[] temp = digits; // 判断最后一位是否进位 if(temp[len-1]+1==10){ temp[len-1]=0; flag = true; }else{ temp[len-1]+=1; return temp; } for (int i = len - 2; i &gt;= 0; i--) { if(flag &amp;&amp; temp[i]+1==10){ // 判断当前位是否有进位 temp[i]=0; flag = true; }else if(flag){ // 当前位没有进位加一退出 temp[i]+=1; flag = false; } } /* 例如 [9,9] 个位进位 0 十位进位 1+9=0 但退出循环了,不能在进位了,数组长度要扩位+1 */ if (flag &amp;&amp; temp[0]==0){ int[] res = new int[len+1]; res[0] =1; return res; } return temp; }","link":"/2019/10/22/LeetCode-66-Plus-One/"},{"title":"LeetCode 7.Reverse Integer","text":"Reverse Integer题目描述:给定一个32位有符号整数，将整数中的数字进行反转示例1:输入:123输入:321示例2:输入:-123输入:-321示例3:输入:120输入:21注意:假设我们的环境只能存储32位有符号整数，其数值范围是[-2^31 , 2^31 -1],如果反转后的整数溢出，返回0.1234567891011public static int Solution(int x){ int rev = 0; while (x!=0){ int pop = x % 10; // 取x的最后一位 x /= 10; // 删除X的最后一位 if(rev &gt; Integer.MAX_VALUE / 10 || rev &lt; Integer.MIN_VALUE /10) //溢出判断 return 0; rev = rev * 10 + pop; //之前的数值向前推进1位加上当前数 } return rev;}https://zlwblog.cn","link":"/2019/10/21/LeetCode-7-Reverse-Integer/"},{"title":"Linux 学习日志-1","text":"主要学了一些基础的指令,热键command [-options] parameter1 parameter2指令 选项 参数1 参数2datedate +%Y/%m/%ddate +%H:%Mcalcal [month] [year]bc--quit 退出热键[tab] 具有[命令补全] 与 [文件补齐] 的功能! ca[tab][tab]date --[tab][tab][Ctrl] + c 中断目前程序[Ctrl] + d 键盘输入结束 可以取代(exit)[Ctrl] + l 清屏[shift] + [PageUP]|[Page Down] 向前/向后翻页--help|less |more 都是可以进行翻页阅读nano text.txt观察系统的使用状态netstat -async 将数据同步写入硬盘中 (如果在内存中的没有写入硬盘,该指令就可以把内存中的数据写入硬盘)shutdown (root用户下) poweroffreboot haltsu - (身份变成root,底下输入root的密码)shutdown 如果什么参数都没有加 则系统会在1分钟之后关机-k 不是真的关机,只是发出警告！-r 系统的服务停掉之后重新启动-h 服务停掉之后关机-c 取消shutdown指令内容systemctl [指令]halt shutdown reboot poweroffpwd — 打印出当前工作目录名cd — 更改目录ls — 列出目录内容ls — 列出目录内容file — 确定文件类型less — 浏览文件内容","link":"/2019/10/30/Linux-学习日志-1/"},{"title":"Linux 学习日志-2","text":"Linux最优秀的地方之一就是在于多人多任务环境Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.1.文件拥有者我的东西,我想给谁看给谁看,我是主宰者!2.群组就是在一个群里面,我可以使用群组的资源,其他用户也可以使用。但不在群组里面的人肯定是不能使用的。3.其他人就是我有一个发小或者朋友,那么他也可以通过我来使用群组里面的资源。那么对于这个组里面的其他人,跟我这个发小并不认识,那么,发小就是他眼中的[其他人].还是就是root账户,那他就是GOD!~,可以任意访问群组,访问他想访问的任何东西!root的相关信息/etc/passwd个人的密码/etc/shadow所有的组名/etc/groupLinux的文件属性- rwx rwx —第一个字符代表这个文件的类型:[d] 目录[-] 文件[l] 连结档[b] 装置文件里面的可供储存的接口设备[c] 装置文件里面的串行端口设备,例如键盘,鼠标(一次性读取装置)[r] 可读 (权值:4)[w] 可写 (权值:2)[x] 可执行 (权值:1)这三个权限的位置不会改变,没有权限,就会出现减号[-]1.数字类型改变文件权限2.符号类型改变文件权限例如:rwx= 4+2+1 = 7rw-= 4+2+0 = 6—= 0+0+0 = 0基本上就九个权限分别是(1)user (2)group (3)others 可以用u,g,o代表这三个权限,a则代表all全部身份! [+] 加入 [-] 除去 [=]设定chmod u=rwx,go=r text.txt可以给每个角色分配一个[r]权限chmod a+w text.txt文件是否能被执行,则是籍由是否具有[x]这个权限来决定的,而不是根据扩展名。[w] 不具备删除该文件本身的权限目录里面的[x]代表用户能是否进入该目录成为工作目录。(工作目录就是目前所在的目录)假如说你的home目录下有一个你无法访问的文件,就是文件拥有者是其他人,且你也不在这个群组里面,那么你可以删除这个文件！因为你具有home目录下的rwx的完整权限当然可以删除这个对于你来说的垃圾文件。[文件拥有者的权限][加入此群组的账号的权限][非本人没有加入本群组的其他账号的权限]如果档名之前多一个[.],则代表这个文件为[隐藏档]root基本上是不受系统的权限所控制的[chgrp] 改变文件所属群组[chown] 改变文件拥有者[chmod] 改变文件的权限,SUI,SGID,SBITcp 来源文件 目标文件为什么在操作目录时候需要[r][x], 单纯操作目录[x]就足够了,但没有r的权限,那就无法知道里面的文件夹放在哪个地方,使用[tab],他就无法自动帮你补齐档名了。Linux文件种类与扩展名任何装置在Linux底下都是文件[-]1.纯文本档(ASCII)2.二进制文件(binary)3.数据格式文件(data)[d](directory)[l](link)类似window快捷方式设备与装置文件(device)[b] 就是一些储存数据,以提供系统随机存取的接口设备。(硬盘与软盘)[c]一些串行端口的接口设备(鼠标与键盘,一次性读取,不能够截断输出)资料接口文件(sockets)[s] 数据接口文件数据输送文件(FIFO,PIPE)[p] 特殊的文件类型,主要的目的在解决多个程序同时存取一个文件造成的错误问题常用的扩展名:*.sh脚本或批处理文件,因为批处理文件是shell写的*.Z *.tar *.tar.gz *.zip *.tgz打包的压缩文件*.html *.php网页相关文件Linux文件名的限制* ? &gt; &lt; ; &amp;[./] 本目录","link":"/2019/10/30/Linux-学习日志-2/"},{"title":"Linux 学习日志-3","text":"Linux目录管理绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)相对路径:[不是由/写起]. (代表此层目录 ).. (代表上一层目录 )- (代表签一个工作目录 )~ (代表[当前用户身份]所在的家目录 )~zlw (代表zlw这个用户的家目录 )常用的处理目录指令cd 变换目录pwd 显示当前目录mkdir 建立一个新的目录[-m]创建目录的时候直接设定权限[-p]直接将要创建所需要的目录递归建立起来! example:mkdir -p text1/text2/text3ls -ld test*rmdir 删除一个空的目录[-p] 连同[上层][空的]目录一起删除被删除的目录里面必定不能存在其他的目录或者文件!为什么我可以在任何地方执行/bin/ls 这个指令?是因为环境变量$PATH 指定了/bin/ls,若把ls文件移入到/root下,则无法使用ls指令,可以PATH=”${PATH}:/root” 加入到执行文件搜寻路径PATH中文件与目录是检视: ls[-a] 显示全部文件,包括隐藏档,包括(.)(..)[-A] 显示全部文件,包括隐藏档,不包括(.)(..)[-d] 仅列出目录本身,不是目录下的文件数据(查询目录需要加)[-r] 直接列出结果,不排序(ls会以档名排序)[-h] 文件容量以人类易读的方式(GB KB)列出来[-i] 列出inode 号码，[-F] 根据文件,目录等信息,给予附加数据结构[-l] 长数据串行出[-S] 以文件容量大小排序[-r] 反序输出[-t] 以时间排序[-R] 连同子目录一起列出来,等于输出显示所有文件[-n] 列出UID跟GID,(而不是使用者跟群组)–color=never 不根据文件特性给予颜色显示–color=always 显示颜色–color=auto 系统自动判断–full–time 以完整的时间模式(年月日时分)输出复制 cpcp [-adfilprsu] 来源文件(source) 目标文件(destination)cp [options] source1 source2 source3… directory[-a] 相当于-dr –preserve=all的意思[-d] 若来源文件为链接文件的属性(link file),则复制链接文件属性而非文件本身[-f] 强制(force),若目标文件已经存在且无法开启,则移除后再尝试一次[-i] 目标文件存在,覆盖之前询问[-l] 进行硬链接(hard link)的连档建立,而非复制文件本身[-p] 连同文件的属性(权限,用户,时间)一起复制,而非使用默认属性[-r] 递归持续复制,用于目录的复制行为[-s] 复制成为符号链接文件(symbolic link),亦即[快捷方式]文件[-u] destination 比 source 旧才跟新 destination,或者destination 不存在的情况下才复制移除 rmrm [-fir] 文件或目录[-f] 强制删除,忽略不存在的文件,不会出现警告[-i] 询问[-r] 递归删除! rm -r /tmp/etc如果身份是root ,预计加入 -i 的选项,需要一直按y才会删除可以按[Ctrl] + c 结束这是一种保护动作,如果不需要\\rm -r /tmp/etc删除档名第一个字符有[-] -aaa- 因为’-‘是选项,系统会误判rm ./-aaa-移动 mvmv [-fiu] source destinationmv [options] source1 source2 source3 … directory[-f] 强制,如果存在的文件,不会询问直接覆盖[-i] 询问[-u] 若目标文件存在,且source比较新,才会更新(update)更改名字mv mytest mytest1取得最后的档名basename取得目录名dirname文件内容查阅cat 由第一行开始显示文件内容tac 从最后一行开始显示, tac就是cat倒着写的！nl 显示行号more 一页一页显示文件内容less 比moreg好,可以向前翻页head 只看前几行 -n (默认10行)tail 只看后几行 -n (默认10行)od 二进制的方式读取文件内容cat [-AbEnTv][-A] 相当于-vET的整合[-b] 列出行号,仅对非空白行,空白行不标行号[-E] 结尾断行字符$显示出来[-n] 打印出行号,空白行也打印[-T] 将[tab]按键以 ^[显示出来[-v] 列出一些看不到的特殊字符more空格 代表向下翻一页Enter 代表向下翻一行/字符串 [字符串]搜索:f 立即显示出文件名和行数q 退出b 或者[Ctrl] + b 往回翻页less/字符串 向下搜索?字符串 向上搜索q 退出g 第一行G 最后一行修改文件时间或者建置新档 touch三个主要的变动时间modification time当该文件的[内容数据]变更时,就会更新这个时间status time当该文件的[状态]变更时,就会更新这个时间(权限或者属性)access time当[该文件的内容被取用]时,就会更新这个时间(cat 去读取时)ls显示出来的是该文件的mtime,也就是这个文件上一次的内容被改动的时间。如果touch的文件不存在,那么会创建一个新的空文件.如果存在那么文件的三个时间(atime,ctime,mtime)都会更新为目前的时间ll===&gt; ls -l(别名)[;] 代表连续指令的下达! date ; ll bashrc ; ll –time=atime bashrc; ll –time=ctime bashrc;touch [-acdmt] 文件[-a] 仅修改atime[-c] 仅修改文件时间,文件不存在不新建[-d] 后面可以接修改的日期而不是目前的日期,也可以使用 –date=”日期或者时间”[-m] 仅修改mtime[-t] 后面可以接修改的时间而不用目前的时间,格式为[YYYYMMDDhhmm]复制一个文件时,复制所有的属性,但没办法复制ctime.","link":"/2019/11/01/Linux-学习日志-3/"},{"title":"Linux 学习日志-4","text":"Linux文件与目录的默认权限与隐藏权限目前用户在建立文件或目录时候的权限默认值umask数字的方式显示0022 第一组是特殊权限umask -S字符的方式显示该默认值是需要减掉的权限0022建立的文件默认权限是644(6-0,6-2,6-2)建立的目录的默认 权限是755(7-0,7-2,7-2)设置umask 002 就可以改变当前的默认值rwxr-xr-x文件的隐藏属性暂时不看Set UID查看文件类型file 文件名脚本文件名搜索which [-a] commanda 就是all PATH中可以找到的所有指令列出来文件的档名的搜寻whereis [-bmsu] 文件或者文件名[-l] 可以列出 whereis 会去查询的几个主要目录而已[-b] 只找binary格式的文件[-m] 只找说明文件 manual[-s] 只找source来源的文件[-u] 搜索不在上述三个项目当中的其他特殊文件find指令 花费的时间很大(因为它是直接搜寻硬盘)whereis指令 只找几个特定的目录而已,并没有全系统的去查询(主要是针对/bin/sbin底下的执行档)locate指令 寻找的数据是在(已建立的数据库 /var/lib/mlocate/)locate [-ir] keyword(文件的部分名称)[-i] 忽略大小写[-c] 不输出档名,仅计算找到的文件数目[-l] 输出几行的意思 -l 5[-S] 输出locate 使用的数据库文件的相关信息[-r] 正规可接正规表示法显示方式因为locate是经数据库来搜寻的,而数据库的建立默认是在每天执行一次,那么你新建的文件使用这个指令可能找不到,所以必须跟新数据库使用updatedb来更新find [PATH] [option] [option]有 -atime, -ctime , -mtime-mtimen n为数字,意义在n天之前的[一天之内]被更动过内容的文件+n n天之前被更动过内容的文件档名(不包括n天本身)-n n天之内被更改内容的文件档名-newer file file为一个存在的文件,列出比file 还要新的文件档名find / -mtime 0find Desktop -newer /与使用者或者组名有关的参数-uid n n为数字,这个数字是用户的账号的UID-gid n n为数字,这个数字是组名的GID-user name name为使用者的名字-group name name为组名-nouser 寻找文件拥有者不存在的与 /etc/passwd 的人-nogroup 寻找文件的拥有群组不存在 /etc/group 的文件与文件的权限及名称有关的参数-name filename 搜索文件名为filename的文件-size [+-]SIZE 搜寻比SIZE 还要大(+)或(-)的文件. c: byte k:1024bytes 要找20KB还要大的文件-size +50k-type TYPE 搜寻文件的类型为TYPE的,(一般正规文件f,装置文件b、c,d,l,s,p)-perm mode 搜寻文件权限刚好等于 mode的文件-perm -mode 搜寻文件权限[必须全部包括mode的权限]的文件-perm /mode 搜寻文件权限[包括任一mode的权限]的文件额外可进行的动作-exec command exec后面可以接其他的指令-print 打印输出显示find / size +1M -exec ls -l {} ;-exec 后面的指令不支持命令别名{} 代表的是[由find找到的内容],find的结果会被放置到{}位置中;是关键词,表示find 额外的动作开始(-exec)到结束(;),在中间的就是find指令内的额外的动作[;] 在bash环境下有特殊的意义,因此利用反斜杠来跳脱一. 让某用户进入某目录成为[可工作目录]的基本权限用户至少有对这个目录需要具有 x 权限二.让某用户在某个目录内读取一个文件的基本权限用户至少对这个目录具有x权限对文件具有r权限三.让一个用户可以修改文件的权限用户至少对这个目录具有x权限对文件具有r w 权限","link":"/2019/11/03/Linux-学习日志-4/"},{"title":"Markdown操作","text":"Markdownd是一种轻量级的标记语言Markdownd编写的文档后缀为.md,.markdownHello World!标题我是一级标题我是二级标题一级标题二级标题三级标题四级标题[格式]123456============------------######1-6个# 表示1-6级标题段落格式1.末尾添加两个空格2.使用空行来换行字体[字体格式]123456*斜体字体*_斜体字体_**粗体字体**__粗体字体__***粗斜体字体***___粗斜体字体___斜体字体斜体字体粗体字体粗体字体粗斜体字体粗斜体字体分割线[分割线格式]12345**** * ******- - ----------删除线和下划线和脚注zlwblogzlwBLOGzlwblog1这是一个脚注^123这是一个脚注列表123123第一项1.11.2第二项2.12.2结束区块zzzzzzllllllwwwwwwwz12311.11.22代码printf()函数test(){12 111;}支持HTML元素https://github/ZlwPickCtrl+Alt+Del重启电脑转义 *","link":"/2019/10/19/Markdown操作/"},{"title":"Linux 学习日志-5","text":"Linux 磁盘与文件系统管理磁盘的组成圆形的磁盘盘(主要记录数据的部分)机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)主轴马达,可以转动磁盘盘磁盘盘的组成扇区(Sector)为最小的物理储存单位,目前主要有 512bytes 与4K 两张格式.将扇区组成一个圆,那就是磁柱;早期的分区主要是以磁柱为最小分区单位,现在的分区通常使用扇区为最小分区单位(每一个扇区都有号码)磁盘的分区表主要有两种格式,一个是限制较多的MBR分区表,一种是较新且限制较少的GPT分区表MBR分区表中,第一个扇区最重要,里面有:(1)主要开机区(Master boot record)及分区表(partition table) MBR 占有446bytes 而 partition table 占有 64bytesGPT分区表除了分区数量扩展开了所有的磁盘文件名已经被模拟成/dev/sd[a-p][1-128]/dev/vd[a-d][1-128]文件系统特性superblock: 记录filesystem 的整体信息,包括inode/block的总量、使用量、剩余量,及文件系统的格式和相关信息等","link":"/2019/11/13/Linux-学习日志-5/"},{"title":"SQL 语言 - 基础","text":"基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。[注释]1234## 注释SELECT * FROM mytable -- 注释/*注释1 注释2 */[数据库的创建与使用]12CREATE DATABASE zlwdb;USE zlwdb;[创建表与修改表]1234567891011121314CREATE TABLE mytable( uid INT NOT NULL AUTO_INCREMENT, z1 INT NOT NULL DEFAULT 1, z2 INT VARCHAR(45) NULL, z3 DATE NULL, PRIMARY KEY('id') );}##修改表ALTER TABLE mytableADD z4 CHAR(20);ALTER TABLE mytableDROP COLUMN z4;##删除表DROP TABLE mytable;[插入,更新,删除]1234567891011INSERT INTO mytable(z1,z2) VALUES(va11,val2);## 插入检索出来的数据INSERT INTO mytable1(z1,z2) SELECT z1,z2 FROM mytable2;## 一个表的内容插入到一个新表CREATE TABLE newtable AS SELECT * FROM mytable;UPDATE mytable SET z1 = va11 WHERE uid = 1;DELETE FROM mytable WHERE uid = 1;TRUNCATE TABLE mytable; --也可以清空表，也就是删除所有行[查询]1234567##DISTINCT --去重复，相同的值只会显示一次SELECT DISTINCT z1,z2, FROM mytable;##LIMIT -- 限制返回的行数,可以有两个参数,1.起始行2. 返回的总行数SELECT * FROM mytable LIMIT 5;SELECT * FROM mytable LIMIT 0,5;SELECT * FROM mytable LIMIT 2,3; -- 从第3行到第第5行[排序]12## ASC 升序(默认) DESC 降序SELECT * FROM mytable ORDER BY z1 DESC, z2 ASC;[过滤]1SELECT * FROM mytable WHERE z1 IS NULL;操作符说明=等于单元格单元格&lt; &gt;小于 大于&lt;&gt;!= &lt;=!&gt; &gt;=!&lt;不等于 小于等于 大于等于BETWEEN在两个值之间IS NULL为NULL值AND 和OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。NOT 操作符用于否定一个条件。通配符通配符也是用在过滤语句中，但它只能用于文本字段。% 匹配 &gt;=0 个任意字符；_ 匹配 ==1 个任意字符；[ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。使用 Like 来进行通配符匹配。不要滥用通配符，通配符位于开头处匹配会非常慢。[]1SELECT * FROM mytable WHERE z1 LIKE '[^AB]' --不以 A 和 B 开头的文本[计算字段]12345SELECT z1 * z2 AS xj FROM mytable;##CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，##因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。SELECT CONCAT(TRIM(z1), '(', TRIM(z2), ')') AS concat_zFROM mytable;函数(MYSQL)函数说明(列)AVG()平均值COUNT()行数MAX() MIN()最大值 最小值SUM()和LEFT() RIGHT()左边的字符 右边的字符LOWER() UPPER()转为小写字符 转为大写字符LTRIM() RTRIM()去除左边的空格 去除右边的空格分组分组就是把具有相同的数据值的行放在同一组中。可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。[分组]1234SELECT z1,COUNT(*) AS SUM FROM mytable GROUP BY z1;##GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。##WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。SELECT z1,COUNT(*) AS num FROM mytable WHERE z1 &gt; 2 GROUP BY z1 HAVING num &gt;= 2;分组规定：GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；NULL 的行会单独分为一组；大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型未写完[]1","link":"/2019/10/23/SQL-语言-基础/"},{"title":"Hello World","text":"","link":"/2019/06/23/hello-world/"},{"title":"java-8 Optional类解析","text":"简介用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。of为非null的值创建一个Optional。1234//调用工厂方法创建Optional实例Optional&lt;String&gt; s = Optional.of(\"zlw\");//传入参数为null，抛出NullPointerException.Optional&lt;String&gt; s1 = Optional.of(null);ofNullable为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。1234//ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况//下面创建了一个不包含任何值的Optional实例//例如，值为'null'Optional&lt;String&gt; empty = Optional.ofNullable(null);isPresent如果值存在返回true，否则返回false。123456//isPresent方法用来检查Optional实例中是否包含值Optional&lt;String&gt; empty = Optional.ofNullable(\"ZLW\"); String name = \"zlw\"; if(empty.isPresent()){ System.out.println(empty.get()); }get如果Optional有值则将其返回，否则抛出NoSuchElementException。12345try { System.out.println(empty.get()); } catch (NoSuchElementException ex) { System.out.println(ex.getMessage()); }ifPresent如果Optional实例有值则为其调用consumer，否则不做处理要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。123//ifPresent方法接受lambda表达式作为参数。//lambda表达式对Optional的值调用consumer进行处理。empty.ifPresent(System.out::println);orElse如果有值则将其返回，否则返回指定的其它值。1234// 值为 nullSystem.out.println(empty.orElse(\"no value\"));// 值为 zlwSystem.out.println(empty.orElse(\"no value\"));orElseGetorElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值123//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，//orElseGet可以接受一个lambda表达式生成默认值。System.out.println(empty.orElseGet(() -&gt; \"no value!\"));orElseThrow如果有值则将其返回，否则抛出supplier接口创建的异常。在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常123456789try { //orElseThrow与orElse方法类似。与返回默认值不同， //orElseThrow会抛出lambda表达式或方法生成的异常 empty.orElseThrow(ValueAbsentException::new);} catch (Throwable ex) { //输出: No value present in the Optional instance System.out.println(ex.getMessage());}ValueAbsentException定义如下：123456789101112131415class ValueAbsentException extends Throwable { public ValueAbsentException() { super(); } public ValueAbsentException(String msg) { super(msg); } @Override public String getMessage() { return \"No value present in the Optional instance\"; }}map如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。12345//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\");Optional&lt;String&gt; newempty = empty.map((value) -&gt; value.toUpperCase());System.out.println(newempty.orElseGet(() -&gt; \"no value!!\"));flatMap如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。12345//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 //但flatMap方法中的lambda表达式返回值必须是Optionl实例。 Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\"); System.out.println(empty.flatMap((value) -&gt; Optional.of(value.toUpperCase())).orElseGet(() -&gt; \"no value!!\"));filter如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。12345//filter方法检查给定的Option值是否满足某些条件。//如果满足则返回同一个Option实例，否则返回空Optional。Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\");Optional&lt;String&gt; s = empty.filter((value) -&gt; value.length() &gt; 5);System.out.println(s.orElse(\"The name is less than 6 characters\"));","link":"/2019/10/28/java-8-Optional类解析/"},{"title":"java-8 lambda 2","text":"关于函数式接口:1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。1234567@FunctionalInterfacepublic interface MyInterfae { void test(); // java.lang.Object 是所以类的父类 MyInterfae的实现类一点会直接或者间接的继承Object类 toString String toString();}在其他有lambda表达式语言中,lambda表达式的类型是函数,但在java中，Lambda表达式是对象,他们必须依附于一类特别的对象类型————函数式接口(functional interface)外部迭代最传统的方法是用Iterator，当然还以用for i、增强for循环等等。这一类方法叫做外部迭代，意为显式地进行迭代操作，即集合中的元素访问是由一个处于集合外部的东西来控制的，在这里控制着循环的东西就是迭代器。1234List&lt;String&gt; alphabets = Arrays.asList(new String[] { \"a\", \"b\", \"b\", \"d\" });for (String letter : alphabets) { System.out.println(letter.toUpperCase());}内部迭代顾名思义，这种方式的遍历将在集合内部进行，我们不会显式地去控制这个循环。无需关心遍历元素的顺序，我们只需要定义对其中每一个元素进行什么样的操作。注意在这种设定下可能无法直接获取到当前元素的下标。比如JDK8提供的最新的Collection.forEach(…)方法。1alphabets.forEach(System.out::println);Function接口1234567891011121314151617181920212223242526272829303132333435/** * 代表这一个方法，能够接受一个参数，并且返回一个结果 * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; { /** * 将参数赋予给相应方法 * * @param t * @return */ R apply(T t); /** * 先执行参数(即也是一个Function)的，再执行调用者(同样是一个Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } /** * 先执行调用者，再执行参数，和compose相反。 */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } /** * 返回当前正在执行的方法 */ static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }}[例子]123456789101112131415161718192021public class TextIDEA { public static void main(String[] args) { TextIDEA TextIDEA = new TextIDEA(); System.out.println(TextIDEA.compute(2,(value) -&gt; value * 3,(value) -&gt; value * value)); // 12 System.out.println(TextIDEA.compute1(2,(value) -&gt; value * 3,(value) -&gt; value * value));// 36 System.out.println(TextIDEA.compute2(2,3,(value1,value2) -&gt; value1 * value2)); // 6 } public int compute(int a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2){ return function1.compose(function2).apply(a); } public int compute1(int a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2){ return function1.andThen(function2).apply(a); } public int compute2(int a,int b, BiFunction&lt;Integer,Integer,Integer&gt; biFunction){ return biFunction.apply(a,b); } }Predicate123456789101112131415161718192021222324252627282930@FunctionalInterfacepublic interface Predicate&lt;T&gt; { //唯一的抽象方法 boolean test(T t); //且操作，既满足A也满足B条件 default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } //且操作，既满足A也满足B条件 default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } //或操作，满足A条件或者满足B条件 default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } //静态方法，判定是否相等 static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); }}Predicate123456789@FunctionalInterfacepublic interface Supplier&lt;T&gt; { /** *这个接口是一个提供者的意思，只有一个get的抽象类， *没有默认的方法以及静态的方法，传入一个泛型T的，get方法，返回一个泛型T */ T get();}BinaryOperatorBinaryOperator:对同一类型的两个参数的操作比较操作,返回的和传入参数时相同的 ;binaryOperator 继承制BiFunciton方法1: minBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最小的对象方法1: maxBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最大的对象","link":"/2019/10/26/java-8-lambda-2/"},{"title":"java-8 stream","text":"本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.流是java8中一个新的概念,它允许你以声明性方法处理数据集合,类似于SQL语句,可以透明地并行处理.并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！流的带来的好处有以下:1.声明性——更简洁,更易读2.可复合——更灵活3.可并行——性能更好流中的几个概念:1.元素序列—— 集合讲的是数据,流讲的是计算.2.源—— 流会使用一个提供数据的源.3.数据处理操作—— 流的数据处理功能支持类似于数据库的操作,以及函数式编程中常用的操作,可以是顺序或者并行执行.流操作两个重要的特点:1.流水线——很多流操作本身会返回一个流,这样多个操作就可以链接起来,形成一个大的流水线.(ps:类似于sql的查找)2.内部迭代——于使用迭代器显示迭代的集合不同,流的迭代操作是在背后进行的.3.流只能遍历一次,遍历完就已经被消费掉了,可以从原始数据源重新获得一个新的流.反正会报错.外部迭代是用户使用Collection接口自己去做迭代.内部迭代是它自动帮你把迭代做了,还把得到的流值存在某个地方,你只需要给出一个函数说要干什么就完事了,是不是很轻松.而且内部迭代是透明地并行处理,或者用更优化的顺序(某些合适你硬件的数据表示)进行处理.流的操作中间操作——会返回另一个流,这样可以多个操作连接起来,更重要的是,除非流水线上触发一个终端操作,否则中间操作不会执行任何处理——他们很懒(惰性求值).这是因为中间操作一般是可以合并起来,在终端操作时一次性全部处理.终端操作——从流的流水线生成结果,其结果是任何不是流的值.(List,Integer,甚至是void)使用流1.一个数据源(如集合)来执行一个查询.2.一个中间操作链,形成一条流的流水线.3.一个终端操作,执行流水线,并能生成结果.筛选和切片用谓词筛选,筛选出各不相同的元素filter()—-&gt;该操作会接受一个谓词(一个返回boolean的函数)作为参数,并返回一个包含所有符合谓词的元素的流.distinct()—-&gt;它会返回一个元素各异(根据流所生成元素的hashCode和equals方法实现)的流.limit()—-&gt;该方法会返回一个不超过给定长度的流.skip(n)—-&gt;返回一个扔掉前n个元素的流,如果流中元素不足n个,则返回一个空流.映射map()—-&gt;它会接受一个函数作为参数,这个函数会被应用到每个元素上,并将其映射成一个新的元素.flatMap()—-&gt;各个数组并不是分别映射成一个流,而是映射成流的内容.也就是生成的单个流被合并起来,即扁平化为一个流.查找和匹配anyMatch()—-&gt;检查谓词是否至少匹配一个元素,返回一个boolean,是一个终端操作.allMatch()—-&gt;检查谓词是否匹配所有元素.noneMacth()—-&gt;确保流中没有任何元素与给定的谓词匹配.以上三个操作都具有短路的特性.(当搜索的条件满足时,就不会继续下去了)findAny()—-&gt;返回当前流中的任意元素.findFirst()—-&gt;返回当前流中的第一个元素.归约将流中所以元素反复结合起来,得到一个值.这样的查询可以被归类为归约操作.(函数编程的术语为折叠)reduce(0,(a,b) -&gt; a + b);或者直接Integer里面的静态sum方法求和reduce(0,Integer::sum);或者求最大值、最小值reduce(0,Integer::min);reduce(0,Integer::max);练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static void main(String[] args) { Trader zlw1 = new Trader(\"zlw1\", \"hb\"); Trader zlw2 = new Trader(\"zlw2\", \"sz\"); Trader zlw3 = new Trader(\"zlw3\", \"hb\"); Trader zlw4 = new Trader(\"zlw4\", \"hb\"); List&lt;Transactions&gt; transactions1 = Arrays.asList( new Transactions(zlw4, 2011, 300), new Transactions(zlw1, 2012, 1000), new Transactions(zlw1, 2011, 400), new Transactions(zlw2, 2012, 710), new Transactions(zlw2, 2012, 700), new Transactions(zlw3, 2012, 950) ); //找出2011年发生的交易,并按交易排序(低到高) transactions1.stream() .filter(tran -&gt; tran.getYear() == 2011) .sorted(Comparator.comparing(Transactions::getValue)) .forEach(System.out::println); System.out.println(\"-------------------\"); //交易员在那些不同的城市工作 transactions1.stream() .map(transactions2 -&gt; transactions2.getTrader().getCity()).distinct() .forEach(System.out::println); System.out.println(\"-------------------\"); //返回所有湖北的交易员,并按姓名排序 transactions1.stream() .map(Transactions::getTrader) .filter(Trader -&gt; Trader.getCity().equals(\"hb\")) .distinct().sorted(Comparator.comparing(Trader::getName)) .forEach(System.out::println); System.out.println(\"-------------------\"); //返回所以交易员的姓名字符串,按字母排序 此方法的效率不高 其reduce()中使用String拼接 String reduce = transactions1.stream() .map(Transactions -&gt; Transactions.getTrader().getName()).distinct() .reduce(\"\", (a, b) -&gt; a + b); System.out.println(reduce); System.out.println(\"-------------------\"); //有没有在sz工作过的 boolean sz = transactions1.stream() .anyMatch(Transactions -&gt; Transactions.getTrader().getCity().equals(\"sz1\")); System.out.println(sz); System.out.println(\"-------------------\"); //打印所以在湖北的交易员的交易额 transactions1 .stream() .filter(transactions -&gt; transactions.getTrader().getCity().equals(\"hb\")) .map(Transactions::getValue) .forEach(System.out::println); System.out.println(\"-------------------\"); //输出交易中,交易额最高的交易额 Integer max = transactions1.stream() .map(Transactions::getValue) .reduce(Integer::max) .get(); System.out.println(max); System.out.println(\"-------------------\"); //最小的交易额 Integer min = transactions1.stream() .map(Transactions::getValue) .reduce(Integer::min) .get(); System.out.println(min); }","link":"/2019/12/06/java-8-stream/"},{"title":"java-8 方法引用","text":"方法引用: method reference方法引用实际上是个Lambda表达式的一种语法糖我们可以将方法引用看作是一个[函数指针]*方法引用classname::staticmethod*方法调用classname.staticmethod方法引用共分为4类类名::静态方法名引用名(对象名)::实例方法名类名::实例方法名(lambda表达式的第一个参数作为这个方法的调用者,之后的参数作为这个方法的参数)构造方法引用 类名::new默认方法什么是默认方法简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。为什么出现默认方法为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。java 8抽象类与接口对比相同点不同点都是抽象类型抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）都可以有实现方法（以前接口不行）抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。多重继承的冲突由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：1.一个声明在类里面的方法优先于任何默认方法（classes always win）2.否则，则会优先选取路径最短的。12345678910public interface MyInterface { default void myMethod(){ System.out.println(\"myMethod1!!\"); }}public interface MyInterface1 { default void myMethod(){ System.out.println(\"myMethod2!!\"); }}报错 defaultTest inherits unrelated defaults for myMethod() from types MyInterface and MyInterface1如果一定要这么写呢，同时实现MyInterface,MyInterface1并且使用MyInterface1中myMethod()？可以这么写：12345678910public class defaultTest implements MyInterface,MyInterface1{ public static void main(String[] args) { defaultTest defaultTest = new defaultTest(); defaultTest.myMethod(); } @Override public void myMethod() { MyInterface1.super.myMethod(); }}或者可以这么写:12345678910111213141516public interface MyInterface2 extends MyInterface,MyInterface1 { default void myMethod(){ System.out.println(\"myMethod3!!\"); }}public class defaultTest implements MyInterface2{ public static void main(String[] args) { defaultTest defaultTest = new defaultTest(); defaultTest.myMethod(); } @Override public void myMethod() { MyInterface2.super.myMethod(); }}输出 myMethod3!! 可见MyInterface2.super表示的是MyInterface2接口，同时defaultTest无法访问MyInterface,MyInterface2的myMethod()可见MyInterface2虽然有同一个两个最短路径的myMethod(), 但是它自己有一个更高优先级的myMethod()，所以不会报错;默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。","link":"/2019/10/28/java-8-方法引用/"},{"title":"zzz","text":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.[title] [] [url] [link text]1code snippet","link":"/2019/06/24/周李伟的第一篇文章/"},{"title":"平时看的好文章","text":"技术人员的发展之路 –陈皓https://coolshell.cn/articles/17583.html计算机专业学历重不重要https://zhuanlan.zhihu.com/p/84350029","link":"/2019/10/24/平时看的好文章/"},{"title":"数据结构 基本概念","text":"这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。1.数据能输入到计算机且能被计算机程序处理的符号总称.(整数,字符串等)2.数据元素是数据的基本单位,一个数据元素可能由若干个数据项组成.3.数据项是数据结构中最小的单位,是数据记录中最基本的、不可分割的数据单位.4.数据对象相同的数据元素的集合,是数据的一个子集.5.数据结构相互之间存在一种或者多种特定关系的数据元素的集合,包括一下三方面:逻辑结构、存储结构、对数据的运算.6.数据的逻辑结构是数据之间关系的描述,与数据的存储结构无关.①.线性结构是一个数据元素的有序集合,元素之间存在着”一对一“的线性关系的数据结构，除了头尾元素,其他元素有且只有一个”前驱”和一个”后继”.②.非线性结构与线性结构不同的是,元素之间存在”一对多”的关系.7.数据的物理结构是数据的逻辑结构在计算机中的表示(映像–&gt;顺序映像和非顺序映像),包括数据的表示和关系的表示.①.顺序存储方法把逻辑上相邻的结点存储在物理位置上相邻的存储单元上.(数组)②.链式存储方法不要求逻辑上相邻的结点在物理位置上也相邻,结点的逻辑关系是由附加的指针字段来表示的.(链表)③.索引存储方法在存储结点信息时除建立存储结点信息外,还建立附加的索引表来标识结点的地址.索引项的一般形式是&lt;关键字,地址&gt;④.散列存储方法根据结点的关键字通过散列函数直接计算出该结点的存储地址.算法的基本概念1.算法的特性(1)有穷性(2)确定性(3)输入(4)输出(5)可行性2.算法的设计目标(1)正确性(1)可读性(1)健壮性(1)高效率与低存储量需求","link":"/2019/12/04/数据结构-基本概念/"},{"title":"数据结构 线性表","text":"线性表的知识是之后的基础,一定要完全掌握.线性表的定义线性表是具有相同特性数据元素的一个有序序列,长度为n.线性表的存储结构(1)顺序存储结构(顺序表)随机访问特性占用连续的存储空间顺序表插入操作的时候要移动多个元素(2)链式存储结构(链表)不支持随机访问结点的存储空间利用率较顺序表稍低一些动态分配进行插入操作无须移动元素链表有以下5种:(1)单链表①.带头结点的头指针head指向头结点,头结点的值域不含任何信息,从头结点的后继结点开始存储数据信息,头结点始终不等于NULL,head-&gt;next==NULL的时候,链表为空.②.不带头结点的头指针head直接指向开始结点,head==NULL时,链表为空.(2)双链表除了前后结点,每个结点有两指针域分别指向前后两结点(3)循环单链表就是尾节点不是指向NULL,而是指向头结点,没有带头结点就指向第一个节点,头尾相邻形成一个环.(4)循环双链表前后结点形成环即可.(5)静态链表借助一维数组.","link":"/2019/12/04/数据结构-线性表/"},{"title":"数据结构总体的思维导图","text":"自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.","link":"/2019/11/30/数据结构总体的思维导图/"},{"title":"练习hexo的发布","text":"[title] [] [url] [link text]1234567---title: #文章标题date: #时间，一般不用改categories: #目录分类tags: #标签，格式可以是[Hexo,总结]，中间用英文逗号分开keywords: #文章关键词，多个关键词用英文逗号隔开---1alert(&apos;Hello World!&apos;);Array.map1array.map(callback[, thisArg])插入图片的方法绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。12source/images/image.jpg![](/images/image.jpg)图片既可以在首页内容中访问到，也可以在文章正文中访问到。相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。_config.yml1post_asset_folder: true将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。12_posts/post_name/image.jpg![](image.jpg)上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。12_posts/post_name/image.jpgTime.javaview raw12345678910111213141516171819202122/** * @author zlw * @create 2019-09-11 22:53 */public class Time { public static void main(String[] args) { long startTime = System.currentTimeMillis(); doSomeThing(); long endTime = System.currentTimeMillis(); System.out.println(\"====================\"); System.out.println( (endTime - startTime)+\"ms\"); } public static void doSomeThing(){ for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { System.out.println(i * j); } } }}","link":"/2019/10/18/练习hexo的发布/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"java 8","slug":"java-8","link":"/tags/java-8/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"写作","slug":"写作","link":"/tags/写作/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"SQL语言","slug":"SQL语言","link":"/tags/SQL语言/"},{"name":"好文章","slug":"好文章","link":"/tags/好文章/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"练习","slug":"练习","link":"/tags/练习/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"数据库基础和原理","slug":"数据库基础和原理","link":"/categories/数据库基础和原理/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}