{"pages":[],"posts":[{"title":"2019年自我总结","text":"&nbsp;自我总结&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 2019年对于我来说是具有成长性的一年,这一年里面我收获许多,也绝望很多,但还是坚持下来了,而且对自己未来的道路十分的迷茫,我分别对这一年的时间内进行概述:&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;1月的时候我还在深圳找工作,在各个平台上投了加起来将近7000多份简历,只收到了仅有的7次面试.我现在都还记得那种绝望,整个房间都空了,朋友们都去面试了,只有自己一个人坐在凳子上,投简历、准备面试题、准备自我介绍。在7次的面试中有4家是培训机构的子公司(达内),面试你这种刚出来的小白,就是一顿打击,然后让你他们的公司培训一下.还有一次是一个居民楼里面的公司自己感觉还行,但回来之前就没有信息了,还有一次我坐地铁2个小时,然后又走了半个小时,然后是一个骗子公司,啥技术都没问,就给你开8000,还说我们这最低8000.我傻了都,还有一次运维的工作要去外地现在维护就没去开的5000,最后一次是我工作的公司深圳市筷云有限公司,跟软通动力一个写字楼,实习5000,转正8000,考察期1个星期,一个外包公司.我进去的第一个星期双休变单休,……,由于这个是一个外包公司,人员变动的很快,基本上公司一直在招人,我一进来就一工作了1个月的哥们被项目大佬嫌太菜给踢了,我慌的一比,但还好项目很快就熟悉了下了,也慢慢的好起来了,然后过年回来我一哥们说要专升本,我还是头一次一听说专升本,了解了一下,打算试一试,所以辞去了深圳的工作,回家复习.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 3月我开始了复习,一开始准备的是湖北师范大学,买了c语言、微机原理的资料,英语基础基本上是从音开始的(我是真的菜),然后就开开始疯狂学微机可以多拉点分,写了接近100份微机试卷,MD,招生简章出来了,说今年不考微机了,……,然后我就换了一个学校,荆楚理工.花了1个月的时间去重新学了计算机基础,到了6月考试,出的题目是真的简单(英语看不懂除外),然后就考上了,15名,之前就跟基友疯玩了2个月(现在想想就后悔浪费了这么多的时间),9月去上学.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 9月来到学校,看了课表,MD,居然有CAD,我服了,一个计算机学院的开了一门机械的课程,我不喜欢这个课,就开始学自己想学的东西,之前用hexo搭了一个静态的博客,就一直没有管了,我就重新启动了这个博客,给它注册了个域名,开始写博客了,我写的博客是自己学习过程中的一些总结,才发现写博客是多快乐的一件事情,看着自己的文章一篇一篇变多了,心里就有一种满足感,这种满足比我打游戏还舒服,之后的几个月我基本上没有打几次游戏了,中途报了个软考程序员,也过了,题很简单.又去图书馆看了一下408的那几门课程,打算如果明年4级过了就去试一试考研.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; 回看我这即将过去的2019,觉得有几分可惜、有几分自信、几分迷茫,但过去的都过去了,目前只有把握现在,才能去追求远方和我等了很久的那个女孩,在此我给我在2020定一下几个目标:1.坚持写博客,减一下肥2.liunx一定要学好3.javaWeb相关的知识学习,中间件,并发等4.看源码5.坚持背单词6.3月的篮桥,4月的四级7.LeetCode的题坚持刷&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在最后引用美国往事里面的一句话:当我对世事厌倦的时候，我就会想到你。想到你在世界的某个地方生活着、存在着，我就愿意忍受一切。你的存在对我很重要。","link":"/2019/12/28/2019年自我总结/"},{"title":"Hexo+coding+github加速博客访问","text":"之前使用Hexo+github建立后访问博客速慢,是因为github服务器在国外，可能访问量太大，国内访问速度有些慢;然后改用coding 托管代码什么是coding？简单的说coding就是类似于github的开源代码仓库，几乎是完全仿照github做的；虽然现在代码量并不多，但是部分地方还是比github方便一些的：中文界面，对我们来用起来更加方便；可以免费创建私有仓库；虽然服务器也在国外，但访问速度比github要快不少注册coding并创建项目这一部分很简单，不多说。需要注意的是创建项目的时候项目名称跟我们在github上创建时候类似，项目名一定要是：用户名 + coding.me创建Coding项目创建完成之后，先完成下一步在进行其他步骤配置SSH Key只是把其中的添加SSH key添加到GitHub的步骤换成下面的就行,添加SSH key到Coding将上面生产的id_rsa.pub中的内容添加SSH Key到Codingcoding ---&gt; 个人账户 ---&gt; SSH公钥 ---&gt; 添加公钥测试SSH Key 是否配置成功[git bash]1$ ssh -T git@github.comHexo部署添加Coding仓库修改Hexo博客目录下的站点配置文件_config.yml中的部署配置[_config.yml]123456deploy: type: git repo: github: https://github.com/ZlwPick/ZlwPick.github.io.git coding: https://e.coding.net/zlwblog/zlw.git branch: master重新执行Hexo部署命令，此时就会将Hexo博客部署到GitHub和Coding上了hexo d部署结束之后，Coding项目master分支下面就会有代码了左侧菜单 ---&gt; 部署 ---&gt; 静态网址 ---&gt; 把代码库里面的项目部署一下配置域名分流解析dns修改之后需要一点时间刷新,之后在静态网页设置里面申请SSL证书(一定先把DNS中GitHub的解析关了,要不然申请失败),在下方打开https自动最小化静态文件Chrome 开发者工具中提供的 Network 选项卡可以很方便的检测整个网站的文件传输情况。通过输入 domain:kaitohh.com 筛选仅来自于源站的文件，可以看到所有来自于源站的文件及大小。可以发现绝大部分文件都是一些网站本身的 CSS 和 JS，最大的文件是当前网站的 HTML 代码，这些文件由于经常会发生变动，因此不能直接存在对象存储中。接下来，逐个预览这些文件，发现这些文件居然都没有最小化！安装插件 https://github.com/chenzhutian/hexo-all-minifier$ npm install hexo-all-minifier –save_config.ymlall_minifier: true","link":"/2019/10/24/Hexo-coding-github加速博客访问/"},{"title":"IDEA 后缀补全","text":"IDEA 有个很厉害的功能，那就是后缀补全（不是自动补全），这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。var 声明null判断notnull判断nn判断ifreturn","link":"/2019/10/26/IDEA-后缀补全/"},{"title":"IDEA Debug调试","text":"Debug调试的一些技巧从左向右1.光标在其他的行或者页面,点击可以跳转到当前代码执行的行(Alt + F10)2.步过,一行一行往下走,这打断点的行上面有方法不会进入方法(F8)3.步入,如果当前行有方法,可以进入这个方法内部,一般是自定义方法,不会是函数库里面的方法(F7)4.强制步入,能进入任何方法(Alt+Shift+F7)5.步出,从步入的方法内退出到方法调用出,此时方法已执行完毕,只是没有完成赋值(Shift+F8)6.回退断点7.运行到光标处,而不需要打断点(Alt+ F9)8.计算表达式 可以直接选择某个表达式再Alt + F8 直接在窗口输出的结果,也可以自己设置参数(Alt + F8)1.重新运行程序,关闭服务后重新启动程序2.恢复程序(F9)3.暂停程序4.连续按两下,关闭程序(Ctrl+F2)5.查看所有断点6.哑的断点,选择这个后,所有的断点变成灰色,断点失效,按F9直接运行完程序。","link":"/2019/11/04/IDEA-Debug调试/"},{"title":"IDEA 常用的快捷键","text":"一键格式化代碼： Ctrl+Alt+L全局搜索替换：ctrl+shift+r强大的搜索功能，shift+shift (无论您想要搜啥都能找到)ctrl+shift+R:搜索类 &emsp;&emsp; CTRL+N：按照类名搜索类[常规]Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 - 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-“，当前方法展开、折叠Ctrl+Shift+”+/-“，全部展开、折叠[调试部分、编译]Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器[重构]Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联[查找]Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法[VCS]Alt+~，VCS 操作菜单Ctrl+K，提交更改Ctrl+T，更新项目Ctrl+Alt+Shift+D，显示变化-# [平时自己用的]复制提示信息 alt+左键","link":"/2019/10/20/IDEA-常用的快捷键/"},{"title":"JAVA算法中笔记","text":"最近写算法时,遇到的一些问题,及其优化都总结在此篇.输入与输出12Scanner in = new Scanner (System.in);//基本方法Scanner in = new Scanner (new BufferedInputStream(System.in));//更快123PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));//使用缓存加速，比直接使用System.out快out.println(n); out.printf(&quot;%.2f\\n&quot;, ans); // 与c语言中printf用法相同大数据与高精度12345678910111213import java.math.BigInteger; //主要有以下方法可以使用： BigInteger add(BigInteger other) BigInteger subtract(BigInteger other) BigInteger multiply(BigInteger other) BigInteger divide(BigInteger other)BigInteger [] dividedandRemainder(BigInteger other) //数组第一位是商，第二位是余数BigInteger pow(int other)// other次方BigInteger mod(BigInteger other) BigInteger gcd(BigInteger other) int compareTo(BigInteger other) //负数则小于,0则等于,正数则大于static BigInteger valueOf(long x)//输出数字时直接使用 System.out.println(a) 即可123456BigDecimal add(BigDecimal other)BigDecimal subtract(BigDecimal other)BigDecimal multiply(BigDecimal other)BigDecimal divide(BigDecimal other)BigDecimal divide(BigDecimal divisor, int scale, BigDecimal.ROUND_HALF_UP)//除数，保留小数位数，保留方法四舍五入BigDecimal.setScale()方法用于格式化小数点 //setScale(1)表示保留一位小数，默认用四舍五入方式","link":"/2020/03/02/JAVA算法中笔记/"},{"title":"Java-基础篇1","text":"距上次学习Java基础已经过去2年多了,现在或多或少忘记了一些知识点,正好这次期末要考Java基础,在此重新把Java基础过一遍,查漏补缺,加深印象.Java的基础程序设计结构数据类型类型储存需求包装类型byte1字节Bytechar2字节Characterint4字节Integershort2字节Shortlong8字节Longfloat4字节Floatdouble8字节Doubleboolean1,0Boolean在Java中,整型、实型和字符型被视为简单数据类型,这些类型由低级到高级分别为:1（byte、short、char）---&gt; int ---&gt; long ---&gt; folat ---&gt; double自动装箱和自动拆箱装箱===&gt; 基本数据类型转换为包装器类型.拆箱===&gt; 包装器类型转换为基本数据类型.12Integer i = 1111; //装箱int n = i; //拆箱int 和 Integer 区别1.Integer是int的包装类,int是基本数据类型2.Integer变量必须实例化之后才可以使用,int可以直接使用3.Integer默认值是null,int是0String、StringBuffer、StringBuilder区别(面试常问)从三个方面去回答(可变、线程安全、String不变有什么好处)1.是否可变:1.1 String不能进行修改,若修改则是重新创建一个String对象1.2StringBuffer、StringBuilder则是直接对本身String对象进行修改,append()等方法2.是否线程安全:2.1String对象定义之后不能改变,所以线程安全2.2StringBuffer是线程不安全的,适用于单线程下操作字符串缓冲区大量数据.2.3StringBuffer:是线程安全的(对调用方法加入同步锁),执行效率较慢,适用于多线程下操作字符串缓冲区大量数据.3.String不可变有什么好处？3.1可以缓存 hash 值3.2String Pool 的需要3.3线程安全Java 修饰符访问修饰符记住一下表就完事了修饰符当前类同包子类其他包public√√√√protected√√√×default√√××private√×××非访问修饰符static(用来修饰变量、方法、类)修饰变量:变成静态变量其他的类、方法可以访问这个属性修饰方法:静态方法在类加载的时候就存在了,它不依赖于任何实例修饰语块:在类初始化一次修饰类:静态内部类不依赖外部类,且不能访问外部类的非 static 变量和方法.final修饰变量:该变量不能不可改变(基本类型)修饰方法:不能被继承类重新定义修饰类:不能够被继承abstract用来创建抽象类和抽象方法.synchronized、volatile主要用于线程的编程.变量成员变量局部变量全局变量\\成员变量局部变量静态变量定义位置在类中,方法外方法中,或者方法的形式参数在类中,方法外初始化值有默认初始化值无,先定义,后赋值才可以使用有默认初始化值调用方式对象调用—对象调用,类名调用储存位置堆中栈中方法区生命周期与对象共存亡与方法共存亡与类共存亡别名实例变量—类变量Java面对对象Java面对对象具有三大特性:封装-继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）.继承让变化中的软件系统有了一定的延续性,同时继承也是封装程序中可变因素的继承-通常认为封装是把数据和操作数据的方法绑定起来,对数据的访问只能通过已定义的接口多态-多态是指允许不同子类型的对象对同一消息作出不同的响应.要实现多态主要是做两件事:重写和重载.Overload(方法重载)和Override(方法重写)重载:是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。重写:重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！接口","link":"/2020/01/01/Java-基础篇1/"},{"title":"LeetCode 1.Two Sum","text":"Two Sum题目描述:给定一个整数数组和一个目标值,找出数组中和为目标值的 两个 数你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。示例给定 nums = [2,7,11,15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回[0,1]解法一[暴力破解法]123456789public static int[] Solution(int[] nums, int target) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (target == nums[i] + nums[j]) return new int[]{i, j}; } } throw new IllegalArgumentException(\"not two sum solution\");}解法二[一遍哈希表]12345678910public static int[] Solution2(int[] nums,int target){ Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i&lt; nums.length; i++) { if(map.containsKey(target - nums[i])) { return new int[] {map.get(target-nums[i]),i}; } map.put(nums[i], i); } throw new IllegalArgumentException(\"No two sum solution\"); }12345678910111213141516171819202122232425class Solution { public int lengthOfLongestSubstring(String s) { if (s.length() == 0 || s == null) return 0; int lo = 0, hi = 0; int len = s.length(); int maxlen = 1; //去重 HashSet&lt;Character&gt; characters = new HashSet&lt;&gt;(); for (; hi &lt; len; hi++) { //声明滑动窗口中已经有了该元素 if (!characters.add(s.charAt(hi))) { while (lo &lt; hi &amp;&amp; s.charAt(lo) != s.charAt(hi)) { characters.remove(s.charAt(lo++)); //当前lo的index 是活动窗口中于 hi index重复的字符的下标 //++ 就将前面的那个字符跳过了 } lo++; } //当新元素加入窗口之后 判断大小 maxlen = Math.max(maxlen, hi - lo + 1); } return maxlen; }}","link":"/2019/10/20/LeetCode-1-Two-Sum/"},{"title":"Java 8 - 函数编程（lambda表达式）","text":"简介超过3行的逻辑就不适用Lambda表达式了。虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖(用更简练的言语表达较复杂的含义)”,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘.)Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口.lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。基本语法(parameters) -&gt; expression或(请注意语句的花括号)(parameters) -&gt; {expression}λ表达式本质上是一个匿名方法。让我们来看下面这个例子：public int add(int x, int y) {return x + y;}转成λ表达式后是这个样子：(int x, int y) -&gt; x + y;参数类型也可以省略，Java编译器会根据上下文推断出来：(x, y) -&gt; x + y; //返回两数之和或者(x, y) -&gt; { return x + y; } //显式指明返回值可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：() -&gt; { System.out.println(“Hello Lambda!”); }如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：c -&gt; { return c.size(); }[lambda简单例子]123456// 1.不需要参数 返回值 7() -&gt; 7// 2. 接受两个int类型参数 返回值 为 两者之和(int x,int y) -&gt; x+y// 3. 接受一个string类型参数,并进行打印,没有返回值(String s) -&gt; System.out.print(s)[循环输出]12345678910111213// 随便定义的数据 String[] str = {\"zlw\",\"joe\",\"qjl\",\"lxl\",\"zc\",\"sam\"}; List&lt;String&gt; players = Arrays.asList(str); // 以前的循环方式 for (String player : players) { System.out.println(player); } System.out.println(\"--------------\"); // 使用 lambda 表达式以及函数操作(functional operation) players.forEach((player) -&gt; System.out.println(player)); System.out.println(\"--------------\"); // 在 Java 8 中使用双冒号操作符(double colon operator) players.forEach(System.out::println);[使用lambdas 来实现 Runnable接口]12345678910111213141516171819202122// 使用匿名内部类 1.1 new Thread(new Runnable() { @Override public void run() { System.out.println(\"Hello lambda1\"); } }).start();// 使用 lambda 表达式1.2 new Thread(() -&gt; System.out.println(\"Hello lambda2\")).start();// 使用匿名内部类 2.1 Runnable hello_zlw_lambda1 = new Runnable() { @Override public void run() { System.out.println(\"Hello zlw lambda1\"); } };// 使用 lambda 表达式2.2 Runnable hello_zlw_lambda2 = () -&gt; System.out.println(\"Hello zlw lambda2\"); hello_zlw_lambda1.run(); hello_zlw_lambda2.run();使用Lambdas排序集合在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。123456789101112131415// 1.1 使用匿名内部类根据 name 排序String[] players = {\"zlw\",\"joe\",\"qjl\",\"lxl\",\"zc\",\"sam\"};Arrays.sort(players, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return (o1.compareTo(o2)); }});// 使用 lambda 表达式以及函数操作(functional operation)Comparator&lt;String&gt; sortName = (String o1, String o2) -&gt; o1.compareTo(o2);Arrays.sort(players,sortName);Arrays.sort(players,(String o1,String o2) -&gt; o1.compareTo(o2));System.out.println(Arrays.toString(players));","link":"/2019/10/25/Java-8-函数编程（lambda表达式）/"},{"title":"LeetCode 13.Roman to Integer","text":"Roman to Integer罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: “III”输出: 3示例 2:输入: “IV”输出: 4示例 3:输入: “IX”输出: 9示例 4:输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.1234567891011121314151617181920public static int romanToInt(String s) { Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int result = 0; for (int i = 0; i &lt; s.length(); i++) { if(i&gt;0 &amp;&amp; map.get(s.charAt(i)) &gt; map.get(s.charAt(i-1))){ result += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i-1)); }else{ result += map.get(s.charAt(i)); } } return result; }","link":"/2019/10/21/LeetCode-13-Roman-to-Integer/"},{"title":"LeetCode 198 House Robber","text":"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 1:输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。示例 2:输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。经典的动态规划题目,这一题要好好品一下,对于房屋,我们就只有偷还是不偷这两选项,这个大佬讲的动态规划思路好理解👇:https://www.bilibili.com/video/av16544031tetle:解法一123456789101112class Solution { public int rob(int[] nums) { if (nums.length == 0) return 0; int[] dp = new int[nums.length + 1]; dp[0] = 0; dp[1] = nums[0]; for (int i = 2; i &lt;= nums.length; i++) dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]); return dp[nums.length]; }}","link":"/2020/01/06/LeetCode-198-House-Robber/"},{"title":"LeetCode 66.Plus One","text":"Plus One题目描述:给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。示例 1:输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。12345678910111213141516171819202122232425262728293031323334public int[] plusOne(int[] digits) { boolean flag = false; int len = digits.length; int[] temp = digits; // 判断最后一位是否进位 if(temp[len-1]+1==10){ temp[len-1]=0; flag = true; }else{ temp[len-1]+=1; return temp; } for (int i = len - 2; i &gt;= 0; i--) { if(flag &amp;&amp; temp[i]+1==10){ // 判断当前位是否有进位 temp[i]=0; flag = true; }else if(flag){ // 当前位没有进位加一退出 temp[i]+=1; flag = false; } } /* 例如 [9,9] 个位进位 0 十位进位 1+9=0 但退出循环了,不能在进位了,数组长度要扩位+1 */ if (flag &amp;&amp; temp[0]==0){ int[] res = new int[len+1]; res[0] =1; return res; } return temp; }225123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.LinkedList;import java.util.Queue;/** * @author zlw * @create 2020-03-01 21:52 */public class MyStack { private Queue&lt;Integer&gt; queue1; private Queue&lt;Integer&gt; queue2; public MyStack() { queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); } /** * Push element x onto stack. */ public void push(int x) { if (queue1.peek() != null) { while (queue1.peek() != null) { queue2.offer(queue1.poll()); } queue1.offer(x); while (queue2.peek() != null) { queue1.offer(queue2.poll()); } } else { queue1.offer(x); } } /** * Removes the element on top of the stack and returns that element. */ public int pop() { if (queue1.peek() == null) return 0; return queue1.poll(); } /** * Get the top element. */ public int top() { if (queue1.peek() == null) return 0; return queue1.peek(); } /** * Returns whether the stack is empty. */ public boolean empty() { return queue1.peek() == null ? true : false; }}","link":"/2019/10/22/LeetCode-66-Plus-One/"},{"title":"LeetCode 20.Valid Paretheses","text":"Valid Paretheses(有效的括号)题目描述:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例 1:输入: “()”输出: true示例 2:输入: “()[]{}”输出: true示例 3:输入: “(]”输出: false示例 4:输入: “([)]”输出: false示例 5:输入: “{[]}”输出: true12345678910111213141516171819202122public boolean isValid(String s) { Deque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') { stack.push(s.charAt(i)); } else { if (stack.isEmpty()) { return false; } else { if (stack.peek() == '{' &amp;&amp; s.charAt(i) != '}') { return false; } else if (stack.peek() == '(' &amp;&amp; s.charAt(i) != ')') { return false; } else if (stack.peek() == '[' &amp;&amp; s.charAt(i) != ']') { return false; } } stack.pop(); } } return stack.isEmpty(); }","link":"/2019/10/22/LeetCode-20-Valid-Paretheses/"},{"title":"LeetCode 58.Length of Last Word","text":"Length of Last Word(最后一个单词长度)给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。示例输入: “Hello World”输出: 5解题思路直接从字符串最后开始先前找,总长度–,找到后记录那就是’ ‘之前的长度,再去用 总长度 - 去’ ‘之前的长度 = 最后一个单词的长度12345678910111213public int lengthOfLastWord(String s) { if(s==null || s.length()==0) return 0; String trim = s.trim(); //去掉字符串两边的' '空格 if(trim.length()==0){ return 0; } int n = trim.length() -1; while (n&gt;=0 &amp;&amp; trim.charAt(n)!=' ') { n--; } return trim.length() - 1 -n; }","link":"/2019/10/23/LeetCode-58-Length-of-Last-Word/"},{"title":"LeetCode 7.Reverse Integer","text":"Reverse Integer题目描述:给定一个32位有符号整数，将整数中的数字进行反转示例1:输入:123输入:321示例2:输入:-123输入:-321示例3:输入:120输入:21注意:假设我们的环境只能存储32位有符号整数，其数值范围是[-2^31 , 2^31 -1],如果反转后的整数溢出，返回0.1234567891011public static int Solution(int x){ int rev = 0; while (x!=0){ int pop = x % 10; // 取x的最后一位 x /= 10; // 删除X的最后一位 if(rev &gt; Integer.MAX_VALUE / 10 || rev &lt; Integer.MIN_VALUE /10) //溢出判断 return 0; rev = rev * 10 + pop; //之前的数值向前推进1位加上当前数 } return rev;}LeetCode 167首先题目给的条件是已升序 ,找到两个数使得它们相加之和等于目标数我们可以用双指针对数组元素 进行相加,如果我们的双指针1个是从0,1个是从1开始之间就会有很多重复判断.为什么指针是从两边开始,这个数组最小的加上这个数组最大的的和与target对比有三种结果:正好相等 (md 绝了)sum 大于 target 这时候需要移动两个指针的其中一个,如果是移动左边的指针那么sum 只会越来越大,这样跟我们的期望的结果相反,那我们就只能去移动右边的让sum变小,来靠近targetsum 小于 target123456789101112131415 //缩减搜索空间public static int[] twoSum1(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left &lt; right) { int sum = numbers[left] + numbers[right]; if (sum &gt; target) { right -= 1; } else if (sum &lt; target) { left += 1; } else { return new int[]{left + 1, right + 1}; } } return new int[]{-1, -1};}LeetCode 111234567891011public int maxArea(int[] height) { int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) { int temp = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, temp); if (height[left] &lt; height[right]) left++; else right--; } return maxArea; }123456789101112131415161718public boolean searchMatrix(int[][] matrix, int target) { if (matrix.length == 0 || matrix == null) return false; int j = 0, i = matrix.length - 1; while (i &gt;= 0 &amp;&amp; j &lt; matrix[i].length) { if (matrix[i].length != 0) { if (matrix[i][j] &gt; target) { i--; } else if (matrix[i][j] &lt; target) { j++; } else if (matrix[i][j] == target) { return true; } } else { i--; } } return false; }","link":"/2019/10/21/LeetCode-7-Reverse-Integer/"},{"title":"Linux 学习日志-2","text":"Linux最优秀的地方之一就是在于多人多任务环境Linux一般将文件可存取的身份分为owner/group/others,各有read/write/execute等权限.1.文件拥有者我的东西,我想给谁看给谁看,我是主宰者!2.群组就是在一个群里面,我可以使用群组的资源,其他用户也可以使用。但不在群组里面的人肯定是不能使用的。3.其他人就是我有一个发小或者朋友,那么他也可以通过我来使用群组里面的资源。那么对于这个组里面的其他人,跟我这个发小并不认识,那么,发小就是他眼中的[其他人].还是就是root账户,那他就是GOD!~,可以任意访问群组,访问他想访问的任何东西!root的相关信息/etc/passwd个人的密码/etc/shadow所有的组名/etc/groupLinux的文件属性- rwx rwx —第一个字符代表这个文件的类型:[d] 目录[-] 文件[l] 连结档[b] 装置文件里面的可供储存的接口设备[c] 装置文件里面的串行端口设备,例如键盘,鼠标(一次性读取装置)[r] 可读 (权值:4)[w] 可写 (权值:2)[x] 可执行 (权值:1)这三个权限的位置不会改变,没有权限,就会出现减号[-]1.数字类型改变文件权限2.符号类型改变文件权限例如:rwx= 4+2+1 = 7rw-= 4+2+0 = 6—= 0+0+0 = 0基本上就九个权限分别是(1)user (2)group (3)others 可以用u,g,o代表这三个权限,a则代表all全部身份! [+] 加入 [-] 除去 [=]设定chmod u=rwx,go=r text.txt可以给每个角色分配一个[r]权限chmod a+w text.txt文件是否能被执行,则是籍由是否具有[x]这个权限来决定的,而不是根据扩展名。[w] 不具备删除该文件本身的权限目录里面的[x]代表用户能是否进入该目录成为工作目录。(工作目录就是目前所在的目录)假如说你的home目录下有一个你无法访问的文件,就是文件拥有者是其他人,且你也不在这个群组里面,那么你可以删除这个文件！因为你具有home目录下的rwx的完整权限当然可以删除这个对于你来说的垃圾文件。[文件拥有者的权限][加入此群组的账号的权限][非本人没有加入本群组的其他账号的权限]1 如果是文件,表示硬链接的数,如果是目录则表示该目录的子目录个数。rwx作用到文件r:读取,查看w:可以修改,但不代表可以改文件,前提是要有所在目录的写权限,才可以删除文件x可以被执行rwx作用到目录r:目录中的文件可被读w:可以被修改,目录的创建+删除+改名目录x：进入目录如果档名之前多一个[.],则代表这个文件为[隐藏档]root基本上是不受系统的权限所控制的[chgrp] 改变文件所属群组[chown] 改变文件拥有者[chmod] 改变文件的权限,SUI,SGID,SBITcp 来源文件 目标文件为什么在操作目录时候需要[r][x], 单纯操作目录[x]就足够了,但没有r的权限,那就无法知道里面的文件夹放在哪个地方,使用[tab],他就无法自动帮你补齐档名了。Linux文件种类与扩展名任何装置在Linux底下都是文件[-]1.纯文本档(ASCII)2.二进制文件(binary)3.数据格式文件(data)[d](directory)[l](link)类似window快捷方式设备与装置文件(device)[b] 就是一些储存数据,以提供系统随机存取的接口设备。(硬盘与软盘)[c]一些串行端口的接口设备(鼠标与键盘,一次性读取,不能够截断输出)资料接口文件(sockets)[s] 数据接口文件数据输送文件(FIFO,PIPE)[p] 特殊的文件类型,主要的目的在解决多个程序同时存取一个文件造成的错误问题常用的扩展名:*.sh脚本或批处理文件,因为批处理文件是shell写的*.Z *.tar *.tar.gz *.zip *.tgz打包的压缩文件*.html *.php网页相关文件Linux文件名的限制* ? &gt; &lt; ; &amp;[./] 本目录","link":"/2019/10/30/Linux-学习日志-2/"},{"title":"LeetCode 994.Rotting Oranges","text":"经典的bfs 题目,我的入门题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int orangesRotting(int[][] grid) { //方向坐标 int m = grid.length; int n = grid[0].length; int day = -1; int count = 0; Deque&lt;int[]&gt; deque = new LinkedList&lt;&gt;(); for(int i = 0;i &lt; m;i++){ for(int j = 0;j &lt; n;j++){ //记录橘子数目(不论好坏) if(grid[i][j] != 0){ ++count; } //找到第一个坏的橘子并将它的坐标设置入队 if(grid[i][j] == 2){ deque.offer(new int[]{i,j}); } } } //deque队列的最后一个元素(但不删除)。返回null如果此deque队列为空。 int[] flag = deque.peekLast(); while(!deque.isEmpty()){ //出队 将之前入队的 坏橘子的 x y 坐标取出来 int[] loc = deque.poll(); --count; for(int k =0;k &lt; 4;++k){ int x = loc[0] + delta[k][0]; int y = loc[1] + delta[k][1]; //判断当前的下标是否越界 周围的单元格是白色 和 已经是坏橘子 的就 if(x &lt; 0|| x == m || y &lt; 0 || y == n ||grid[x][y] == 0 || grid[x][y] == 2) continue; //将好橘子 变成 坏橘子 并将坐标 入队 grid[x][y] = 2; deque.offer(new int[]{x,y}); } if(loc[0] == flag[0] &amp;&amp; loc[1] == flag[1]){ ++day; flag = deque.peekLast(); } } return count &gt; 0 ? -1 : Math.max(day,0); }}bfs 模板1123456789101112131415161718192021222324/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) { Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed int step = 0; // 指示从根结点到我们正在访问的当前结点的距离。 // initialize add root to queue; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) { Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) { add next to queue; } remove the first node from queue; } } return -1; // there is no path from root to target}bfs 模板21234567891011121314151617181920212223242526272829/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) { Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed Set&lt;Node&gt; used; // store all the used nodes int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to used; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) { Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) { if (next is not in used) { add next to queue; add next to used; } } remove the first node from queue; } } return -1; // there is no path from root to target}123456789101112131415161718192021222324public int lengthOfLongestSubstring(String s) { if (s.length() == 0 || s == null) return 0; int lo = 0, hi = 0; int len = s.length(); int maxlen = 1; //去重 HashSet&lt;Character&gt; characters = new HashSet&lt;&gt;(); for (; hi &lt; len; hi++) { //声明滑动窗口中已经有了该元素 if (!characters.add(s.charAt(hi))) { while (lo &lt; hi &amp;&amp; s.charAt(lo) != s.charAt(hi)) { characters.remove(s.charAt(lo++)); //当前lo的index 是活动窗口中于 hi index重复的字符的下标 //++ 就将前面的那个字符跳过了 } lo++; } //当新元素加入窗口之后 判断大小 maxlen = Math.max(maxlen, hi - lo + 1); } return maxlen; }","link":"/2020/03/04/LeetCode-994-Rotting-Oranges/"},{"title":"Linux 学习日志-1","text":"主要学了一些基础的指令,热键command [-options] parameter1 parameter2指令 选项 参数1 参数2datedate +%Y/%m/%ddate +%H:%Mcalcal [month] [year]bc--quit 退出热键[tab] 具有[命令补全] 与 [文件补齐] 的功能! ca[tab][tab]date --[tab][tab][Ctrl] + c 中断目前程序[Ctrl] + d 键盘输入结束 可以取代(exit)[Ctrl] + l 清屏[shift] + [PageUP]|[Page Down] 向前/向后翻页--help|less |more 都是可以进行翻页阅读nano text.txt观察系统的使用状态netstat -asu - (身份变成root,底下输入root的密码)关机&amp;重启指令shutdown 如果什么参数都没有加 则系统会在1分钟之后关机-k 不是真的关机,只是发出警告！-r 系统的服务停掉之后重新启动-h 服务停掉之后关机-c 取消shutdown指令内容sync 将数据同步写入硬盘中 (如果在内存中的没有写入硬盘,该指令就可以把内存中的数据写入硬盘)shutdown (root用户下) poweroffreboot(重启) haltlogout 用户注销systemctl [指令]halt shutdown reboot poweroffpwd — 打印出当前工作目录名cd — 更改目录ls — 列出目录内容ls — 列出目录内容file — 确定文件类型less — 浏览文件内容","link":"/2019/10/30/Linux-学习日志-1/"},{"title":"Linux 学习日志-4","text":"Linux文件与目录的默认权限与隐藏权限目前用户在建立文件或目录时候的权限默认值umask数字的方式显示0022 第一组是特殊权限umask -S字符的方式显示该默认值是需要减掉的权限0022建立的文件默认权限是644(6-0,6-2,6-2)建立的目录的默认 权限是755(7-0,7-2,7-2)设置umask 002 就可以改变当前的默认值rwxr-xr-x文件的隐藏属性暂时不看Set UID查看文件类型file 文件名脚本文件名搜索which [-a] commanda 就是all PATH中可以找到的所有指令列出来文件的档名的搜寻whereis [-bmsu] 文件或者文件名[-l] 可以列出 whereis 会去查询的几个主要目录而已[-b] 只找binary格式的文件[-m] 只找说明文件 manual[-s] 只找source来源的文件[-u] 搜索不在上述三个项目当中的其他特殊文件find指令 花费的时间很大(因为它是直接搜寻硬盘)whereis指令 只找几个特定的目录而已,并没有全系统的去查询(主要是针对/bin/sbin底下的执行档)locate指令 寻找的数据是在(已建立的数据库 /var/lib/mlocate/)locate [-ir] keyword(文件的部分名称)[-i] 忽略大小写[-c] 不输出档名,仅计算找到的文件数目[-l] 输出几行的意思 -l 5[-S] 输出locate 使用的数据库文件的相关信息[-r] 正规可接正规表示法显示方式因为locate是经数据库来搜寻的,而数据库的建立默认是在每天执行一次,那么你新建的文件使用这个指令可能找不到,所以必须跟新数据库使用updatedb来更新find [PATH] [option] [option]有 -atime, -ctime , -mtime-mtimen n为数字,意义在n天之前的[一天之内]被更动过内容的文件+n n天之前被更动过内容的文件档名(不包括n天本身)-n n天之内被更改内容的文件档名-newer file file为一个存在的文件,列出比file 还要新的文件档名find / -mtime 0find Desktop -newer /与使用者或者组名有关的参数-uid n n为数字,这个数字是用户的账号的UID-gid n n为数字,这个数字是组名的GID-user name name为使用者的名字-group name name为组名-nouser 寻找文件拥有者不存在的与 /etc/passwd 的人-nogroup 寻找文件的拥有群组不存在 /etc/group 的文件与文件的权限及名称有关的参数-name filename 搜索文件名为filename的文件-size [+-]SIZE 搜寻比SIZE 还要大(+)或(-)的文件. c: byte k:1024bytes 要找20KB还要大的文件-size +50k-type TYPE 搜寻文件的类型为TYPE的,(一般正规文件f,装置文件b、c,d,l,s,p)-perm mode 搜寻文件权限刚好等于 mode的文件-perm -mode 搜寻文件权限[必须全部包括mode的权限]的文件-perm /mode 搜寻文件权限[包括任一mode的权限]的文件额外可进行的动作-exec command exec后面可以接其他的指令-print 打印输出显示find / size +1M -exec ls -l {} ;-exec 后面的指令不支持命令别名{} 代表的是[由find找到的内容],find的结果会被放置到{}位置中;是关键词,表示find 额外的动作开始(-exec)到结束(;),在中间的就是find指令内的额外的动作[;] 在bash环境下有特殊的意义,因此利用反斜杠来跳脱一. 让某用户进入某目录成为[可工作目录]的基本权限用户至少有对这个目录需要具有 x 权限二.让某用户在某个目录内读取一个文件的基本权限用户至少对这个目录具有x权限对文件具有r权限三.让一个用户可以修改文件的权限用户至少对这个目录具有x权限对文件具有r w 权限","link":"/2019/11/03/Linux-学习日志-4/"},{"title":"Linux 学习日志-3","text":"Linux目录管理绝对路径:[一定由根目录/写起] (比起正确性比相对路径要好!)相对路径:[不是由/写起]. (代表此层目录 ).. (代表上一层目录 )- (代表前一个工作目录 )~ (代表[当前用户身份]所在的家目录 )~zlw (代表zlw这个用户的家目录 )cd - 返回上一次的工作目录常用的处理目录指令cd 变换目录pwd 显示当前目录mkdir 建立一个新的目录[-m]创建目录的时候直接设定权限[-p]直接将要创建所需要的目录递归建立起来! example:mkdir -p text1/text2/text3ls -ld test*rmdir 删除一个空的目录[-p] 连同[上层][空的]目录一起删除被删除的目录里面必定不能存在其他的目录或者文件!为什么我可以在任何地方执行/bin/ls 这个指令?是因为环境变量$PATH 指定了/bin/ls,若把ls文件移入到/root下,则无法使用ls指令,可以PATH=”${PATH}:/root” 加入到执行文件搜寻路径PATH中文件与目录是检视: ls[-a] 显示全部文件,包括隐藏档,包括(.)(..)[-A] 显示全部文件,包括隐藏档,不包括(.)(..)[-d] 仅列出目录本身,不是目录下的文件数据(查询目录需要加)[-r] 直接列出结果,不排序(ls会以档名排序)[-h] 文件容量以人类易读的方式(GB KB)列出来[-i] 列出inode 号码，[-F] 根据文件,目录等信息,给予附加数据结构[-l] 长数据串行出[-S] 以文件容量大小排序[-r] 反序输出[-t] 以时间排序[-R] 连同子目录一起列出来,等于输出显示所有文件[-n] 列出UID跟GID,(而不是使用者跟群组)–color=never 不根据文件特性给予颜色显示–color=always 显示颜色–color=auto 系统自动判断–full–time 以完整的时间模式(年月日时分)输出复制 cpcp [-adfilprsu] 来源文件(source) 目标文件(destination)cp [options] source1 source2 source3… directory[-a] 相当于-dr –preserve=all的意思[-d] 若来源文件为链接文件的属性(link file),则复制链接文件属性而非文件本身[-f] 强制(force),若目标文件已经存在且无法开启,则移除后再尝试一次[-i] 目标文件存在,覆盖之前询问[-l] 进行硬链接(hard link)的连档建立,而非复制文件本身[-p] 连同文件的属性(权限,用户,时间)一起复制,而非使用默认属性[-r] 递归持续复制,用于目录的复制行为[-s] 复制成为符号链接文件(symbolic link),亦即[快捷方式]文件[-u] destination 比 source 旧才跟新 destination,或者destination 不存在的情况下才复制移除 rmrm [-fir] 文件或目录[-f] 强制删除,忽略不存在的文件,不会出现警告[-i] 询问[-r] 递归删除! rm -r /tmp/etc如果身份是root ,预计加入 -i 的选项,需要一直按y才会删除可以按[Ctrl] + c 结束这是一种保护动作,如果不需要\\rm -r /tmp/etc删除档名第一个字符有[-] -aaa- 因为’-‘是选项,系统会误判rm ./-aaa-移动 mvmv [-fiu] source destinationmv [options] source1 source2 source3 … directory[-f] 强制,如果存在的文件,不会询问直接覆盖[-i] 询问[-u] 若目标文件存在,且source比较新,才会更新(update)更改名字mv mytest mytest1取得最后的档名basename取得目录名dirname文件内容查阅cat 由第一行开始显示文件内容tac 从最后一行开始显示, tac就是cat倒着写的！nl 显示行号more 一页一页显示文件内容less 比moreg好,可以向前翻页head 只看前几行 -n (默认10行)tail 只看后几行 -n (默认10行)od 二进制的方式读取文件内容cat [-AbEnTv][-A] 相当于-vET的整合[-b] 列出行号,仅对非空白行,空白行不标行号[-E] 结尾断行字符$显示出来[-n] 打印出行号,空白行也打印[-T] 将[tab]按键以 ^[显示出来[-v] 列出一些看不到的特殊字符more空格 代表向下翻一页Enter 代表向下翻一行/字符串 [字符串]搜索:f 立即显示出文件名和行数q 退出b 或者[Ctrl] + b 往回翻页less/字符串 向下搜索?字符串 向上搜索q 退出g 第一行G 最后一行修改文件时间或者建置新档 touch三个主要的变动时间modification time当该文件的[内容数据]变更时,就会更新这个时间status time当该文件的[状态]变更时,就会更新这个时间(权限或者属性)access time当[该文件的内容被取用]时,就会更新这个时间(cat 去读取时)ls显示出来的是该文件的mtime,也就是这个文件上一次的内容被改动的时间。如果touch的文件不存在,那么会创建一个新的空文件.如果存在那么文件的三个时间(atime,ctime,mtime)都会更新为目前的时间ll===&gt; ls -l(别名)[;] 代表连续指令的下达! date ; ll bashrc ; ll –time=atime bashrc; ll –time=ctime bashrc;touch [-acdmt] 文件[-a] 仅修改atime[-c] 仅修改文件时间,文件不存在不新建[-d] 后面可以接修改的日期而不是目前的日期,也可以使用 –date=”日期或者时间”[-m] 仅修改mtime[-t] 后面可以接修改的时间而不用目前的时间,格式为[YYYYMMDDhhmm]复制一个文件时,复制所有的属性,但没办法复制ctime.","link":"/2019/11/01/Linux-学习日志-3/"},{"title":"Linux 学习日志-5","text":"Linux 磁盘与文件系统管理磁盘的组成圆形的磁盘盘(主要记录数据的部分)机械手臂,与在机械手臂上的磁盘读取头(可擦写磁盘盘上的数据)主轴马达,可以转动磁盘盘磁盘盘的组成扇区(Sector)为最小的物理储存单位,目前主要有 512bytes 与4K 两张格式.将扇区组成一个圆,那就是磁柱;早期的分区主要是以磁柱为最小分区单位,现在的分区通常使用扇区为最小分区单位(每一个扇区都有号码)磁盘的分区表主要有两种格式,一个是限制较多的MBR分区表,一种是较新且限制较少的GPT分区表MBR分区表中,第一个扇区最重要,里面有:(1)主要开机区(Master boot record)及分区表(partition table) MBR 占有446bytes 而 partition table 占有 64bytesGPT分区表除了分区数量扩展开了所有的磁盘文件名已经被模拟成/dev/sd[a-p][1-128]/dev/vd[a-d][1-128]mbr分区1.最多支持四个主分区2.系统只能安装在主分区3.扩展分区要占一个主分区4.mbr最大只支持2tbgpt分区1.支持无限多个主分区2.最大支持18EB的大容量(EB=1024PB,PB=1024TB)3.windows7 64位以后支持gpt文件系统特性superblock: 记录filesystem 的整体信息,包括inode/block的总量、使用量、剩余量,及文件系统的格式和相关信息等","link":"/2019/11/13/Linux-学习日志-5/"},{"title":"Markdown操作","text":"Markdownd是一种轻量级的标记语言Markdownd编写的文档后缀为.md,.markdownHello World!标题我是一级标题我是二级标题一级标题二级标题三级标题四级标题[格式]123456============------------######1-6个# 表示1-6级标题段落格式1.末尾添加两个空格2.使用空行来换行字体[字体格式]123456*斜体字体*_斜体字体_**粗体字体**__粗体字体__***粗斜体字体***___粗斜体字体___斜体字体斜体字体粗体字体粗体字体粗斜体字体粗斜体字体分割线[分割线格式]12345**** * ******- - ----------删除线和下划线和脚注zlwblogzlwBLOGzlwblog1这是一个脚注^123这是一个脚注列表123123第一项1.11.2第二项2.12.2结束区块zzzzzzllllllwwwwwwwz12311.11.22代码printf()函数test(){12 111;}支持HTML元素https://github/ZlwPickCtrl+Alt+Del重启电脑转义 *","link":"/2019/10/19/Markdown操作/"},{"title":"Linux 学习日志-6","text":"vi 跟 vim 编辑器正常模式可以使用快捷键yy复制当前行, 5yy复制当前以下5行 p粘贴dd 删除G 最末行gg 最首行u 撤销之前写的10gg查找某关键字 /XXXX n 下一个插入模式(编辑模式)可以输入内容,按i、I,o、O等进入命令行模式可以完成读取,存盘,替换,离开等操作q 打开后没有修改wq 打开后修改了q! 强制保存set nu 设置行数set nonu 取消行数习惯性的会按Ctrl+s vim会进入假死状态,按Ctrl+q退出该状态用户管理添加用户useradd [选项] -d 指定目录 (每个用户必须在一个组里面,新创建的一个组在以自己名字的组中)useradd -g 组名 用户名passwd 设置密码userdel 删除用户 保存家目录 [-r] 家目录一起删除查询用户信息id 用户名su - 切换到rootsu - 用户名 切换到普通用户exit 回到原来的用户添加组groupadd 组名groupdel 组名修改用户所在的组usermod -g 组名 用户名配置文件用户信息配置文件etc/passwd其中行的每一个项的意义用户名 口令 用户id 组id 家目录 登录shell组配置文件etc/group其中行的每一个项的意义组名 口令 组内成员列表 组id口令配置文件(密码和登录信息,是加密的)etc/shadow其中行的每一个项的意义登录名 加密口令 最后一次修改时间 最小间隔 最大时间间隔等等Linux的运行级别描述linux运行级别0-6的各自含义（记时1分钟）0：关机1：单用户模式2：无网络支持的多用户模式3：有网络支持的多用户模式（文本模式，工作中最常使用的模式）4：保留，未使用5：有网络支持有X-Window支持的多用户模式6：重新引导系统，即重启文件在/etc/inittab中init [012356]常用的指令帮助类指令man [命令或者配置文件]help [命令]目录类指令pwdlscdmkdir [选项] -p 多级 要创建的目录rmdir [选项] -rf 只能删除空目录 否则加rfch 文件名1 文件名2cp [选项]-r 源 目的rm [选项] -r 递归 -f 强制(force) 文件名mv 文件名1地址 文件名2地址cat -n 文件地址 |more(一次性全部加载) less(懒加载)more 文件地址less 文件地址&gt; 文件 列表内容写入文件a.txt中 覆盖&gt;&gt; 文件 列表的内容追加到文件a.txt的末尾cat 文件1 &gt; 文件2 覆盖cat 文件1 &gt;&gt; 文件2 追加echo “内容” &gt; 文件echo “内容” &gt;&gt; 文件echo $PATHhead [-n] 文件 显示文件的前10行tail [-n] 文件 显示文件的后10行tail -f 文件history 查看历史执行的指令history n 查看最后n条指令ln -s 源文件地址 链接名删除链接rm -rf 链接名 (切记链接名后面不可以加/ 要不然把链接地址下面的东西全部删除)查找类指令find [查找范围] [选项] -name 文件名(可以用正则表达式)find [查找范围] -user 用户名 (显示指定的用户的所有文件)+n大于 -n小于 n等于find [查找范围] -size +nM(k G)快速定位通过locate数据库找到文件路径updatedb| 表示将前一个命令的处理结果输出传递给后面的命令处理过滤查找 一般配合管道使用grep [选项] 查找内容 源文件-n 显示匹配行-i 忽略大小写压缩与解压缩指令gzip 文件名 (压缩完之后 原来的文件不保留)gunzip 文件名zip [选项] XXX.zip 将要压缩的内容(文件或者目录)-runzip [选项] [指定解压到的目录] XXX.zip-d 指定解压到的目录tar 指令(打包指令.tar.gz)选项-c 产生.tar打包文件-v 显示详细信息-f 指定压缩后的文件名-z 打包同时压缩-x 解压.tar文件tar -czvf zlw.tar.gz zlw.py zlw1.py解压文件tar -xzvf zlw.tar.gz(默认的本目录) -C [指定的目录]","link":"/2020/01/14/Linux-学习日志-6/"},{"title":"Linux 学习日志-7","text":"组管理和权限管理[chgrp] 改变文件所属群组[chown] 改变文件拥有者改变用户所在的组usermod -g 组名 用户名groups 查询所有的组chown newuser:newgroup file 改变用户的拥有者和所在组-r 目录下面的所有东西都改变crond 任务调度crontab [选项]| -e | 编辑crontab定时任务 || -i | 查询crontab任务 || -r | 删除当前用户所有的crontab任务 |参数细节| / | 含义 | 范围 || :—-:| :—-: | :—-: || 第一个”*” | 一小时当中的第几分钟 | 0-59 || 第二个”*” | 一天当中的第几小时 | 0-23 || 第三个”*” | 一月当中的第几天 | 0-31 || 第四个”*” | 一年当中的第几月 | 1-12 || 第五个”*” | 一周当中的星期几 | 0-7 |特殊符号| 特殊符号 | 含义 || :—-:| :—-: || * | 一小时当中的第几分钟 || 第二个”*” | 一天当中的第几小时 || 第三个”*” | 一月当中的第几天 || 第四个”*” | 一年当中的第几月 || 第五个”*” | 一周当中的星期几 |linux分区硬盘 linux的文件系统分区一 /分区二 boot mnt…。。。。。。分区挂载到目录(mount挂载和umount卸载)查看系统的分区和挂载的情况lsblk -f如何添加一块硬盘1.虚拟机添加硬盘(当添加之后lsblk中并没有新的硬盘的信息,需要虚拟机重启)2.分区(fdisk 地址)3.格式化()4.挂载5.设置自动挂载查询系统磁盘的整体使用情况df -lh查询某一特定的目录的使用情况du -h /….-h 带计量单位-a 带文件-c 列出明细的同时,增加汇总值–max-depth=1 子目录深度统计指定目录下文件的数目ls -l /home/zlw | grep “^-“ | wc -l统计指定目录下目录的数目ls -l /home/zlw | grep “^ d” | wc -l统计指定目录下文件的数目,包括子文件下的ls -lR /home/zlw | grep “^-“ | wc -l统计指定目录下目录的数目 ,包括子文件下的ls -lR /home/zlw | grep “^ d” | wc -l用树状显示目录yun install treeRPM==&gt;&gt;下载包的打包及安装工具(类似于windows中的setup.exe)查询已经安装的的rpm列表rpm -qa | grep XX查询rpm安装的软件信息rpm -qi XXX查询rpm包的文件安装在哪rpm -ql XXX查询某个文件所有那个rpm包rpm -qf XXX删除rpm包rpm -e rpm包的名称强制删除(在某些情况下你要删除的包可能跟其他的包有依赖在删除之后可以会出现错误)rpm -e –nodeps foo用rpm安装包rpm -ivhinstall 安装verbose 提示hash 进度条安装的步骤1.先找到要安装rpm包,然后需要挂载安装的centos的iso文件,然后到/media/下去找rpm2.copy出来在安装YUN 是基于rpm包管理,能够从指定的服务器自动下载rpm包并安装&lt;fontcolor=”red”&gt;可以自动处理依赖性关系查看yum 服务器是否需要安装的软件yum list | grep firefox安装yum install firefox安装jdk,配置java环境1.先将软件通过xftp5继续远程上传到 /opt 下2.解压到/opt3.配置环境变量的配置文件 vim /etc/profile4.JAVA_HOME=/opt/jdk1.7.0_795.PATH=/opt/jdk1.7.0_79/bin:$PATH6.export JAVA_HOME PATH安装tomcat1.解压apache-tomcat-7.0.70.tar2.cd 到apache-tomcat-7.0.70.tar/bin./startup.sh (启动)如果想要windows上访问Linux的http://localhost:8080就需要linux放行8080端口window中telnet服务记得打开telnet 192.168.0.116 8080firewall-cmd –zone=public –list-portsfirewall-cmd –permanent –zone=public –add-port=80/tcpCentos7:firewall-cmd –permanent –add-port=8080/tcp–zone #作用域–add-port=80/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效//firewall-cmd –reloadservice firewalld restarttelnet成功而打不开的先试试本地是否打开，然后看看防火墙端口centos7可以看systemctl status firewalld，或者用以前的ps和top都能看到，要活学活用eclipse的安装1.解压到/opt中2.配置jre和server3.编写jsp测试MySQL安装和配置1.卸载旧版本-rpm -qa | grep mysql有删除,没有下一步2.安装mysql安装编译代码需要的包yum -y install make gcc-c++ cmake bison-devel ncurses-devel12345678cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql-DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc-DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1-DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1-DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306-DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENHINE=1-DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8-DDEFAULT_COLLATION=utf8_general_ci3.make &amp;&amp; make install (此过程按照时间很长)4.查看是否有MySQL用户及用户组cat /etc/passwd 查看用户cat /etc/proup 查看组没有创建修改 ls -al /usr/local/mysql的权限,交给mysql组chown -R mysql:mysql /usr/local/mysql/5.初始化mysqlcd /usr/local/mysql/scripts/mysql_install_db –basedir=/usr/local/mysql –datadir=/usr/local/mysql/data –user=mysqlmv /etc/my.cnf /etc/my.cnf.bak6.启动mysqlcp support-files/mysql.server /etc/init.d/mysqlchkconfig mysql on设置默认启动service mysql startnetstat -anp |more (查看3306端口)7.修改root的密码cd /usr/local/mysql/bin./mysql -urootSET PASSWORD = PASSWORD(‘weiwei1998’);quit退出再次进入 ./mysql -u root -p","link":"/2020/01/19/Linux-学习日志-7/"},{"title":"Nginx 动静分离和高可用","text":"待完善","link":"/2020/02/14/Nginx-动静分离和高可用/"},{"title":"Linux 学习日志-9","text":"桥连接:liunx可以和其他的系统通信,但可以造成ip冲突NAT:网络的地址转换方式:liunx可以访问外网,不会造成ip冲突主机模式:liunx是一个独立的主机,不能访问外网.一些基本的命令练习第一组1.在root下创建空文件1.txt2.在root下创建目录file1/file23.将1.txt复制到file1/file24.将1.txt移动到file1下5.分别查看file1和file2下的内容6.删除file2第二组1.创建5个文件分别是 1.txt 2.txt 3.txt 4.txt 5.txt2.压缩这5个文件，压缩包的名字是zlw.tar3.把压缩包移动到/home下面4.解压hailiang.tar5.查看是否有这5个文件","link":"/2020/02/12/Linux-学习日志-9/"},{"title":"Nginx 简介和安装","text":"Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器,其特点是占有内存少，并发能力强.简介Nginx是什么?是一个高性能的HTTP和反向代理web服务器.为什么使用Nginx?在传统的Web项目中,并发量小,用户使用的少.所以在低并发的情况下,用户可以直接访问tomcat服务器,然后tomcat服务器返回消息给用户。用户访问&lt;—&gt;Tomcat服务器在互联网项目下,因单个Tomcat默认并发量有限,会产生如下问题:1.用户并发大的情况下,单个Tomcat服务器无法支撑.1.1 垂直 (扩展服务器的设备,买更好的服务器,来扩大Tomcat的并发量)1.2 水平(线性扩展 多个Tomcat服务器来支持用户的请求)问题: 用户需要记很多个服务器地址,用户根本不知道哪台服务器是忙闲?这时候Nginx完美解决。Nginx特点1.高并发,高可用,高性能2.可扩展性好3.热部署4.BSD许可证代理的概念正向代理是一个位于客户端和原始服务器之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回客户端,客户端才能使用正向代理.反向代理反向代理方式是指以代理服务器来接受internet上的连接请求,然后将请求转发给内部网络上的服务器,并将服务器上得到的结果返回给internet上请求连接的客户端,此时代理服务器对外就表现为一个反向代理服务器.两者之间的区别正向代理,是在客户端的.(VPN)反向代理,是作用在服务器端的,是一个虚拟IP(VIP)安装(linux下)1.一键安装四个依赖包yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel2.下载Nginx,解压12345678cd /usr/local/mkdir nginxcd nginx/#下载安装Nginxwget http://nginx.org/download/nginx-1.13.11.tar.gz#先切换到opt目录下，新建文件夹nginx-1-13cd nginx-1.13.11./configure --prefix=/opt/nginx-1-13 #指定安装目录3：在nginx-1.13.11目录下执行编译和执行安装命令make &amp;&amp; make install4:切换到安装目录和启动cd /opt/nginx-1-13/sbin/12345678910#启动Nginxnginx #强制关闭(某些东西不会保存,因此会丢失,此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。)nginx -s stop#强制关闭(某些东西不会保存,此方式停止步骤是待nginx进程处理任务完毕进行停止。)nginx -s quit#重启nginxnginx -s reload#查看Nginx版本nginx -vnginx.conf 配置文件全局块从配置文件开始到events块之间的内容,主要会设置一些影响nginx服务器整体运行的配置指令,主要包括配置运行Nginx服务器的用户(组)、允许生成的worker process数,进程PID 存放路径、日志存放路径和类型以及配置文件的引入等.events块events块涉及的指令主要影响Nginx服务器与用户的网络连接.http块nginx服务器配置中最频繁的部分,代理、缓存和日志定义等绝大多数功能和第三方模块的模块的配置都在这里面.可以分为一下两部分:http 全局块http全局块配置的指令包括文件引入,MIME-TYPE定义、日志自定义、连接抄时间等server 块这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。1.全局 server 块最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。2.location 块一个 server 块可以配置多个 location 块。这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。 地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。反向代理(实例)目的:打开浏览器,在浏览器地址栏输入地址www.zlw.com,跳转到linux系统Tomcat主页面. 1.启动Tomcat(端口8080,开放端口见linux学习日志7)2.本地DNS域名解析修改hosts文件192.168.0.9 www.zlw.com3.http://www.zlw.com:8080/访问出现Tomcat主页4.修改nginx.conf 实现反向代理server_name 192.168.0.9location / {root html;proxy_pass http://127.0.0.1:8080; index index.html index.htm;}修改Tomcat的端口号详细修改的地方展开查看1234&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;&lt;Server port=&quot;8015&quot; shutdown=&quot;SHUTDOWN&quot;&gt;&lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;&lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;准备两个Tomcat服务器8080，8081 创建见文件夹和测试页面负载均衡增加服务器的数量,然后将请求分发到各个服务器上,将原先请求集中到单个服务器上的情况改为请求分发到多个服务器上,将负载分发到不同的服务器,这就是负载均衡.· 目的:http://192.168.0.9/zlw/hhhh.html,实现负载均衡的效果,平分到8080,8081端口中.1.准备两台Tomcat,中都有zlw文件夹,创建hhhh.html2.配置nginx.conf详细配置的地方展开查看1234567891011121314151617181920upstream myserver{ #ip_hash; server 192.168.0.9:8080; server 192.168.0.9:8081; } server { listen 80; server_name 192.168.0.9; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; proxy_pass http://myserver:8080; index index.html index.htm; } }负载均衡的策略轮询(默认)每个请求按时间顺序逐一分配到不同的后端服务器,如果后端服务器down掉,能自动剔除.weightweight代表权,默认为1,权重越高被分配的客户端越多.指轮询几率,weight和访问比率成正比,用于后端服务器性能不均的情况; upstream myserver{ server 192.168.0.9:8080 weight=1; server 192.168.0.9:8081 weight=2; } ip_hash每个请求访问ip的hash结果分配,这样每个访客固定访问一个后端服务器,可以解决session的问题: upstream myserver{ ip_hash; server 192.168.0.9:8080; server 192.168.0.9:8081; } fair(第三方)按后端服务器的响应时间来分配请求,响应时间短的优先分配. upstream myserver{ server 192.168.0.9:8080; server 192.168.0.9:8081; fair; }","link":"/2020/02/12/Nginx-简介和安装/"},{"title":"Python-入门篇2","text":"大部分是关于函数及其参数的记录.help() 帮助函数数据类型转换将其他类型转化成本类型int()float()bool()str()函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”a = maxprint(a(1,2,3,4,99,44,77))空函数(pass语句表示什么都不做,可以在其他语句中出现,有占位符的意思)def nop():pass数据类型检查可以用内置函数isinstance()if not isinstance(x, (int, float)):raise TypeError(‘bad operand type’)Python中的函数可以返回多个值(但其实这只是一种假象,Python函数返回的仍然是单一值,返回值是一个tuple！)def cheng(x,y):a = x * xb = y * yreturn a,b;print(cheng(3,5)[0])默认参数 (默认参数必须指向不变对象！ )def d1(x,y=”zlw”):print(“name”,y)print(“x”,x)d1(“qweq12123we”)d1(“qweqwe”,”ZLWZLW”)也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。d1(“qweq12123we”,y=”zlwzlw”,z=18)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687a = maxprint(a(1,2,3,4,99,44,77))def zlw(x): if not isinstance(x,(float,int)): raise TypeError(\"Type Error!\") if x &gt; 10: print(\"YES! I M\") else: print(\"NO! NO! NO!\")zlw(18)def nop(): passdef cheng(x,y): a = x * x b = y * y return a,b;print(cheng(3,5)[0])def d1(x,z=18,y=\"zlw\"): print(\"name\",y) print(\"age\",z) print(\"x\",x)d1(\"qweq12123we\",y=\"zlwzlw\",z=18)d1(\"qweqwe\",15,\"ZLWZLW\")#因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，# 如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。def d2(L=[]): L.append(\"END\") return Lprint(d2([1,2,3,4]))print(d2())print(d2())print(d2())print(d2())#可以用None这个不变对象def d3(L=None): if L is None: L = [] L.append(\"END\") return Lprint(d3())print(d3())print(d3())#可变参数def d4(*numbers): #这里加*是把参数列表封装成一个tuple sum = 0 for x in numbers: print(x+sum) sum += xd4(1,2,3,4,5,6,7)#如果已经有一个list或者tuplelist = [10,20,30,40,50,60,70]d4(*list)#关键字参数#关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。def person(name,age, **k): #def person(name, age, *, city, job): if \"city\" in k: print(\"YES!!\") print(\"name\",name,\"age\",age,\"other\",k)person(\"zlw\",18)Map = {\"city\":\"jingmen\",\"job\":\"XS\"}person(\"zlwzlw\",111,**Map)#参数组合#在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，# 这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：# 必选参数、默认参数、可变参数、命名关键字参数和关键字参数。#递归函数def fact(n): if n == 1: return 1 return n * fact(n-1)print(fact(10))","link":"/2019/12/13/Python-入门篇2/"},{"title":"Linux 学习日志-8","text":"shell是什么shell是一个命令行解释器,他为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用shell来启动,挂起,暂停,编写一些程序. document.querySelector('video').playbackRate = 16.0; ## 脚本格式要求 1.脚本以#!/bin/bash 开头 2.脚本需要有可执行权限脚本的常用执行方式首先要赋予执行的权限1.直接输入文件的路径(绝对,相对都可以)2.sh ./helloworld.sh(不需要赋权限)shell的变量1.liunx shell中的变量分为系统变量和用户自定义变量1.1系统变量: $HOME $PWD $SHELL $USER1.2显示当前shell中的所有变量:setshell变量的定义基本语法(在引用变量时需要使用$)定义变量: 变量=值撤销变量 unset 变量(赋null)声明静态变量: readnoly 变量(不能unset) 定义变量的规则1.变量名可以由字母、数字和下划线组成,但是不能以数字开头。2.等号两侧不能有空格3.变量名称一般习惯为大写将命令的返回值赋值给变量1.A=ls -la2.A=$(ls -la)编写属于自己的环境变量在/etc/profile 编写,编写完成后需要刷新该文件source多行注释::&lt;&lt;! ZLW=”ZLW”echo “$ZLW”!位置参数变量执行一个shell脚本时,如果希望获取到命令行的参数信息,就可以使用位置参数变量(类似于方法传参的形式)1./Myshell.sh 100 200 300$n (n为数字,0代表命令本身,1-9为第一到第九个参数,大于10需要用大括号包含,如${10})$* (所有参数看成一个整体)$@ (也代表所有参数,但每个参数区分对待)$# (参数的个数)预定义变量事先已经定义好的变量,可以直接在shell脚本中使用1.$$ (当前进程的进程号(PID))2.$! (后台运行的最后一个进程的进程号)3.$? (最后一次执行的命令的返回状态)运算符基本语法1.$((运算式)) 或 $[运算式]2.expr m + n (expr运算符间要有空格)3.expr m - n4.expr * / % (乘,除,取余)#第一种方式RESULT1=$(((2+3)4))RESULT2=$[(2+3)4]echo “结果1=$RESULT1”echo “结果2=$RESULT2”#第二种方式RESULT3=expr 2 + 3RESULT4=expr $RESULT3 \\* 4echo “RESULT4=$RESULT4”条件判断基本语法[ condition ] (condition前后要有空格)非空返回 true两个整数的比较= 字符串比较-lt 小于(less than)-le 小于等于(less equal)-eq 等于(equal)-gt 大于(greater than)-ge 大于等于(greater equal)-ne 不等于(not equal)按照文件的权限进行判断-r-w-x按照文件的类型进行判断-f (文件存在并且是一个常规的文件)-e (文件存在)-d (文件存在并是一个目录)流程控制if 判断基本语法(两种方式,中括号和条件判断式之间必须有空格)1.123if [ 条件判断式 ];then 程序fi2.1234567if [ 条件判断式 ]then 程序 elif[ 条件判断式 ] then 程序fi案例展开查看12345678#!/bin/bashif [ $1 -ge 60 ]then echo &quot;及格&quot;elif [ $1 -lt 60 ]then echo &quot;不及格&quot;ficase 语句基本语法1234567891011121314case $变量名 in &quot;值1&quot;) 值为1的程序段;;&quot;值2&quot;) 值为1的程序段;;&quot;值3&quot;) 值为1的程序段;;*) 以上值都不是执行该语句;;esac案例展开查看12345678910111213141516#!/bin/bashcase $1 in&quot;1&quot;) echo &quot;周一&quot;;;&quot;2&quot;) echo &quot;周二&quot;;;&quot;3&quot;) echo &quot;周三&quot;;;*) echo &quot;xxxxxxxx&quot;;;esacfor 循环基本语法 (这就要用到之前的位置变量)1.跟Python很类似1234for 变量 in 值1 值2 值3do 程序done2.跟java很类似1234for((初始值;循环控制条件;变量变化))do 程序done 案例展开查看12345678910111213141516171819#!/bin/bashfor i in &quot;$*&quot;do echo &quot;$i&quot;doneecho &quot;--------------------------------&quot;for z in &quot;$@&quot;do echo &quot;$z&quot;doneSUM=0for((i=1;i&lt;=100;i++))do SUM=$[$SUM + $i]doneecho &quot;$SUM&quot;while 语句基本语法12345678SUM=0i=0while [ $i -le $1 ]do SUM=$[$SUM+$i] i=$[$i+1]doneecho &quot;sum=$SUM&quot;read 读取控制台输入基本语法read (选项)(参数)-p (指定读取值时的提示符)-t (指定提示的时间,超过就不在等待,单位是秒)12345read -p &quot;输入数字:&quot; NUMecho &quot;num=$NUM&quot;read -t 10 -p &quot;输入数字:&quot; NUM1echo &quot;NUM1=$NUM1&quot;函数1.系统函数basename[pathname][suffix]功能:返回完整路径最后/部分,常用于获取文件名suffix为后缀,在返回结果是会被去掉basename ./zlw.txt .txtdirname功能:返回完整路径最后/部分前面的部分,跟basename相反dirname /home/zlw/shellzlw/zlw.txt2.自定义函数12345678910111213#!/bin/bash#不需要形参function getSum(){ NUM=$[$N1 + $N2] echo &quot;$NUM&quot;}read -p &quot;输入第一个参数:&quot; N1read -p &quot;输入第二个参数:&quot; N2#方法调用getSum $N1 $N2","link":"/2020/02/10/Linux-学习日志-8/"},{"title":"Python-入门篇1","text":"因为比较好奇爬虫技术,对比了一下,Java写爬虫的话比较麻烦,所以花点时间去学习一下Python输入函数 input()12345678910111213141516171819202122232425262728293031print(\"Hello\",\"Word\",\"Python!\")print(1000+1000)#name = input(\"请输入名字:\")#print(\"hello:\",name)#print(\"1024*768=\",1024*768)#字符串可以用这两个表示 \"\" '' 如果\"\"中有'转义字符\\,例如一下#\\n表示换行,\\t表示制表符,字符\\本身也要转义,所以\\\\表示的字符就是\\print('I\\'m \\\"OK!\\\"')print('I\\'m \\n \\\"OK!\\\"')print('I\\'m \\t \\\\ \\\"OK!\\\"')#Python还允许用r''表示''内部的字符串默认不转义print(r'I\\'m \\t \\\\ \\\"OK!\\\"')#Python允许用'''...'''的格式表示多行内容 ,在交互式命令行中 &gt;&gt;&gt; 变成 ...print('''zlw1 zlw2zlw3 ''')# True 和False , or and notprint(True)print(False)print(2 &gt; 3)print(3 &gt; 2)print(\"---------------\")print(\"and\",True and False)print(\"or\",True or False)print(\"not\", not True)#Python中空值是 None变量这种变量本身类型不固定的语言称之为动态语言,与之对应的是静态语言.静态语言在定义变量时必须指定变量类型,如果赋值的时候类型不匹配,就会报错.Python 对缩进很敏感 tab和空格的混用会导致错误123456789101112131415161718a = 123print(a)a = \"123123\"print(a)x = 10print(x)x = x + 10print(x)#在Python中,通常用全部大写的变量名表示常量：PI = 3.1415926print(PI)#在Python中,有两种除法 1./(有小数) 2.//(只有整数)print(10/3)print(10//3)print(10 % 3)编码12345678910111213141516171819#Python中字符串是Unicode编码 ord() 获得整数的值 chr()根据整数转字符print(ord(\"A\"),ord(\"中\"),chr(65),chr(97))#由于Python的字符串类型是str,在内存中以Unicode表示,一个字符对应若干个字节.# 如果要在网络上传输,或者保存到磁盘上,就需要把str变为以字节为单位的bytes.print(\"周李伟\".encode(\"utf-8\"))print(len(\"zlwzlwlaqweqwe\"))#!/usr/bin/env python3# -*- coding: utf-8 -*-#第一行注释是为了告诉Linux/OS X系统,这是一个Python可执行程序,Windows系统会忽略这个注释；#第二行注释是为了告诉Python解释器,按照UTF-8编码读取源代码,否则,你在源代码中写的中文输出可能会有乱码.#格式化跟C一样 %d 整数# %f 浮点数# %s 字符串（它会把任何数据类型转换为字符串）# %x 十六进制整数print(\"zlw是%d个%s\" %(1,\"废物\"))listPython中的list,list是一个可变的有序表,list里面的元素的数据类型也可以不同,list元素也可以是另一个list1234567891011121314151617list = [\"ZLW1\",\"ZLW2\",\"ZLW3\"]print(len(list))#print(list[2])#print(list[-1]) #倒数第一个数,以此类推list.append(\"zlw4\")list.insert(1,\"zlwzlw\")list.pop()list.pop(0)list[1]=\"ZZZZZZZ\"for z in list: print(z)print(\"------------\")#二维数组s = [\"JAVA\",[\"C++\",\"C#\",\"C\"],\"Python\"];for z in s: print(s[1][1])tupletuple,tuple和list非常类似,但是tuple一旦初始化就不能修改,tuple的陷阱,当你定义一个tuple时,在定义的时候,tuple的元素就必须被确定下来这是因为括号()既可以表示tuple,又可以表示数学公式中的小括号,这就产生了歧义,因此,Python规定,这种情况下,按小括号进行计算,计算结果自然是1.所以,只有1个元素的tuple定义时必须加一个逗号,来消除歧义.123456789101112t = (1,2,3,4)t = (1,)for t1 in t: print(t1)#tuple所谓的“不变”是说,tuple的每个元素,指向永远不变.那么他指向的list的不会改变,就并不代表list中的值不可改变t = (\"A\",\"B\",[\"ZLW\",\"ZLW\"])for t2 in t: print(t2)t[2][0] = \"周李伟是废物\"for t2 in t: print(t2)条件判断根据Python的缩进规则,如果if语句判断是True,就把缩进的两行print语句执行了,否则,什么也不做.12345678910111213141516171819age = 20if age &gt; 33: print(\"you age\",age)elif age &gt; 18: print(\"！！！！！\")else: print(\"?????\")#elif else if的缩写#if语句执行有个特点,它是从上往下判断,如果在某个判断上是True,把该判断对应的语句执行后,就忽略掉剩下的elif和else#birth = input(\"请输入您的生日\");# 这里面input输入进来的是字符串类型不能直接跟Int类型对比,需要用int()函数进行转化,当然你输入的是字符也不行,也不能跟进行比较#Traceback (most recent call last):# File \"D:/PythonWork/Zlw.py\", line 125, in &lt;module&gt;# if birth &gt; 2000:# TypeError: '&gt;' not supported between instances of 'str' and 'int'#if int(birth) &gt; 2000:# print(\"年轻人\")#else:# print(\"老逼\")dict、set和循环Python内置了字典：dict的支持,在其他的语言中是Map,使用键-值（key-value）存储.具有极快的查找速度.dict的key必须是不可变对象(要保证hash的正确性)对于不变对象来说,调用对象自身的任意方法,也不会改变该对象自身的内容.相反,这些方法会创建新的对象并返回,这样,就保证了不可变对象本身永远是不可变的.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647d = {\"zlw1\":999,\"zlw2\":777,\"zlw3\":222}print(d[\"zlw1\"])#避免key不存在用的错误,有两种方法print(\"zlw\" in d)print(d.get(\"zlw\"))print(d.get(\"zlw\",\"?????\"))d.pop(\"zlw1\")print(d)#set和dict类似,也是一组key的集合,但不存储value,key不能重复.要创建一个set,需要提供一个list作为输入集合d = set([1,1,2,3,4,5])s = set([3,2,15])print(d)d.add(12)print(d)d.remove(1)print(d)print(d &amp; s) #交集print(d | s) #并集#循环sum = 0for x in [1,2,3,4,5,6,7,8,9]: sum += xprint(sum)sum = 0for x in range(101): sum += xprint(sum)sum = 0n = 1while sum &lt; 100: n += 3 sum += nprint(sum)n = 1while n &lt; 100: n+=1 if n % 2 == 0: continue if n &gt; 50: break print(n)print(\"end\")","link":"/2019/12/12/Python-入门篇1/"},{"title":"Python-入门篇3","text":"这部分是关于Python的高级特性切片就是取list跟tuple,如刀切一般,取出部分元素L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3,那么它同样支持倒数切片12345678910111213141516171819L = [\"ZLW1\",\"ZLW2\",\"ZLW3\",\"ZLW4\",\"ZLW5\",\"ZLW6\"]print(L[0:4])print(L[-1:])print(L[-3:-1])#前二 跟后二print(L[:2])print(L[-2:])#前面5,每隔2个取一个print(L[:5:2])#所有数，每5个取一个print(L[::2])#甚至什么都不写，只写[:]就可以原样复制一个list：#tupleT = (1,2,3,4,5,6,7,8,9)print(T[::2])#String也可以切片print(\"abcdefghijklmn\"[:10])print(\"abcdefghijklmn\"[-10:])print(\"abcdefghijklmn\"[::2])迭代list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代123456789101112131415d = {\"a\":123,\"b\":345,\"c\":678}for k,values in d.items(): # d.values() d.items() print(k,values)#使用for循环时,只要作用于一个可迭代对象,for循环就可以正常运行.#collections模块的Iterable类型判断 还可以判断其他类型 isinstance(x, str)from collections.abc import Iterable #加.abcprint(isinstance(\"ABCDEF\",Iterable))print(isinstance([1,2,34],Iterable))print(isinstance(1234,Iterable))#Python内置的enumerate函数可以把一个list变成索引-元素对,跟java一样可以用下标访问L = [\"A\",\"B\",\"C\",\"D\"]for x,values in enumerate(L): print(x,values)列表生成式123456789101112131415print(list(range(1,11)))L = []for x in range(1,11): L.append(x * x)print(L)#写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，# 十分有用,for循环后面还可以加上if判断,还可以使用两层循环list = [x * x for x in range(1,11) if x%2==0]print(list)i = 0print([A + B for A in \"ABCDE\" for B in \"FGHIJ\"])L = [\"HOLLE\",\"WORD\",\"PYTHON\"]print([x.lower() for x in L])生成器如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。只要把一个列表生成式的[]改成()，就创建了一个generator：generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。12345678910111213141516171819202122232425262728293031323334353637g = (x * x for x in range(1,11))print(next(g),next(g),next(g),next(g),next(g)) #太麻烦了,用forfor n in g: #之前 print(n)#斐波拉契数列def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a+b #相当于把这两个数组装了成一个tuple t = (b, a + b) # a = t[0] b =t[1] n += 1 return \"done\"fib(20)#可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。#只需要把print(b)改为yield b,如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generatordef fib1(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a+b n += 1 return \"done\"for x in fib1(10): print(x)#generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。# 而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。#在执行过程中，遇到yield就中断，下次又继续执行。#发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的valueprint(\"----------------\")g = fib1(10)while True: try: print(next(g)) except StopIteration as e: print(\"StopIteration!!\",e.value) break迭代器可以直接作用于for循环的对象统称为可迭代对象：Iterable。（String,list,tuple,dict,set）,Iterable变成Iterator可以使用iter()函数：可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象：1234567891011print(isinstance((x * x for x in range(10)),Iterable))print(isinstance(123,Iterable))L = iter([1,2,3,4,5])print(next(L))#S = [1,2,3,4,5]#print(next(S))#这样会报错 TypeError: 'list' object is not an iterator 不是迭代器对象#Iterator甚至可以表示一个无限大的数据流,同样也是堕性的","link":"/2019/12/13/Python-入门篇3/"},{"title":"Python-入门篇4","text":"这部分是关于函数式编程,函数式编程关心数据的映射,命令式编程关心解决问题的步骤函数本身也可以赋值给变量,即：变量可以指向函数。函数名其实就是指向函数的变量！既然变量可以指向函数,函数的参数能接收变量,那么一个函数就可以接收另一个函数作为参数,这种函数就称之为高阶函数。函数式编程就是指这种高度抽象的编程范式。map()map()函数接收两个参数,一个是函数,一个是Iterable,map将传入的函数依次作用到序列的每个元素,并把结果作为新的Iterator返回。1234567def f(x): return x * xzzz = map(f,[1,2,3,4,5,6,7])for x in zzz: print(x)z= list(map(str,[1,2,3,4,5,6,7]))print(z)reduce (跟java8中的reduce相似)123456from functools import reducedef f1(x,x1): #第一个参数是之前累积的数(初始值是第一个元素),第二个是下一个跟数 return x * 10 + x1zlw = reduce(f1,[1,2,3,4,5,6]) # f1这个函数必须接收两个参数,也可以用lambda表达式来print(zlw)print(reduce(lambda x1 ,x2: x1 *100 +x2,[1,2,3,4,5,6,7]))filter()函数用于过滤序列.跟java8 stream 很相似filter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果,需要用list()函数获得所有结果并返回list。1print(list(filter(lambda n: n%2==0,list(range(1,21)))))sorted()排序函数key函数返回的结果进行排序sorted(迭代对象,key函数,reverse=True反向排序)12345678print(sorted([1,65,23,91,-1,48,-99]))print(sorted([1,65,23,91,-1,48,-99],key=abs))print(sorted([\"Zlw\",\"restore\",\"Reputation\",\"abc\"],key=str.lower))print(sorted([1,65,23,91,-1,48,-99],key=abs,reverse=True))L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def t1(L): return L[1];print(sorted(L,key=t1,reverse=True))返回函数123456789101112131415def sum(*args): ax = 0 for x in args: ax = ax + x return axprint(sum(1,2,3,4,5,6,7,8,9))def lazy(*args): def sum(): ax = 0 for x in args: ax = ax + x return ax return sumprint(lazy(1,2,3,4,5,6,7,8,9)())我们在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数sum时,相关参数和变量都保存在返回的函数中,这种称为“闭包（Closure）”的程序.【注】返回的函数并没有立刻执行,而是直到调用了f()才执行闭包闭包：如果在一个内部函数里对外部函数（不是在全局作用域）的变量进行引用,内部函数就被认为是闭包。闭包产生条件1.必须包含一个嵌套函数2.嵌套函数必须引用封闭函数中定义的值（自由变量）3.封闭函数必须返回嵌套函数1234567891011121314def count(): fs = [] for x in range(1,4): def f(): return x * x fs.append(f) return fsf1, f2, f3 = count()print(f1())print(f2())print(f3())#返回函数不要引用任何循环变量,或者后续会发生变化的变量。#因为调用count()方法for循环了三次1-&gt;2-&gt;3,i的值为三,但内嵌的函数并没执行.#等到3个函数都返回时,它们所引用的变量i已经变成了3,因此最终结果为9。匿名函数关键字lambda表示匿名函数,冒号前面的x表示函数参数。不用写return,返回值就是该表达式的结果。装饰器 python装饰器（fuctional decorators）就是用于拓展原来函数功能的一种函数,目的是在不改变原函数名(或类名)的情况下给函数增加新的功能。在函数调用前后自动打印日志,但又不希望修改f()函数的定义这种在代码运行期间动态增加功能的方式,称之为“装饰器”（Decorator）123456789101112131415161718192021222324252627282930313233343536373839404142def log(f1): def wrapper(a): print(\"call %s()\" % f1.__name__) return f1(a) return wrapper@logdef f1(x): return x * xprint(f1(10),f1.__name__)#1.带有固定参数的装饰器#def wrapper(a):#2.无固定参数的装饰器#def wrapper(*args, **kwargs):#3.使用多个装饰器,装饰一个函数（套娃）#import functoolsdef log2(zlw1):# @functools.wraps(zlw1) def wrapper(*args, **kwargs): print(\"call %s() \" % zlw1.__name__) return zlw1(*args, **kwargs) return wrapperdef logzlw(text): def log3(zlw1): def wrapper(*args, **kwargs): print(\"x是百位,y是十位,z是个位 %s\" %text) return zlw1(*args, **kwargs) return wrapper return log3@log2@logzlw(\"zlwzlwzlw\")def zlw1(x,y,z): return x * 100 + y * 10 + z# log2(log3(zlw(9,8,7)))print(zlw1(9,8,7),zlw1.__name__)#由于log()是一个decorator,返回一个函数,所以,原来的now()函数仍然存在#只是现在同名的now变量指向了新的函数,于是调用now()将执行新函数,即在log()函数中返回的wrapper()函数。偏函数import functoolsint8 = functools.partial(int,base=8) #八进制转10print(int8(“123124”))int2 = functools.partial(int,base=2)#二进制转10print(int2(“111111111111111”))","link":"/2019/12/14/Python-入门篇4/"},{"title":"Python-入门篇5","text":"这部分主要是对于Python的面向对象编程的描述和一部分模块知识的梳理.模块title:Hello.py123456789101112131415161718192021222324252627#!/usr/bin/env python3 #可以让这个文件直接在Unix/Linux/Mac上运行#-*- coding: utf-8 -*- #表示该文件本身使用标准UTF-8编码\"this is test\" #表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；__author__ = \"zlw\" #作者import sysclass dog: def private_1(name): return 'Hello, %s' % name def private_2(name): return 'Hi, %s' % name def __test2(self): print(\"我是私有方法,只有本模块才调用\") def test3(self): print(\"我是test3\") def __test4(self): print(\"我是test4\")#当该模块被直接执行时，条件成立，执行指定的入口模块代码，# 否则什么也不做。就相当于手动给py模块指定一个main函数一样，# 如果未指定直接运行py模块会从上到下依次执行。#if __name__=='__main__':# test1()以下是调用上面编写的模块:title:test.py12345678910import Helloprint(\"我是模块B\")Hello.dog.private_1(\"zlw\")Hello.dog.test3(1)#__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。#_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *#__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。#foo:就是public方法面向对象编程类紧接着是(object)，表示该类是从哪个类继承下来的，如果没有合适的继承类，就使用object类，1234567891011121314151617181920212223242526272829303132333435363738394041class Student(object): #创建实例的时候，就把name，score等属性绑上去 #注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此， # 在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 #除此之外，类的方法和普通函数没有什么区别 def __init__(self,name,score): self.__name = name self.__score = score def printScore(self): print(\"name=%s,score=%s\" %(self.__name,self.__score)) def get_name(self): return self.__name def get_score(self): return self.__score def set_name(self,name): self.__name = name def set_score(self,score): self.__score = scorea = Student(\"zlw\",100)#绑定属性print(a)# print(a.name,a.score)#数据封装 这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。a.printScore()#在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private）print(a.get_name(),a.get_score())a.set_name(\"zlwzlwzlw\")a.set_score(11111)print(a.get_name(),a.get_score())#在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的# ，是特殊变量，特殊变量是可以直接访问的，#外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！# 内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给a新增了一个__name变量。a.__name = \"zzzzz\"print(a.__name)print(a.get_name())继承和多态1234567891011121314151617181920212223242526272829303132333435class Animal(object): def run(self): print(\"This is Animal\")#子类的run()覆盖了父类的run()class Dog(Animal): def run(self): # print(\"This is Dog\")class Cat(Animal): def run(self): print(\"This is Cat\")Dog().run()Cat().run()#当我们定义一个class的时候，我们实际上就定义了一种数据类型。# 我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：a = list()b = Animal()c = Dog()print(isinstance(a,list),isinstance(b,Animal),isinstance(c,Dog))# 因为Dog是是从Animal继承下来的, dog本是Animal的一种,但Animal不都是dogprint(isinstance(c,Animal))a = Animal()print(isinstance(a,Dog))#对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。#对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：def Timer(object): def run(): print(\"stars!\")#这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。#Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。判断对象类型使用type()函数,判断一个对象是否是函数123456789101112131415161718192021222324252627282930313233343536373839404142434445print(type(123))print(type(a))print(type(c))print(\"---------------\")#types模块中定义的常量,import typesprint(type(a.run())==types.FunctionType)print(type(lambda x,y:x * y)==types.LambdaType)print(type(x*x for x in range(10))==types.GeneratorType)#isinstanceprint(isinstance([1,2,3,4,5],(list,tuple)))#dir() 获得一个对象的所有属性和方法,返回一个包含字符串的listlista = dir(c)#for x in lista:# print(x)#获得指定的属性 getattr() setattr() hasattr()class Myobject(): def __init__(self): self.x = 9 def power(self): return self.x * self.xa1 = Myobject();# self.__x 则访问不了print(getattr(a1,\"x\"))print(setattr(a1,\"zlw\",\"zlwzlw\"))print(hasattr(a1,\"zlw\"))print(getattr(a1,\"zlw\"))print(a1.x,a1.zlw)# AttributeError: 'Myobject' object has no attribute 'y'# print(getattr(a1,\"y\"))print(getattr(a1,\"power\")())class Student1(): name = \"zlwzlw\" #可以直接在class中定义属性，这种属性是类属性，归Student1类所有 #这个属性虽然归类所有，但类的所有实例都可以访问到a = Student1();print(a.name)b = Student1();print(b.name)","link":"/2019/12/15/Python-入门篇5/"},{"title":"Python-入门篇7","text":"这一部分主要是关于Python的错误、调试很测试,内容偏少try:…except…finally…123456789101112131415161718192021222324252627282930313233343536try: print(\"try...\") a = 10 / int(\"A\") # int(\"A\") 0 print(\"value=\",a)except ValueError as e1: print(\"except1...\") print(\"error=\",e1)except ZeroDivisionError as e2: print(\"except2...\") print(\"error=\",e2)else: print(\"no error!\")finally: print(\"finally...\")#Python的错误是class,所有的错误类型都继承自BaseException,它不但捕获该类型的错误,还把其子类也“一网打尽”.#https://docs.python.org/3/library/exceptions.html#exception-hierarchyprint(\"-------------\")#好处之一就是可以跨越多层调用,# 比如函数main()调用f1(),f1()调用f2(),结果f2()出错了,这时,只要main()捕获到了,就可以层层向下查出问题import loggingdef f2(s): return 10 / int(s)def f1(s): return f2(s) * 2def main(): try: f1(\"a\") except Exception as e: logging.exception(e) print(\"error=\",e) finally: print(\"finally\")main()调用栈出错的时候,一定要分析错误的调用栈信息,才能定位错误的位置.1234567891011121314def main1(): f1(\"a\")main1()#Traceback (most recent call last): 告诉我们这是错误的跟踪信息.# File \"D:/PythonWork/HelloPython/errorTest.py\", line 40, in &lt;module&gt;# main1()# File \"D:/PythonWork/HelloPython/errorTest.py\", line 38, in main1# f1(\"a\")# File \"D:/PythonWork/HelloPython/errorTest.py\", line 24, in f1# return f2(s) * 2# File \"D:/PythonWork/HelloPython/errorTest.py\", line 21, in f2# return 10 / int(s)#ValueError: invalid literal for int() with base 10: 'a'记录错误因为出现了错误程序停止了下了,我们把错误信息打印之后输出,同时让程序继续执行Python内置的logging模块可以非常容易地记录错误信息12main()print(\"没想到吧！,我还在执行\")抛出错误如果要抛出错误,首先根据需要,可以定义一个错误的class,选择好继承关系,然后,用raise语句抛出一个错误的实例12345678class F1Error(ZeroDivisionError): logging.exception(ZeroDivisionError)def f1(i): if i==0: raise F1Error(\"this is value=%s\" %i) return 10 /i#print(f1(0))调试1.用print()打印可能出现错误的地方,进而进行分析2.凡是用print()来辅助查看的地方,都可以用断言（assert）来替代启动Python解释器时可以用-O参数来关闭assert,关闭后,你可以把所有的assert语句当成pass来看.1234def f3(i): assert i != 0,\"this is zero!!\" #为true继续往下执行 AssertionError: this is zero!! return 10 /iprint(f3(0))3.logging把print()替换为logging是第3种方式,和assert比,logging不会抛出错误,而且可以输出到文件：print(“——-“)1234def f4(i): logging.info(\"n = %d\" % i) return 10 / if4(0)4.pdb省略5.IDE打断点(最实用的)","link":"/2019/12/15/Python-入门篇7/"},{"title":"Python-入门篇6","text":"这一部分是关于Python面向对象高级编程,有一部分不是很理解,有时间的话就补充一下内容.__slots__的用法1234567891011121314151617181920212223242526class Student(): __slots__ = (\"name\",\"score\",\"age\",\"set_score\") #限制实例的属性,不允许随便动态绑定 #仅对当前类有效,对子类不起作用 #AttributeError: 'Student' object has no attribute 'zzz'#绑定属性a = Student()a.name = \"zlw\"print(a.name)#a.zzz = \"zzz\" 被限制了,无法绑定#绑定方法from types import MethodTypedef set_score(self,score): self.score = scorea.set_score = MethodType(set_score,a)a.set_score(100)print(a.score)# AttributeError: 'Student' object has no attribute 'set_score'#b = Student()#b.set_score(12)#print(b.score)# 直接改Class绑定方法Student.set_score = set_scoreb = Student()b.set_score(12)print(b.score)@property123456789101112#一般情况class Student1(): def get_name(self): return self._name def set_name(self,value): if not isinstance(value,str): raise ValueError(\"name must be an String!\") self._name = values1 = Student1();s1.set_name(\"123\")print(s1.get_name())上面的调用方法又略显复杂,没有直接用属性这么直接简单.有没有既能检查参数,又可以用类似属性这样简单的方式来访问类的变量呢？1234567891011121314#修改之后的class Student2(): @property #把一个getter方法变成属性 def name(self): return self._name @name.setter #@property本身又创建了另一个装饰器@name.setter,负责把一个setter方法变成属性赋值 def name(self,value): if not isinstance(value,str): raise ValueError(\"name must be an String!\") self._name = values2 = Student2()s2.name = \"zlw\"print(s2.name)多重继承比如,让Dog除了继承自Animal外,再同时继承Canid.这种设计通常称之为MixIn.MixIn的目的就是给一个类增加多个功能,这样,在设计类的时候,我们优先考虑通过多重继承来组合多个MixIn的功能,而不是设计多层次的复杂的继承关系.123456789101112131415161718192021222324class Animal(): def Animal(self): print(\"this is Animal\")class Canid(): def Canid(self): print(\"this is Canid\")class Feline(): def Feline(self): print(\"this is Feline\")class Dog(Animal,Canid): def __init__(self,name): self__name = name def __str__(self): #print 输出显示 return \"this is __str__ \" def __repr__(self): #交互式的时候直接输出 d 显示 return \"this is __repr__\"# __str__ == __repr__()#__str__()返回用户看到的字符串# __repr__()返回程序开发者看到的字符串,也就是说,__repr__()是为调试服务的.d = Dog(\"zlw\")print(d)__iter__用法如果一个类想被用于for … in循环,类似list或tuple那样,就必须实现一个__iter__()方法,该方法返回一个迭代对象,然后,Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值,直到遇到StopIteration错误时退出循环.12345678910111213class Fib(): def __init__(self): self.x1 ,self.x2 = 0,1 def __iter__(self): return self def __next__(self): self.x1 ,self.x2 = self.x2 ,self.x1+self.x2 if(self.x1 &gt; 3000): raise StopIteration(\"\") return self.x1for x in Fib(): print(x)__getitem__省略需要的时候在看__getattr__用法当调用不存在的属性时,比如score,Python解释器会试图调用__getattr__(self, ‘score’)来尝试获得属性,这样就避免了查找不到属性时报错12345678910111213class Student3(): def __init__(self,name): self.__name = name def __getattr__(self, attr): if attr ==\"score\": #要让class只响应特定的几个属性,我们就要按照约定,抛出AttributeError的错误 return 100 raise AttributeError(\"!!!!\") def __call__(self, *args, **kwargs): print(\"this is call\")s = Student3(\"zlw\");print(s.score)#非常方便地调用API了__call__用法就可以直接对实例进行调用.当我们调用实例方法时,我们用instance.method()来调用.通过callable()函数,我们就可以判断一个对象是否是“可调用”对象.print(s())print(callable(s))使用枚举类from enum import EnumMonth = Enum(‘Month’, (‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘Jun’, ‘Jul’, ‘Aug’, ‘Sep’, ‘Oct’, ‘Nov’, ‘Dec’))省略,需要的时候在去复习type()函数可以查看一个类型或变量的类型,Hello是一个class,它的类型就是type,而h是一个实例,它的类型就是class Hello.class的定义是运行时动态创建的,而创建class的方法就是使用type()函数.要创建一个class对象,type()函数依次传入3个参数：1.class的名称；2.继承的父类集合,注意Python支持多重继承,如果只有一个父类,别忘了tuple的单元素写法；3.class的方法名称与函数绑定,这里我们把函数fn绑定到方法名hello上.1234567def f1(self,name=\"zlw\"): print(\"Hello %s\" %name)Hello = type(\"Hello\",(object,),dict(hello=f1))h = Hello()h.hello()print(type(Hello))print(type(h))metaclass(元类)省略 有需要在补充","link":"/2019/12/15/Python-入门篇6/"},{"title":"Python-入门篇9","text":"这部分是关于多线程与多进程之间的知识,再次之前必须了解操作系统的相关知识,因为Python是在系统调用进行了封装.在Linux中,创造新进程的方法只有一个，就是fork(),其他的函数库看似可以创建进程,其实内部调用了fork(),普通的函数:调用一次,返回一次.fork():调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次.1.在父进程中，fork返回新创建子进程的进程ID；2.在子进程中，fork返回0；3.如果出现错误，fork返回一个负值；12345import osprint(os.getpid())#子进程只需要调用getppid()就可以拿到父进程的ID。pid = os.fork()","link":"/2019/12/27/Python-入门篇9/"},{"title":"Python-爬虫篇3","text":"Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时,以下是官方API👇:https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#我们先根据HTML字符串练习一下bs4,字符串如下:12345678910111213141516171819from bs4 import BeautifulSouphtml = '''&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt;and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;'''# 创建BeautifulSoup对象soup = BeautifulSoup(html, \"lxml\")一.使用Tag对象按照文档结构获取数据123456789z = soup.title.stringz = soup.title.name# 默认获取第一个pz = soup.p.string# 获取p里面的class属性z = soup.p['class']# 获取p标签的父类的姓名z = soup.p.parent.nameprint(z)二.搜索12345678910111213# 查询满足条件的一个元素f = soup.find(id=\"link3\")[\"class\"]f = soup.find(id=\"link3\").string# 查询满足条件的所有元素f = soup.find_all(\"a\") # 总返回一个列表,如果没有找到则返回空# 属性参数attributes：可以传一个用Python字典封装起来的某个标签的若干个属性及与其对应的属性值做属性参数attributes。# f = soup.findAll(\"\",{\"class\":{\"story\",\"title\"}})# 文本参数text:用标签的文本内容去匹配，而不是用标签的属性去匹配。f = soup.findAll(\"\", text=\"Tillie\")f = soup.findAll(\"\", id=\"link2\")for x in f: print(x)三.css选择器123456z = soup.select(\"a\") # 通过标签名字 #listz = soup.select(\".sister\") # 通过class选择器z = soup.select(\"#link1 #link2 #link3\") # 通id选择器z = soup.select(\"p &gt; #link1\")for x in z: print(x.string)1234567891011121314151617181920212223242526272829303132333435363738import requests,jsonfrom bs4 import BeautifulSoup# urlurl = \"https://www.lmonkey.com/t\"# 请求头headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"}req = requests.get(url=url, headers=headers)# if req.status_code == 200:# with open(r\"./yqpy.html\", \"w\", encoding='UTF-8') as fp:# fp.write(req.text)# a = open(\"./yqpy.html\",\"r\",encoding=\"utf-8\").read()# 解析数据soup = BeautifulSoup(req.text, \"lxml\") # as = soup.find_all(\"div\", class_=\"list-group-item list-group-item-action p-06\")i = 0data = []for x in s: i += 1 title = x.find(\"div\", class_=\"topic_title\") if title: # print(title.text.split(\"\\n\")[0]) # print(x.a[\"href\"]) # print(x.strong.a.string) # print(x.p.span[\"title\"]) data1 = {\"title\": title.text.split(\"\\n\")[0], \"href\": x.a[\"href\"], \"author\": x.strong.a.string, \"date\": x.p.span[\"title\"]} data.append(data1)print(data)with open(\"./yqpy.josn\", \"w\") as fp: json.dump(data,fp)1234567891011121314151617181920212223242526272829303132333435363738import revar = \"wqerqwcasqweqwe123123qweqweqweqwef3ert\"zlw = \"\\d\"# (匹配规则,字符串),返回listz = re.findall(zlw, var)# (匹配规则,字符串),返回iterator# s = re.finditer(zlw,var)# for x in s:# print(x.group(),x.span())#搜索,在替换# zzz = re.sub(\"\\d\",\"ZLWZLW\",var)# print(zzz)# print(z)#将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 以及其他如下描述。z = re.compile(\"123\")s = z.findall(var)print(s)# print(s.group(1))# 正则对象# 搜索整个string寻找第一个匹配的位置,返回一个匹配对象,如果没有匹配就返回None# (String,开始的位置索引,默认值是0)z = re.search(\"qer\", var)# 如果String的开始位置能够找到这个正则样式的任意个匹配,返回一个匹配对象,如果没有匹配就返回Nones = re.match(\"wqer\", var)# rearch() 跟 match() 区别''' +从字符串开始到结尾进行搜索匹配 +要么开始位置符合,否则不符合+匹配成功返回Match对象,否则None +匹配成功返回Match对象,否则None +group()返回元素 +group()返回元素+span()返回下标区间 +span()返回下标区间'''print(z.group())print(s.group())用re模块爬虫的例子12345678910111213141516171819202122232425262728293031323334353637383940import re,requestsfrom openpyxl import Workbookfrom openpyxl import load_workbook# 写入Exceldef writer(data): workbook2 = load_workbook(\"./zlw123123.xlsx\") ws = workbook2.active ws.append([U'标题', U'作者', U'时间', U'地址']) print(data) for i in range(0, len(data)): data1 = [data[i][0],data[i][1],data[i][2],data[i][3]] print(data1) ws.append(data1) i += 1 workbook2.save(\"./zlw123123.xlsx\")#urlurl = \"https://www.lmonkey.com/ask\"# 请求头headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"}req = requests.get(url=url,headers=headers)print(req.status_code)if req.status_code == 200: str1 = '&lt;div class=\"topic_title mb-0 lh-180 ml-n2\"&gt;(.*?)&lt;small' title = re.findall(str1, req.text) str1 = '&lt;strong&gt;(.*?)&lt;/strong&gt;' aouther = re.findall(str1,req.text) str1 = '&lt;span data-toggle=\"tooltip\" data-placement=\"top\" title=\"(.*?)\"&gt;' date = re.findall(str1, req.text) str1 = '&lt;a href=\"(https://www.lmonkey.com/ask/\\d+)\" target=\"_blank\"&gt;' url1 = re.findall(str1, req.text) arrayList = list(zip(title,aouther,date,url1)) print(arrayList[0][0],len(arrayList)) writer(arrayList)","link":"/2019/12/18/Python-爬虫篇3/"},{"title":"Python-爬虫篇4","text":"openpyxl模块,关于Excel的读写操作,常用的关于Excel的操作的模块如一下表格:\\XlsxWriterxlrdxlwtopenpyxl介绍可以创建XLSX文件用来读取xls文件，是python-excel的三大模块用来写xls文件，是python-excal的三大模块可以读写XLSX、XLSM文件读×√×√写√×√√.xls×√√×.xlsx√××√大文件√××√123456789101112131415161718192021222324252627282930313233343536from openpyxl import Workbook#from openpyxl import load_workbook#实例化workbook = Workbook()#激活 WorkSheetws = workbook.active#打开已经存在的文件#workbook2 = load_workbook(\"./zlwzlw.xlsx\")#写的方式#一.直接行号加列号写入ws[\"A1\"] = 123123#二.可以附加行，从第一列开始附加(从最下方空白处，最左开始)(可以输入多行)ws.append([1,2,3,4,5,6])#创建表 后面可以加参数,默认是插入到最后一位,如果为0,则插入在第一位zs = workbook.create_sheet(\"zlwSheet\")#选择表ws = workbook[\"zlwSheet\"]ws.append([\"ZLW\",\"ZLWZLW\"])ws.append([1,2,3,4,5,6,7])#查看表 一个数组print(workbook.sheetnames)#访问单元格#单一单元格访问s = ws[\"A1\"]print(s)# 保存文件workbook.save(\"./zlwzlw.xlsx\")一个利用openpyxl模块将分页的数据保存在Excel中的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import requestsfrom bs4 import BeautifulSoupimport timefrom openpyxl import Workbookfrom openpyxl import load_workbook# 请求页面def getHtml(url): # 请求头 headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\" } req = requests.get(url=url, headers=headers) if req.status_code == 200: return req.text else: return False# 解析数据def interpretData(html): soup = BeautifulSoup(html, \"lxml\") # a s = soup.find_all(\"div\", class_=\"list-group-item list-group-item-action p-06\") data = [] i = 0 for x in s: i += 1 title = x.find(\"div\", class_=\"topic_title\") if title: data1 = {\"title\": title.text.split(\"\\n\")[0], \"href\": x.a[\"href\"], \"author\": x.strong.a.string, \"date\": x.p.span[\"title\"]} data.append(data1) return data# 写入Exceldef writer(data, num): workbook2 = load_workbook(\"./zlw.xlsx\") ws = workbook2.active if num == 1: ws.append([U'标题', U'地址', U'作者', U'时间']) for i in range(1, len(data) + 1): data1 = [data[i - 1].get(\"title\"), data[i - 1].get(\"href\"), data[i - 1].get(\"author\"), data[i - 1].get(\"date\")] ws.append(data1) i += 1 workbook2.save(\"./zlw.xlsx\")# 主函数def main(num): # url拼之后分页请求 url = f\"https://www.lmonkey.com/t?page={num}\" # 发送请求 html = getHtml(url) # 解析数据 data = interpretData(html) # 写入Excel writer(data, num)if __name__ == '__main__': for x in range(1, 11): print(f\"我是第{x}页\") main(x) # 设置请求间隙给访问的服务器减少压力 time.sleep(1)","link":"/2019/12/22/Python-爬虫篇4/"},{"title":"Python-爬虫篇1","text":"网络爬虫(又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者)是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。其实通俗的讲就是通过程序去获取web页面上自己想要的数据，也就是自动抓取数据爬虫流程步骤1.确定需求2.寻找需求3.发送请求4.解析数据5.储存数据requests模块因为我是安装的Anaconda3,里面已经有了requests,就不需要在去安装了,在之前流程之中,我以发送请求开始写,说到请求,那要回顾一下http最常用的两种请求方式:请求方式getpost参数位置url中request body参数长度有限制无限制参数编码ASCII编码无限制后退/刷新不重复提交，回退无害重复提交，回退有害安全性参数暴露，不安全安全缓存可以缓存不可以缓存书签可以收藏为书签不可收藏为书签历史参数保留在浏览器历史不保留在浏览器历史请求包个数1个 http header+data两个 先http header，再dataget()请求的例子123456789101112131415161718192021222324252627282930#导入模块import requests#定义请求头信息 有些网站会拒绝Python程序,需要自己定义请求头,伪装信息,以下有个个不同的浏览器的User-Agent#https://www.cnblogs.com/zrmw/p/9332801.htmlheaders = { 'User-Agent':\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"}#发请求#url = \"https://www.baidu.com/\"url = \"https://www.xicidaili.com/\"req = requests.get(url,headers=headers)req.encoding=\"utf-8\" #如果不设置编码的话,text中的中文字符是乱码#获得请求print(req) #一个Response对象 &lt;Response [200]&gt; 里面有很多信息print(req.status_code) #请求状态码print(req.url) #请求路径print(req.text) #获得的响应内容print(req.content.decode(\"utf-8\")) #二进制文本流,转化成utf-8的字符串(content返回的是bytes型的数据)print(req.headers) #响应头文件print(req.request.headers) #请求头文件print(req.encoding) #Response对象的编码(Requests库的自身编码为: r.encoding = ‘ISO-8859-1’ )# 请求状态码为 200 就写入到本地目录下的test1.html中if req.status_code==200: with open(r\"./test1.html\",\"w\",encoding='UTF-8') as fp: fp.write(req.text)post()请求的例子123456789101112131415161718192021222324252627import requestsurl = \"https://fanyi.baidu.com/sug\"headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"}data = {'kw':'删除'}req = requests.post(url=url,headers=headers,data=data)#req.encoding = \"utf-8\"print(req.status_code)print(req.text)print(req.json())if req.status_code == 200: print(\"请求成功！\") data = req.json() if data[\"errno\"] == 0: print(\"数据无异常\") if data[\"data\"] == []: print(\"有问题\") else: print(data[\"data\"][0][\"k\"]) print(data[\"data\"][0][\"v\"].split(\";\")[-2].replace(\" \", \"\"))","link":"/2019/12/16/Python-爬虫篇1/"},{"title":"Python-爬虫篇2","text":"我们现在考虑跟复杂的情况,网站会检查登录状态,才允许用户访问一些特定的网页,比如说：你想进入个人信息页面,那么你没有登录,怎么会有个人信息,然后你输入账户密码或者浏览器会检查你之前是否有记住密码然后直接登录(因为http协议无法保证状态)请求方式CookieSession存放位置浏览器端服务器端安全性低高存储限制4KB(不同浏览器不一样)无限制还有更多的网上查.我以http://www.zmz2019.com这个网址作为例子(相比较简单)来梳理一下登录的步骤:1.因为现在大多数网站的登录都是ajax做的,在登录页面F12进入开发者模式,选项卡现在Network模块.2.网站用户名,密码随便输入,之前Network里面的Name列表发生改变,寻找登录那给请求如图下:3.复制该请求的地址,把form Data里面的选项写成字典(Map)4.post请求5.get请求123456789101112131415161718192021222324252627282930import requestsheaders = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"}# 登录请求url = \"http://www.zmz2019.com/User/Login/ajaxLogin\"# 个人信息url1 = \"http://www.zmz2019.com/User/user\"#requests库的session对象能够帮我们跨请求保持某些参数，也会在同一个session实例发出的所有请求之间保持cookies。#创建一个session对象req = requests.session()#form data 列表参数data = { \"account\": \"985686843@qq.com\", \"password\": \"WEIwei1998\", \"remember\": \"1\", \"url_back\": \"http://www.zmz2019.com/User/user\"}req1 = req.post(url=url, headers=headers, data=data)req1.encoding = \"utf-8\"if req1.status_code == 200: req2 = req.get(url=url1, headers=headers) # req2.encoding = \"utf-8\" with open(r\"./rr.html\", \"w\", encoding='UTF-8') as fp: fp.write(req2.text)Xpath解析数据XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。详细的教程点击👇链接:https://www.w3school.com.cn/xpath/index.aspetree解析HTML的两种方式:1.读取一个html字符串解析2.读取一个html文件解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from lxml import etreetxt = '''&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;link href=\"http://js.jstucdn.com/style/layout.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;link href=\"http://js.jstucdn.com/style/user.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;script src=\"http://js.jstucdn.com/js/jquery-1.7.1.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;script src=\"http://js.jstucdn.com/js/global.js?v=20160922\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;title&gt;我的首页&lt;/title&gt;&lt;meta name=\"keywords\" content=\"我的首页\"&gt;&lt;meta name=\"description\" content=\"我的首页\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"menu-box\"&gt; &lt;ul class=\"w\"&gt; &lt;li&gt;&lt;a href=\"/\" class=\"w_index\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"translate\"&gt;&lt;a href=\"/translate\"&gt;翻译任务&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"article\"&gt;&lt;a href=\"/article\"&gt;资讯&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"subtitle\"&gt;&lt;a href=\"/subtitle\"&gt;字幕&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"resource\"&gt;&lt;a href=\"/resourcelist\"&gt;影视库&lt;/a&gt;&lt;/li&gt; &lt;li channel='top'&gt;&lt;a href=\"/html/top/week.html\"&gt;排行榜&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"today\"&gt;&lt;a href=\"/today\"&gt;今日&lt;/a&gt;&lt;/li&gt; &lt;li channel='schedule'&gt;&lt;a href=\"/tv/schedule\"&gt;播出表&lt;/a&gt;&lt;/li&gt; &lt;li channel=\"help\"&gt;&lt;a href=\"/help\"&gt;求档&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/Announcement\"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://allyingshi.com/fanyi/index.html\"&gt;合作洽谈&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'''html = etree.HTML(text=txt)print(html)print(html.xpath(\"/html/body/div/ul/li/a/text()\"))#在xpath中下标重1开始print(html.xpath(\"/html/body/div/ul/li[1]/a/text()\"))html1 = etree.parse(\"./rr.html\",etree.HTMLParser())print(html1.xpath(\"/html/body/div/div/ul/li/a/text()\"))h = html1.xpath('//div[@class=\"menu-box\"]//li/a/text()')print(html1.xpath('//div[@class=\"menu-box\"]//li/a/text()'))h1 = html1.xpath('//div[@class=\"menu-box\"]//li/a/@href')print(html1.xpath('//div[@class=\"menu-box\"]//li/a/@href'))res = list(zip(h,h1))print(res)12345678910111213141516171819202122232425262728293031323334353637383940414243444546from lxml import etreeimport requests,jsonclass Test(): url = \"https://www.lmonkey.com/essence\" # 请求头 headers = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\" } data = [] #初始化 def __init__(self): req = requests.get(url=self.url,headers=self.headers) print(req.status_code) if req.status_code==200: with open(r\"./test1.html\",\"w\",encoding='UTF-8') as fp: fp.write(req.text) if self.getHtml(): self.writeJson() #解析网页 def getHtml(self): html = etree.parse(\"./test1.html\",etree.HTMLParser()) authours = html.xpath('//div[contains(@class,\"list-group-item list-group-item-action\")]//strong/a/text()') title = html.xpath('//div[contains(@class,\"list-group-item list-group-item-action\")]//div[contains(@class,\"flex-fill col-12\")]/a[1]/div/text()') link = html.xpath('//div[contains(@class,\"list-group-item list-group-item-action\")]//div[contains(@class,\"flex-fill col-12\")]/a[1]/@href') #zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。 #数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。 #如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 #res = list(zip(authours,title,link)) #print(res) # print(\"--------\") # print(len(authours)) # print(len(title)) # print(len(link)) for i in range(0,len(authours)): res = {'authours':authours[i],'title':title[i],'link':link[i]} self.data.append(res) return True #写入文件 def writeJson(self): with open(\"./rr.json\",\"w\") as fp: json.dump(self.data,fp)Test()","link":"/2019/12/17/Python-爬虫篇2/"},{"title":"Redis 笔记1","text":"Redis 是完全开源免费的,遵守BSD协议,是一个高性能(NoSQL)的key-value数据库NOSQL 与 SQL数据与数据之间没有关联关系表与表之间建立关联关系NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战,尤其是大数据应用的难题.特点1.性能极高 读写速度快2.丰富的数据类型3.原子性4.丰富的特性安装下载wget http://download.redis.io/releases/redis-4.0.6.tar.gz解压tar -zxvfyum安装gcc依赖yum install gcc跳转到redis解压目录下cd redis-4.0.6编译安装make MALLOC=libccd src &amp;&amp; make installredis.conf 配置文件详解指令意思daemonize noRedis默认不是以守护进程的方式运行,可以通过该配置项修改,使用yes 启用守护进程pidfile /var/run/redis_6379.pidpid 文件的路径port 6379端口号bind 127.0.01绑定主机地址(本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接，)timeout 300客户端闲置多久后关闭连接(0 表示关闭这个功能)loglevel verbose指定日志记录级别 (debug、verbose、notice、warning)logfile stdout日志记录方式,默认标准输出,如果Redis为守护进程方式运行,而这里又配置为日志记录方式为标准输出,则日志发送/dev/nulldatabases 16设置数据库的数量save 900 1 (15分钟内有1个更改)save 300 10 (5分钟内有10个更改)save 60 10000 (60秒内有10000个更改)指定在多长时间内,有多少次更新操作,就将数据同步到数据文件,可以多个条件配合 saverdbcompression yes指定存储本地数据库时是否压缩数据dbfilename dump.rdb指定本地数据库文件名,默认值为 dump.rdb,在bin中dir ./指定本地数据库存放目录requirepass foobared设置Redis连接密码,如果配置了连接密码,客户端在连接Redis 时需要通过AUTH命令提供密码,默认关闭maxclients 128设置同一时间最大客户端连接数:默认无限制maxmemory指定Redis最大内存限制redis作为优秀的中间缓存件,时常会存储大量的数据,即使采取了集群部署来动态扩容,也应该即时的整理内存,维持系统性能(如果数据一直新增,内存很快就会满)有以下两种解决方案:1.为数据设置超时时间,设定内存空间,建议不要超过1G 256-512M2.采用LRU 算法动态将不要的数据删除redis-cli -h host -p port -a password(ip地址) (端口号) (密码)1.断电,非正常关闭,容易丢失数据kill2.正常关闭,数据保存shutdownRedis 常用命令Redis 键 key指令意思DEL key删除key的值dump key序列化给定key,并返回序列化的值exists key检查key 是否存在expire key seconds为给定key 设置过期时间(以秒计)ttl key以秒为单位,返回给定key的剩余生存时间pttl key *(毫秒)以毫秒为单位persist key移除过期时间(永久保持)keys pattern查找所有符合给定模式(pattern) 的key *所有 ?代表一个字符randomkey随机 keyrename key newkey修改key名move key db当前数据库的key移动到给定数据库中type key返回key所储存的值的类型set key value有值就覆盖setnx key value如果key不存在,进行赋值,存在不赋值get key取值getrange key start end取字符串中start 到 end 范围的字符getbit key offset取指定偏移量上的位mget key1 key2…获取一个或者多个keykey 命名规范redis 单个 key 存入512M大小1.key不要太长,不要超过1024字节2.key不要太短,key可读性会降低3.key最好使用统一的命名模式. user:123:password;Hash 命令赋值语法：指令意思HSET KEY FIELD VALUE单个hashHMSET KET FIELD1 VALUE1 [FIELD2 VALUE2]多个hashhmset users uname zlw age 20 address “荆门市”取值语法指令意思HGET KEY FIELD单个HGET KEY FIELD [FIELD1]多个HGEALL key返回hash表中所以字段和值HKEYS KEY获取所有哈希表中的字段HLEN KEY获取hash表中字段长度删除语法指令意思HDEL KEY FIELD1 [FIELD2]删除一个或者多个hash表字段hsetnx key field value只有在字段field不存在,设置哈希字段的值hincrby key field value指定字段的整形值加上增量incrementhincrbyfloat浮点型hexists key field查看hash表中，指定的字段是否存在#redis.clientsjedis2.9.0Redis和spring 整合","link":"/2020/02/26/Redis-笔记1/"},{"title":"SQL 语言 - 基础","text":"基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。[注释]1234## 注释SELECT * FROM mytable -- 注释/*注释1 注释2 */[数据库的创建与使用]12CREATE DATABASE zlwdb;USE zlwdb;[创建表与修改表]1234567891011121314CREATE TABLE mytable( uid INT NOT NULL AUTO_INCREMENT, z1 INT NOT NULL DEFAULT 1, z2 INT VARCHAR(45) NULL, z3 DATE NULL, PRIMARY KEY('id') );}##修改表ALTER TABLE mytableADD z4 CHAR(20);ALTER TABLE mytableDROP COLUMN z4;##删除表DROP TABLE mytable;[插入,更新,删除]1234567891011INSERT INTO mytable(z1,z2) VALUES(va11,val2);## 插入检索出来的数据INSERT INTO mytable1(z1,z2) SELECT z1,z2 FROM mytable2;## 一个表的内容插入到一个新表CREATE TABLE newtable AS SELECT * FROM mytable;UPDATE mytable SET z1 = va11 WHERE uid = 1;DELETE FROM mytable WHERE uid = 1;TRUNCATE TABLE mytable; --也可以清空表，也就是删除所有行[查询]1234567##DISTINCT --去重复，相同的值只会显示一次SELECT DISTINCT z1,z2, FROM mytable;##LIMIT -- 限制返回的行数,可以有两个参数,1.起始行2. 返回的总行数SELECT * FROM mytable LIMIT 5;SELECT * FROM mytable LIMIT 0,5;SELECT * FROM mytable LIMIT 2,3; -- 从第3行到第第5行[排序]12## ASC 升序(默认) DESC 降序SELECT * FROM mytable ORDER BY z1 DESC, z2 ASC;[过滤]1SELECT * FROM mytable WHERE z1 IS NULL;操作符说明=等于单元格单元格&lt; &gt;小于 大于&lt;&gt;!= &lt;=!&gt; &gt;=!&lt;不等于 小于等于 大于等于BETWEEN在两个值之间IS NULL为NULL值AND 和OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。NOT 操作符用于否定一个条件。通配符通配符也是用在过滤语句中，但它只能用于文本字段。% 匹配 &gt;=0 个任意字符；_ 匹配 ==1 个任意字符；[ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。使用 Like 来进行通配符匹配。不要滥用通配符，通配符位于开头处匹配会非常慢。[]1SELECT * FROM mytable WHERE z1 LIKE '[^AB]' --不以 A 和 B 开头的文本[计算字段]12345SELECT z1 * z2 AS xj FROM mytable;##CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，##因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。SELECT CONCAT(TRIM(z1), '(', TRIM(z2), ')') AS concat_zFROM mytable;函数(MYSQL)函数说明(列)AVG()平均值COUNT()行数MAX() MIN()最大值 最小值SUM()和LEFT() RIGHT()左边的字符 右边的字符LOWER() UPPER()转为小写字符 转为大写字符LTRIM() RTRIM()去除左边的空格 去除右边的空格分组分组就是把具有相同的数据值的行放在同一组中。可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。[分组]1234SELECT z1,COUNT(*) AS SUM FROM mytable GROUP BY z1;##GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。##WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。SELECT z1,COUNT(*) AS num FROM mytable WHERE z1 &gt; 2 GROUP BY z1 HAVING num &gt;= 2;分组规定：GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；NULL 的行会单独分为一组；大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型未写完[]1","link":"/2019/10/23/SQL-语言-基础/"},{"title":"java-jvm篇1","text":"jvm的类加载子系统java虚拟机平台上运行非Java语言编写的程序.只关心”字节码”文件.(语言无关性)JVM的整体结构如下图:JVM的架构模型基于栈式架构的特点(HotSpot)1.设计和实现更简单,适用于资源受限的系统.2.避开寄存器的分配难题,使用零地址指令式分配.3.指令流中的指令大部分是零地址指令,其执行过程依赖于操作栈,指令集更小,编译器容易实现.4.不需要硬件支持,可移植性更好,更好实现跨平台.基于寄存器架构的特点1.x86的二进制指令集2.指令集架构完全依赖硬件,移植性差3.性能优秀和执行更高效.4.花费更少的指令去完成一项任务5.有一,二,三地址指令jvm的生命周期1.vm启动是通过引导类加载器(bootstrap class loader)创建一个初始类(inital class)来完成的,这个类是由虚拟机的具体实现指定的.2.vm执行执行一个所谓的java程序的时候,真真正正在执行的是一个叫做Java虚拟机的进程.3.vm退出3.1.正常退出3.2.异常终止3.3.操作系统出现问题终止3.4.某些api的方法退出jvm发展史1.Sun Classic VM (只提供解释器)2.Exact VM3.HotSpot(主流)4.JRockit(专注于服务器端应用,JRockit 是世界上最快的JVM)5.J96.KVM CDC CLDC类加载器子系统类加载器子系统负责从文件系统或者网络中加载Class文件,class文件在文件打开有特定的文件标识.ClassLoader只负责class文件的加载,至于它是否可以运行,则由Execution Engine决定.加载的类信息存放于一块称为方法区的内存空间,除了类的信息外,方法区中还会存放运行时常量池信息,可能还包括字符串面量和数字常量.类的加载过程如下图加载(Loading)1.通过一个类的全限定名获取定义此类的二进制字节流.2.将这个字节流所代表的静态储存结构转化为方法区的运行时的数据结构.3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据访问入口.链接(Linking)验证(verify)目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性.(字节码在文件开头有特定的文件标识.)准备(Perpare)为类变量分配内存并且设置该类变量的默认初始值,零值.不包含final修饰的static,final在编译的时候就会分配,准备阶段会显式初始化.此阶段不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到jvm堆中解析(Resolve)将常量池内的符号引用转换为直接引用的过程.初始化(Initalization)此阶段就是 执行类构造器方法() 的过程.此方法不需要定义,是Javac编译器自动收集类中所有类变量赋值动作和静态代码块中的语句合并而来.构造器方法中指令按语句在源文件中出现的顺序执行.()不同于类的构造器.(父类的()在子类之前执行)虚拟机必须保证一个类的()方法在多线程下被同步加锁.类加载器分类启动类加载器(引导类加载器,bootstrap ClassLoader)这个类加载是C++实现的,不继承自java.lang.ClassLoader,没有父加载器,用来加载java的核心库.用于提供JVM自身需要的类扩展类加载器(Extension ClassLoader)java 语言编写,派生于ClassLoader类,如果用户创建的jar放在次目录下,也会自动由扩展类加载器加载.应用程序类加载器(系统类加载器 AppClassLoader)该类加载是程序中默认的类加载器.ClassLoader#getSystemClassLoader()方法获取该加载器.用户自定义类加载器继承java.lang.ClassLoaderlei,实现自己的类加载器.双亲委派机制工作原理1.如果一个类加载器收到了类加载请求,它并不会自己先去加载,而是把这个请求委托给父类的加载器去执行.2.如果父类加载类还存在其父类加载器,则进一步向上委托,依次递归,请求最终将到达顶层的启动类加载器.3.如果父类加载器可以完成类加载任务,就成功返回,倘若父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,这就是双亲委派机制.优势1.避免类的重复加载2.保护程序安全,防止API被随意篡改java.lang.Stringjava.lang.zlw沙箱安全机制自定义String类,但是在加载自定义string类的时候会使用引导类加载器,而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\\lang\\String.class),报错信息说没有main方法,就是因为加载的是rt.jar包中的Stringlei,这样可以保证对java核心源代码的保护,这就是沙箱安全机制.","link":"/2020/02/04/java-jvm篇1/"},{"title":"java-8 lambda 2","text":"关于函数式接口:1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。1234567@FunctionalInterfacepublic interface MyInterfae { void test(); // java.lang.Object 是所以类的父类 MyInterfae的实现类一点会直接或者间接的继承Object类 toString String toString();}在其他有lambda表达式语言中,lambda表达式的类型是函数,但在java中，Lambda表达式是对象,他们必须依附于一类特别的对象类型————函数式接口(functional interface)外部迭代最传统的方法是用Iterator，当然还以用for i、增强for循环等等。这一类方法叫做外部迭代，意为显式地进行迭代操作，即集合中的元素访问是由一个处于集合外部的东西来控制的，在这里控制着循环的东西就是迭代器。1234List&lt;String&gt; alphabets = Arrays.asList(new String[] { \"a\", \"b\", \"b\", \"d\" });for (String letter : alphabets) { System.out.println(letter.toUpperCase());}内部迭代顾名思义，这种方式的遍历将在集合内部进行，我们不会显式地去控制这个循环。无需关心遍历元素的顺序，我们只需要定义对其中每一个元素进行什么样的操作。注意在这种设定下可能无法直接获取到当前元素的下标。比如JDK8提供的最新的Collection.forEach(…)方法。1alphabets.forEach(System.out::println);Function接口1234567891011121314151617181920212223242526272829303132333435/** * 代表这一个方法，能够接受一个参数，并且返回一个结果 * @since 1.8 */@FunctionalInterfacepublic interface Function&lt;T, R&gt; { /** * 将参数赋予给相应方法 * * @param t * @return */ R apply(T t); /** * 先执行参数(即也是一个Function)的，再执行调用者(同样是一个Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } /** * 先执行调用者，再执行参数，和compose相反。 */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } /** * 返回当前正在执行的方法 */ static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }}[例子]123456789101112131415161718192021public class TextIDEA { public static void main(String[] args) { TextIDEA TextIDEA = new TextIDEA(); System.out.println(TextIDEA.compute(2,(value) -&gt; value * 3,(value) -&gt; value * value)); // 12 System.out.println(TextIDEA.compute1(2,(value) -&gt; value * 3,(value) -&gt; value * value));// 36 System.out.println(TextIDEA.compute2(2,3,(value1,value2) -&gt; value1 * value2)); // 6 } public int compute(int a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2){ return function1.compose(function2).apply(a); } public int compute1(int a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2){ return function1.andThen(function2).apply(a); } public int compute2(int a,int b, BiFunction&lt;Integer,Integer,Integer&gt; biFunction){ return biFunction.apply(a,b); } }Predicate123456789101112131415161718192021222324252627282930@FunctionalInterfacepublic interface Predicate&lt;T&gt; { //唯一的抽象方法 boolean test(T t); //且操作，既满足A也满足B条件 default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } //且操作，既满足A也满足B条件 default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } //或操作，满足A条件或者满足B条件 default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } //静态方法，判定是否相等 static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); }}Predicate123456789@FunctionalInterfacepublic interface Supplier&lt;T&gt; { /** *这个接口是一个提供者的意思，只有一个get的抽象类， *没有默认的方法以及静态的方法，传入一个泛型T的，get方法，返回一个泛型T */ T get();}BinaryOperatorBinaryOperator:对同一类型的两个参数的操作比较操作,返回的和传入参数时相同的 ;binaryOperator 继承制BiFunciton方法1: minBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最小的对象方法1: maxBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最大的对象","link":"/2019/10/26/java-8-lambda-2/"},{"title":"Python-入门篇8","text":"这一部分是关于IO操作读文件使用Python内部的函数open()1234with open(\"C:/Users/1171676294/Desktop/新建文本文档 (2).txt\",\"r\",encoding='UTF-8') as f: print(f.read()) #会一次性读取文件的全部内容 #with语句来自动帮我们调用close()方法 #f.close()1.read(size)方法，每次最多读取size个字节的内容。2.readlines()一次读取所有内容并按行返回list。rb,已二进制的形式读取文件写文件使用Python内部的函数open()1234with open(\"C:/Users/1171676294/Desktop/text.txt\",\"w\") as f: f.write(\"zlwzlwlzlw\") #w 写命令 wb 已二进制写入文件 #'a'以追加（append）模式写入。读写内存1.写入字符串2.读写二进制文件12345678from io import StringIOf = StringIO()print(f.write(\"zlwzlwzlw\"))print(f.getvalue())# print(f.write(\" \"))print(f.readable())from io import BytesIOos模块Python内置的os模块也可以直接调用操作系统提供的接口函数。12345678910111213141516171819import os#查看当前的操作系统print(os.name)#查看当前目录的绝对路径print(os.path.abspath(\".\"))#在路径拼接print(os.path.join(\"C:/Users/1171676294/Desktop/\",\"408\"))#创建目录print(os.mkdir(\"C:/Users/1171676294/Desktop/zlwzlw\"))#删除目录os.rmdir(\"C:/Users/1171676294/Desktop/zlwzlw\")#得到文件名print(os.path.split(\"C:/Users/1171676294/Desktop/zlwzlw\")[1])#得到文件扩展名print(os.path.splitext(\"C:/Users/1171676294/Desktop/zlwzlw\")[1])#对于当前目录下文件改名print(os.rename(\"ZZZ.txt\",\"zlwzlwzlw.txt\"))#删除文件os.remove(\"zlwzlwzlw.txt\")序列化变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，1234import picklef = dict(name=\"zlw\",age=18,score=90)print(pickle.dumps(f))","link":"/2019/12/23/Python-入门篇8/"},{"title":"zlwDemo","text":"测试","link":"/2020/05/06/zlwDemo/"},{"title":"java-8 stream2","text":"用流来收集数据收集器用作高级归约预定义收集器的功能以下:1.将流元素归约和汇总为一个值2.元素分组3.元素分区(使用谓词[返回一个布尔值的单参数函数]作为分组函数)查询流中最大值和最小值Collectors.maxByCollectors.mixBy都是接受一个Comparator(比较器)参数来比较流中的元素.返回一个Optional汇总Collectors.summingInt (Double、Long)可接受一个把对象映射为求和所需的int的函数,并返回一个收集器.Collectors.averagingInt (Double、Long)求平均值Collectors.summarizingInt (Double、Long)一次性 求个数,总和,平均值,最大值,最小值(通过getter取值)joining()—&gt;字符串连接方法,方法内部使用StringBuilder拼加,joining(“, “),可以加分隔符reducing(0,Dishes::getCalories,Integer::sum);①第一个参数是初始值②第二个参数是转换函数(把流中的值转化成你所需要的类型)③第三个参数是累加函数counting() 就是把每个元素转换成1L,然后在求和.就知道了有多少个元素分组Collectors.groupingBy(Function[分类函数]Key,Value)","link":"/2019/12/09/java-8-stream2/"},{"title":"java-8 Optional类解析","text":"简介用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。of为非null的值创建一个Optional。1234//调用工厂方法创建Optional实例Optional&lt;String&gt; s = Optional.of(\"zlw\");//传入参数为null，抛出NullPointerException.Optional&lt;String&gt; s1 = Optional.of(null);ofNullable为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。1234//ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况//下面创建了一个不包含任何值的Optional实例//例如，值为'null'Optional&lt;String&gt; empty = Optional.ofNullable(null);isPresent如果值存在返回true，否则返回false。123456//isPresent方法用来检查Optional实例中是否包含值Optional&lt;String&gt; empty = Optional.ofNullable(\"ZLW\"); String name = \"zlw\"; if(empty.isPresent()){ System.out.println(empty.get()); }get如果Optional有值则将其返回，否则抛出NoSuchElementException。12345try { System.out.println(empty.get()); } catch (NoSuchElementException ex) { System.out.println(ex.getMessage()); }ifPresent如果Optional实例有值则为其调用consumer，否则不做处理要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。123//ifPresent方法接受lambda表达式作为参数。//lambda表达式对Optional的值调用consumer进行处理。empty.ifPresent(System.out::println);orElse如果有值则将其返回，否则返回指定的其它值。1234// 值为 nullSystem.out.println(empty.orElse(\"no value\"));// 值为 zlwSystem.out.println(empty.orElse(\"no value\"));orElseGetorElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值123//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，//orElseGet可以接受一个lambda表达式生成默认值。System.out.println(empty.orElseGet(() -&gt; \"no value!\"));orElseThrow如果有值则将其返回，否则抛出supplier接口创建的异常。在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常123456789try { //orElseThrow与orElse方法类似。与返回默认值不同， //orElseThrow会抛出lambda表达式或方法生成的异常 empty.orElseThrow(ValueAbsentException::new);} catch (Throwable ex) { //输出: No value present in the Optional instance System.out.println(ex.getMessage());}ValueAbsentException定义如下：123456789101112131415class ValueAbsentException extends Throwable { public ValueAbsentException() { super(); } public ValueAbsentException(String msg) { super(msg); } @Override public String getMessage() { return \"No value present in the Optional instance\"; }}map如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。12345//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\");Optional&lt;String&gt; newempty = empty.map((value) -&gt; value.toUpperCase());System.out.println(newempty.orElseGet(() -&gt; \"no value!!\"));flatMap如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。12345//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 //但flatMap方法中的lambda表达式返回值必须是Optionl实例。 Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\"); System.out.println(empty.flatMap((value) -&gt; Optional.of(value.toUpperCase())).orElseGet(() -&gt; \"no value!!\"));filter如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。12345//filter方法检查给定的Option值是否满足某些条件。//如果满足则返回同一个Option实例，否则返回空Optional。Optional&lt;String&gt; empty = Optional.ofNullable(\"zlw\");Optional&lt;String&gt; s = empty.filter((value) -&gt; value.length() &gt; 5);System.out.println(s.orElse(\"The name is less than 6 characters\"));","link":"/2019/10/28/java-8-Optional类解析/"},{"title":"java-8 方法引用","text":"方法引用: method reference方法引用实际上是个Lambda表达式的一种语法糖我们可以将方法引用看作是一个[函数指针]*方法引用classname::staticmethod*方法调用classname.staticmethod方法引用共分为4类类名::静态方法名引用名(对象名)::实例方法名类名::实例方法名(lambda表达式的第一个参数作为这个方法的调用者,之后的参数作为这个方法的参数)构造方法引用 类名::new默认方法什么是默认方法简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。为什么出现默认方法为什么要有这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。java 8抽象类与接口对比相同点不同点都是抽象类型抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）都可以有实现方法（以前接口不行）抽象类和接口所反映出的设计理念不同。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系都可以不需要实现类或者继承者去实现所有方法，（以前不行，现在接口中默认方法不需要实现者实现）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。多重继承的冲突由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：1.一个声明在类里面的方法优先于任何默认方法（classes always win）2.否则，则会优先选取路径最短的。12345678910public interface MyInterface { default void myMethod(){ System.out.println(\"myMethod1!!\"); }}public interface MyInterface1 { default void myMethod(){ System.out.println(\"myMethod2!!\"); }}报错 defaultTest inherits unrelated defaults for myMethod() from types MyInterface and MyInterface1如果一定要这么写呢，同时实现MyInterface,MyInterface1并且使用MyInterface1中myMethod()？可以这么写：12345678910public class defaultTest implements MyInterface,MyInterface1{ public static void main(String[] args) { defaultTest defaultTest = new defaultTest(); defaultTest.myMethod(); } @Override public void myMethod() { MyInterface1.super.myMethod(); }}或者可以这么写:12345678910111213141516public interface MyInterface2 extends MyInterface,MyInterface1 { default void myMethod(){ System.out.println(\"myMethod3!!\"); }}public class defaultTest implements MyInterface2{ public static void main(String[] args) { defaultTest defaultTest = new defaultTest(); defaultTest.myMethod(); } @Override public void myMethod() { MyInterface2.super.myMethod(); }}输出 myMethod3!! 可见MyInterface2.super表示的是MyInterface2接口，同时defaultTest无法访问MyInterface,MyInterface2的myMethod()可见MyInterface2虽然有同一个两个最短路径的myMethod(), 但是它自己有一个更高优先级的myMethod()，所以不会报错;默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进了，当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。也许将来我们会在API设计中看到更多的默认方法的应用。","link":"/2019/10/28/java-8-方法引用/"},{"title":"平时看的好文章","text":"技术人员的发展之路 –陈皓https://coolshell.cn/articles/17583.html计算机专业学历重不重要https://zhuanlan.zhihu.com/p/84350029","link":"/2019/10/24/平时看的好文章/"},{"title":"java-jvm篇2","text":"jvm运行时的数据区,Java 虚拟机在执行 Java 程序的过程中，会把它管理的内存划分成若干个不同的数据区域。不同的JVM对于内存的划分方式和管理机制存在着部分差异.(大部分是方法区不同)以下是简图:绿色的为单线程所有的,蓝色的为多个线程共享的:每个线程:独立包括程序计数器、栈、本地栈.线程间共享:堆、堆外内存(永久或者元空间、代码缓存)==&gt;方法区每个JVM只有一个Runtime实例.(单例)线程是一个程序里的运行单元,JVM允许一个应用有多个线程并行的执行.在Hotspot JVM里,每个线程都与操作系统的本地线程映射.当一个java线程准备好执行以后,此时一个操作系统的本地线程也同时创建.java线程执行终止后,本地线程也会回收.PC寄存器(Program Counter Register)JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟.作用:PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码,由执行引擎读取下一条指令使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？进程切换,保存现场JVM栈(Java Virtual Machine Stack)栈是运行时的单位,堆是存储的单位.早期也叫Java栈,每个线程在创建时都会创建一个虚拟机栈,其内部保存一个个的栈帧(Stack Frame),对应一次次Java方法调用.不存在垃圾回收问题.GC(存在OOM)作用:主管Java程序的运行,它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果,并参与方法的调用和返回.Java栈的大小是动态的或者是固定不变的.如果采用固定大小的jvm栈,那每个线程的jvm栈容量可以在线程创建的时候独立选定.如果线程请求分配的栈的容量超过JVM栈的最大容量,JVM栈会抛出一个StackOverflowError异常.(递归,可以用-Xss 设置栈的大小)如果JVM栈可以动态扩展,并尝试扩展的时候无法申请到足够的内存(创建先的线程时没有足够的内存去创建对应的JVM栈)JVM栈会抛出一个OutOfMemoryError异常.一个时间点上只会有一个活动的栈帧,当前执行的方法的栈帧称为当前栈帧,对应的方法称为当前方法,定义这个方法的类称为当前类.栈运行原理1.不同线程之间栈帧不允许相互引用.2.方法返回时,会将此方法的执行结果给前一个栈帧,此帧丢弃.前一个栈帧成为当前栈帧.3.Java方法有两种返回函数的方式,都会导致栈帧被弹出.3.1 正常的函数返回(return)3.2 抛出异常(Error)栈的内部结构局部变量表1.定义为一个数字数组,主要用于存储方法参数和定义在方法体内的局部变量(基本数据类型,对象引用,returnAddress)。2.是线程私有的,不存在数据安全问题.3.局部变量表所需的容量大小是在编译期确定下来的,运行期间是不会改变局部变量表的大小4.方法嵌套调用的次数由栈的大小决定,栈越大,方法嵌套调用次数越多.5.局部变量表中的变量 只在当前方法调用中有效,当方法调用结束后,随着方法栈帧的销毁也会随之销毁.变量的分类:1.按照数据类型分：①基本数据类型 ②引用数据类型2.按在类中的声明的位置分:①成员变量:在使用前,都经历过默认初始化的赋值类变量:linking的prepare阶段:给类变量默认赋值—&gt;&gt; initial阶段:给类变量显式赋值即静态代码块赋值实例变量:随着对象的创建,会在堆空间中分配变量空间,并进行默认赋值.②局部变量: 在使用之前要进行显式赋值,否则,编译不通过局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象不会被回收.操作数栈在方法执行过程中,根据字节码指令,往栈中写入数据或者提取数据(入栈,出栈),用数组的结构来实现的作用:主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间.1.一个新的栈帧在创建出来,这个方法的操作数栈是空的(max_stack最大深度在编译期就定义好了)2.栈顶缓存技术将栈顶元素全部缓存到物理CPU的寄存器中,以此降低对内存的读/写次数,提升执行引擎的执行效率.动态链接(指向运行时常量池的方法引用)每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用.包括这个引用的目的就是为了支持当前方法的代码能够实现动态链接。(invokedynamic)作用:为了将这些符号引用转换为调用方法的直接引用.绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 Java 来说，绑定分为静态绑定和动态绑定，或者叫做前期绑定和后期绑定。静态绑定：在程序执行前方法已经被绑定(也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法)，由编译器实现。C就是典型的前期绑定。Java 中 final，static，private 修饰的方法和构造方法是前期绑定(早期绑定)动态绑定：运行时根据具体对象的类型进行绑定(晚期绑定)虚方法与非虚方法如果方法在编译期就确定了具体的调用版本,这个版本在运行时是不可改变的,这样的方法称为非虚方法静态方法、私有方法、final方法、实例构造器、父类方法都是其他的方法称为虚方法jvm中的调用方法指令：(绿色表示非虚方法,其余的(final修饰的除外)称为虚方法)1.invokespecial (编译时方法绑定调用方法。)2.invokestatic(调用静态方法。)3.invokevirtual (运行时方法绑定调用方法。)4.invokeinterface (调用接口方法。)5.invokedynamic(Java为了实现动态类型语言支持而做的一种改进.Lambda表达式出现,invokedynamic指令的生成,在java中才有了直接的生成方式)动态类型语言和静态类型语言的区别:对类型的检查是在编译期还是运行期间. java: int i = 10; (静态类型) Python:i = 10 (动态类型) 方法返回地址存放调用该方法的PC寄存器的值.1.正常退出:方法退出后会返回到调用该方法的下一条指令的地址.(执行引擎拿到地址进行跳转).字节码指令中,方法指令包含:1.1 ireturn(当返回值是boolean、byte、char、short、int类型时,使用长度小于int的)1.2 lreturn、freturn、dreturn以及引用类型areturn1.3 return(供声明void的方法、实例初始化方法、类、接口的初始化方法使用)2.异常退出:”返回地址要通过异常表(本方法的异常表中没有搜索到匹配的异常处理器 )来确定,栈帧中一般不会保存这部分信息.两者的区别:通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。","link":"/2020/02/15/java-jvm篇2/"},{"title":"数据结构 基本概念","text":"这些概念不是很好记忆,需要把这些术语记住然后在带入生活中去理解。1.数据能输入到计算机且能被计算机程序处理的符号总称.(整数,字符串等)2.数据元素是数据的基本单位,一个数据元素可能由若干个数据项组成.3.数据项是数据结构中最小的单位,是数据记录中最基本的、不可分割的数据单位.4.数据对象相同的数据元素的集合,是数据的一个子集.5.数据结构相互之间存在一种或者多种特定关系的数据元素的集合,包括一下三方面:逻辑结构、存储结构、对数据的运算.6.数据的逻辑结构是数据之间关系的描述,与数据的存储结构无关.①.线性结构是一个数据元素的有序集合,元素之间存在着”一对一“的线性关系的数据结构，除了头尾元素,其他元素有且只有一个”前驱”和一个”后继”.②.非线性结构与线性结构不同的是,元素之间存在”一对多”的关系.7.数据的物理结构是数据的逻辑结构在计算机中的表示(映像–&gt;顺序映像和非顺序映像),包括数据的表示和关系的表示.①.顺序存储方法把逻辑上相邻的结点存储在物理位置上相邻的存储单元上.(数组)②.链式存储方法不要求逻辑上相邻的结点在物理位置上也相邻,结点的逻辑关系是由附加的指针字段来表示的.(链表)③.索引存储方法在存储结点信息时除建立存储结点信息外,还建立附加的索引表来标识结点的地址.索引项的一般形式是&lt;关键字,地址&gt;④.散列存储方法根据结点的关键字通过散列函数直接计算出该结点的存储地址.算法的基本概念1.算法的特性(1)有穷性(2)确定性(3)输入(4)输出(5)可行性2.算法的设计目标(1)正确性(1)可读性(1)健壮性(1)高效率与低存储量需求","link":"/2019/12/04/数据结构-基本概念/"},{"title":"数据结构总体的思维导图","text":"自己整理的关于考研408数据结构需要掌握的数据结构的知识结构图。这个月因为软考和看408的网络课程没有更新多少博客,在接下来的时间我会更新数据结构的C的代码练习,让自己掌握的更牢固.","link":"/2019/11/30/数据结构总体的思维导图/"},{"title":"数据结构 线性表","text":"线性表的知识是之后的基础,一定要完全掌握.线性表的定义线性表是具有相同特性数据元素的一个有序序列,长度为n.线性表的存储结构(1)顺序存储结构(顺序表)随机访问特性占用连续的存储空间顺序表插入操作的时候要移动多个元素(2)链式存储结构(链表)不支持随机访问结点的存储空间利用率较顺序表稍低一些动态分配进行插入操作无须移动元素链表有以下5种:(1)单链表①.带头结点的头指针head指向头结点,头结点的值域不含任何信息,从头结点的后继结点开始存储数据信息,头结点始终不等于NULL,head-&gt;next==NULL的时候,链表为空.②.不带头结点的头指针head直接指向开始结点,head==NULL时,链表为空.(2)双链表除了前后结点,每个结点有两指针域分别指向前后两结点(3)循环单链表就是尾节点不是指向NULL,而是指向头结点,没有带头结点就指向第一个节点,头尾相邻形成一个环.(4)循环双链表前后结点形成环即可.(5)静态链表借助一维数组.","link":"/2019/12/04/数据结构-线性表/"},{"title":"练习hexo的发布","text":"[title] [] [url] [link text]1234567---title: #文章标题date: #时间，一般不用改categories: #目录分类tags: #标签，格式可以是[Hexo,总结]，中间用英文逗号分开keywords: #文章关键词，多个关键词用英文逗号隔开---1alert(&apos;Hello World!&apos;);Array.map1array.map(callback[, thisArg])插入图片的方法绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。12source/images/image.jpg![](/images/image.jpg)图片既可以在首页内容中访问到，也可以在文章正文中访问到。相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。_config.yml1post_asset_folder: true将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。12_posts/post_name/image.jpg![](image.jpg)上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。12_posts/post_name/image.jpgTime.javaview raw12345678910111213141516171819202122/** * @author zlw * @create 2019-09-11 22:53 */public class Time { public static void main(String[] args) { long startTime = System.currentTimeMillis(); doSomeThing(); long endTime = System.currentTimeMillis(); System.out.println(\"====================\"); System.out.println( (endTime - startTime)+\"ms\"); } public static void doSomeThing(){ for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { System.out.println(i * j); } } }}","link":"/2019/10/18/练习hexo的发布/"},{"title":"CentOS 7 安装git和基本操作","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。安装步骤查看git版本 git --version yum remove git 安装所需软件包123yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install gcc-c++ perl-ExtUtils-MakeMakeryum install install autoconf automake libtool下载 cd /usr/src $ wget https://www.kernel.org/pub/software/scm/git/git-2.7.3.tar.gz 解压tar xf git-2.7.3.tar.gz配置 安装 编译12345cd git-2.7.3make configure./configure --prefix=/usr/git ##配置目录make profix=/usr/gitmake install加入环境变量 vim /etc/profile source /etc/profile 查看版本基础操作指令1.创建git-test 仓库git –bare init git-testchown -R zlwgit:zlwgit /home/zlwgit/git-test/客户端git clone zlwgit@47.111.237.227:/home/zlwgit/git-test (这里输入名字就是在本地新建一个文件放)将服务器端的git-test 仓库下到本地的目录下git remote显示本机所关联的远程仓库cat .git/config 查看具体信息将本地仓库中的分支推送到远端仓库并与远端分支进行合并git push(第一次将本地的修改推送到服务器,此服务器端还不存在master分支,需要用这指令重新推送,git push &lt;远端仓库&gt;&lt;远端分支&gt;)git pull显示所有的本地分支git branch显示所以下载到本地的远端分支git branch -r查看状态(当远程仓库的代码与本地代码有冲突时可以查看冲突文件)git status查看版本树gitk查看提交历史git loggit log -p (patch,输出补丁) 显示每一步的修改内容git log –stat –Summary()git show 21321cf686e09eba538f935242b8a57f2893e903 查看某个提交的具体内容git show 2132git show HEAD (当前分支中最后提交记录的标识符)等同 git show master管理分支创建分支git branch zzgit branch (*当前所在的分支)git checkout zz (切换分支)我们在zz 分支进行修改内容后,在进行提交,在切换到master分支后,查看修改的文件,发现我们在zz分支修改的内容不见了,原因是我们刚才的修改是在zz分支上做的,而我们现在已经切换回了master分支了两个分支产生了分歧,每个分支包含不同的修改.如果要将zz合并到master中执行以下指令即可:git merge zz没有冲突merge 会自动完成,有冲突则合并过程中会中断.Auto-merging zlwgit.txtCONFLICT (content): Merge conflict in zlwgit.txtAutomatic merge failed; fix conflicts and then commit the result.然后我们手动修改冲突,然后在提交,系统会自动的生成提交提示信息.git对象数据库在git中,文件、目录、提交记录都被作为对象管理,[master 65f5957] version 1.1 master3 files changed, 3 insertions(+)主要不发生冲突,可以用前导字符串标识这条提交,就是提交记录标识符的前导字符串,提交记录的标识符是居于本次提交所包含的所有文件的内容,父节点的标识符、系统实践、用户名等综合信息所生成的一个SHA1字符串,这可以保证git永远不会生成重复的提交记录标识符。提交记录保存在.git/objects/tree 是65f5957bc1f018918a19a4fd0e468aa87f13b938这个对象的类型因此得到一下结论与猜想：1.在git中每一条提交记录都具有唯一的标识符2.提交记录被作为二进制文件保存在.git/objects/目录下3.git中有多种类型的对象4.提交记录是git中的一种对象,他的类型是commit5.每个对象都有唯一的SHA1字符串与之对应(猜想)6.提交记录只包含最基本的信息,它的具体内容保存在一个tree类型的对象内()git ls-tree 65f5查看目录git正是通过commit对象的parent属性将独立的commit对象关联起来,从而构成了分支的版本书git cat-file blob 120e查看文件git中的tree对象对应提交的代码中的目录,blob对象对应提交的代码中的文件,tree对象可以包含blob对象(目录中的文件)和tree对象(目录中的子目录)git hash-object &lt;文件&gt;计算文件在git中的SHA1标识符(无论文件的名称如何修改,位于哪个目录下,只要文件的内容不变,他的SHA1就是相同的)在git中,blob类型的对象的SHA1只与文件的内容有关，相同的文件内容永远产生相同的SHA1,而不同的文件内容永远产生不同的SHA1.这意味着如果我们将两个内容相同的文件提交到git中,他们实际上会被保存为同一个blob对象git add test03git commit -a -m “version 1.2 master”为什么我们这一次的提交且包含上一次的那些文件跟目录(git ls-tree xxx)实际上上一条提交记录是工作目录中sygit提交记录的访问方法1 通过SHA1访问git show asdw2 通过分支名访问git log master3 通过HEAD访问git log HEAD4 通过标签访问git show version 1.15 通过^访问 (当前结点的父节点)git log HEAD^git log master^6 通过^[n] 访问git show HEAD^1 (访问第一个父节点)git show HEAD^2 (访问第二个父节点)7 通过~ 访问git show HEAD^2git常用指令初始化本地仓库git init下载远程项目git clone &lt;账号&gt;@&lt;ip地址&gt;:项目在服务器的地址更新index (将工作目录中的文件、目录的内容更新到index中)git add &lt;路径&gt;查看工作目录状态git status撤销git add 操作(如果代码已经通过git commit提交,则不能执行此操作)git reset HEAD &lt;路径&gt;撤销本地操作(如果代码已经通过git commit提交,则不能执行此操作)git checkout – &lt;路径&gt;提交修改git commit (提交index的内容)git commit -a (将修改更新到index,然后提交,忽略新增的文件)git commit -a -m “提交说明”浏览提交历史git log &lt;提交历史&gt;git log (显示当前分支所有提交的历史)显示本地master与远程仓库master之间的不同的提交记录git log -p master..origin/master显示某一提交的内容git show &lt;提交记录&gt;：&lt;文件&gt;git show 123dgit show master显示版本树的图形界面gitk &lt;提交记录&gt;显示差异git diff &lt;旧提交记录&gt;..&lt;新提交记录&gt;git diff wy..master (主分支和从分支的区别)生成patchgit format-patch &lt;旧提交记录&gt;..&lt;新提交记录&gt;显示本地分支git branch创建本地分支git branch &lt;分支名称&gt;删除本地分支git branch -d &lt;分支名称&gt; (-D 强制删除)显示远端分支git branch -r切换分支git checkout &lt;分支名&gt;显示远端仓库git remote推送代码git push提取并更新代码git pull提取代码git fetch合并分支git merge &lt;被合并分支&gt;调查git对象git cat-file -t(查看文件的类型)git cat-filegit cat-file commit 0111调查tree对象git ls-tree内容检索git prep &lt;关键字&gt;git prep &lt;关键字&gt;&lt;提交记录&gt;git prep &lt;关键字&gt;&lt;提交记录&gt;:&lt;文件&gt;移动文件/目录git mv &lt;原&gt; &lt;新&gt;删除文件/目录git rm &lt;路径&gt;显示所有标签git tag -n新建本地标签git tag &lt;标签名&gt; &lt;提交记录&gt;删除标签git tag -d &lt;标签名&gt;创建远端标签git tag -a &lt;标签名&gt; -m &lt;标签说明&gt; &lt;提交记录&gt;推送远端标签git push –tags提取远端标签git fetch –tags撤销某条提交记录git revert &lt;提交记录&gt;获得某个文件的历史版本git checkout master^ zlw.txt计算文件的SHA1字符串git hash-object zlw.txt显示git配置git config –global -lgit config -lhelpgit help &lt;指令&gt;错误同时提交同事B先上传了代码到远程仓库,但同事A也在后面上传了代码,此时同时A报了一下的错误.12345hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.问题原因:其他地方向同一远端库推送了代码，导致本地不是最新的。解决:先pull 一下,使当前本地仓库版本是最新的12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADAAAAAAAAAAAAA version1.1 这部分是本地的=======BBBBBBBBBBBBB version1.1 这部分是远程仓库的&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1f0894404b819648c9b207f19e425638c1bf35a4","link":"/2020/02/25/CentOS-7-安装git和基本操作/"},{"title":"Android入门1","text":"1项目的结构build 编译时自动生成的文件libs 第三方jar包AndroidTest 测试用例java java代码resdrawable 图片layout 布局values 字符串mipmap 开头的用来放应用图标 -xx是为了让程序能够好的兼容各种设备AndroidManifest.xml 整个Android项目的配置文件,四大组件在这注册proguard-rules.pro 指定项目代码的混淆规则,让破解者难以阅读.Activity是Android应用程序的门面,凡是应用中你看到的东西,都是放在活动中的Android程序的设计讲究逻辑和视图分离.调用方式调用应用程序名的字符串两种方式代码中:R.string.hello_worldxml:@string/hello_worldstring的部分可以替换drawable mipmap layout引用id @id/id_name定义id @+id/id_name活动中使用Toast活动本身就是一个Context 对象makeText(“上下文对象”,”显示的文本”,”显示的时长”)在活动中使用Menu(菜单)IntelIntel是Android程序各组件之间进行交互的一种方式Intent zlw = new Intent(启动活动的上下文,指定想要启动的目标活动.class)startActivity(zlw);隐式Intent不明确指出那个活动,而指定action 和category(同时匹配上才响应)1234567&lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.ZLW&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt;向下一个活动传数据12345String data = &quot;qwerqwewerfjqwekrthqwejklrhjkl ehjrklqwhrklqwerhqwelrhjqwelrwjkelrh&quot;; intent.putExtra(&quot;s1&quot;,data); Intent intent = getIntent(); String data =intent.getStringExtra(&quot;s1&quot;); //根据前一个传的键的类型写方法 Log.d(&quot;zlwzlwzlwzlwzlw&quot;,data);返回数据给上一个活动第一个活动:12345startActivityForResult(intent,i)onActivityResult(int requestCode, int resultCode, @Nullable Intent data)requestCode判断来源resultCode判断结果data取数据第二个活动：1234Intent intent1 = new Intent(); intent1.putExtra(&quot;data_return&quot;,&quot;android studio&quot;);setResult(RESULT_OK,intent1);finish();//销毁activity//会调回到上一个活动的onActivityResult方法中Activity的生命周期Android是使用任务(task)来管理活动的，一个任务就是一组放在站里面的活动的集合,这个站也被称为返回栈启动一个栈相当于压栈finish相当于出栈四个状态运行状态处于栈顶的活动暂停状态不处于栈顶的位置的活动,就进入暂停活动.仍然处于完全存活和可见状态.停止状态不在栈顶的位置的活动,完全不可见,但会保存状态和成员变量.销毁状态从栈中移除的活动Activity类中定义了7种回调方法onCreate()会在活动第一次被创建的时候调用onStart()完全不可见变可见时调用onResume()在活动准备好和用户进行交互的时候调用(一定处于栈顶)onRestart()停止状态到运行状态之前调用onPause()在系统准备去启动或者恢复另一个活动的时候调用.onStop()在完全不可见的时候调用onDestroy()在活动销毁前调用生存期正常的dialog完整生存期 onCreate() onDestroy()之间经历可见生存期 onStart() 进行加载 onStop() 进行释放会话前台生存期 onResume() onPause() 活动总是处于运行状态,用户接触最多的活动被回收了怎么办当A活动在去启动B活动之后,由于内存不足,将A活动收回,那么用户按下Back返回活动A,会出现什么情况.还是会onSaveInstanceState() 可以保证在活动被收回之前一定会被调用.活动的启动模式standard(默认启动模式)不在乎这活动是否已经在返回栈中存在,名次还是准备都会创建该活动的一个新的实例.singleTop在启动活动是如果发现返回栈的栈顶已经是该活动,则认为可以直接使用它.不会在创建新的活动实例.singleTask创建活动之前检查返回栈中是否存在该活动的实例,如果有直接使用该实例,并把这个活动之上的所有活动统统出栈,如果没有就直接创建一个新的实例.singleInstance指定该模式的活动会启用一个新的返回栈来管理这个活动(主要是为了很其他的应用程序进行交互,而上三种方式不行,共用这同一个返回栈)在AndroidManifest.xml的知晓当前在哪个活动中写一个BaseActivity,继承AppComatActivity并重写onCreate(),但不在在AndroidManifest.xml里面注册,只需要让要访问的类继承该类就行了,protected void onCreate(@Nullable Bundle savedInstanceState) {super.onCreate(savedInstanceState);Log.d(“BaseActivity”, getClass().getSimpleName());}活动管理器新建一个类,里面有add,remove,还有一个FinnishAll()和一个list列表.每次在onCreate() 和 onDestroy() 执行add,remove方法在需要的时候执行FinnishAll() 结束所有的活动.常用控件的使用方法TextViewmatch_parent 让当前控件的大小和父布局的大小一样fill_parent 跟上面意义相同wrap_parent 让当前控件的大小能够刚好包住里面的内容,由控件内容来决定控件的大小TextView默认是居左对齐.android:gravity=”center” top bottom left right center 可以用|来确定多个值android:textSize=”24sp”android:textColor=”#00000”Button系统对button中的所有英文字母自动进行大写转换android:textAllCaps=”false” 禁用EditText允许用户在控件里输入和编辑内容,并可在程序中对这些内容进行处理.(发短信,发微信,发qq)默认的文本提示,输入文本就消失android:hint=”默认的文本提示”指定行数的限制android:maxLines=”2”imageView显示图片的控件ProgressBar(进度条)android:visibility=””visible 可见(不指定默认可见)invisible 不可见(但占位置和大小,透明)gone 不仅不可见,而且不占空间进度条的样式自己找AlertDialog弹出对话框,置定于所以的界面之上.ProgressDialog4种基本布局布局用来管理控件一个布局里面可以有多个布局和多个控件1.线性布局2.相对布局3.帧布局所有的控件都放在左上角,先加载的在最低层.4.百分百布局自定义控件ListView最常用和最难用的插件.(当我们程序中有大量的数据需要展示的时候使用)ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内,同时屏幕上原有的数据则会滚动出屏幕。提升ListView的效率RecyclerView 比ListView跟方便跟轻松的实现横向滚动和瀑布流布局ListView的布局排列是由自身去管理的,RecyclerView则将这个任务交给LayoutManager,LayoutManager中制定了一套可扩展的布局排列接口,子类照着套就完事了GridLayoutManager 实现网格布局StaggeredGridLayoutManager 实现瀑布流布局RecyclerView的点击事件nine-patch 图片碎片碎片是一种可以嵌入在活动中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间,(可以理解为迷你型的活动)动态添加碎片//创建添加的碎片实例//获得fragmentManager,在活动中可以调用getSupportFragmentManager得到//开启事务 获得fragmentManager.beginTransaction//向容器添加或者替换碎片 用 replace() 传入 容器id 和 添加的碎片实例//提交事务 commit()//将一个事务添加到返回栈中fragmentTransaction.addToBackStack(null);碎片和活动之前进行通信活动中调用碎片FragmentManager 有类似于 findViewById()的方法 专门用于从布局文件中获得碎片的实例getFragmentManager().findFragmentById(R.id.right_layout)碎片中调用活动MainActivity activity = (MainActivity) getActivity();碎片的生命周期1.运行状态可见,关联的活动处于运行状态2.暂停状态活动处于暂停状态,碎片就进入暂停状态3.停止状态当一个活动进入停止状态时,与它相关的碎片就进入到停止状态,或者用 FragmentTransaction 的remove() replace() 从活动中移除. 调用addToBackStack会进入暂停状态,进入停止状态的碎片对于用户来说完全不可见4.销毁状态碎片总是依附活动而存在,活动亡,碎片亡, remove() replace() 在事务之前没有调用 addToBackStack方法,碎片就会进入销毁状态onAttach()当碎片和活动建立关联的时候调用onCreateView()为碎片创建视图(加载布局)时调用onActivityCreated()确保与碎片相关联的活动一定已经创建完毕的时候调用.onDestroyView()当与碎片关联的视图被移除的时候调用onDetach()当碎片和活动解除关联的时候调用动态加载布局的技巧判断程序应该是使用单页模式还是双页模式===&gt;限定符在layout同级目录建一个layout-large 其中large就是一个限定符,那些屏幕认为是large的设备就会自动加载layout-large 文件夹下的布局,小屏幕的设备还是会加载layout文件夹下的布局android中一些常见的限定符大小small 小屏幕设备normal 中等屏幕设备large 大屏幕设备xlarge 超大屏幕设备分辨率ldpi 低分辨率设备 120dpi以下mdpi 中等分辨率设备 120dpi160dpihdpi 高分辨率设备 160dpi240dpixhdpi 超过高分辨率设备 240dpi320dpixxhdpi 超超高分辨率设备 320dpi480dpi方向land 横屏设备port 竖屏设备最小限定符这个最小值为临界点,屏幕宽度大于这个值的设备就加载一个布局,小于加载另一个布局碎片的最佳实例—一个简单版的新闻应用FragmentBestPractice项目名1.实现在app/build.gradle添加依赖implementation ‘androidx.recyclerview:recyclerview:1.0.0’2.创建新闻的实体类,有title和content这两个字段名,和get,set方法3.编写新闻内容的布局 news_content_frag.xml4.然后在创建 NewsContentFragment 新闻内容的碎片广播的类型1.标准广播完全异步执行的广播,在广播发之后,所有广播接收器几乎都会在同一时刻接收到这条广播消息.无法截断2.有序广播同步执行,在广播发之后,同一时刻只会有一个广播接收器能够收到这条广播信息,当这个广播接收器中的逻辑执行完毕后,广播才会继续传播,此时广播接收器是有先后顺序的,优先级高的先接收,可以被截断.可以对自己感兴趣的广播进行注册,注册广播有两种方式1.在代码中注册 (动态注册)2.在AndroidManifest.xml中注册 (静态注册)任何创建一个广播接收器,新建类让他继承自 Broadcast-Receiver,并重写父类的onReceive就行了,在有广播到来时,该方法会得到执行.Android系统为了保护用户设备的安全跟隐私,必须在配置文件中声明权限才可以缺点是程序启动之后才可以接收到广播静态注册实现开机启动android:name=”.BootCompleteReceiver” 指定那个广播接收器android:enabled=”true”是否启动android:exported=”true”是否接收本程序以外的广播不要在onReceive()方法中添加过多的逻辑进行任何的耗时操作.发送自定义广播android:priority=”100”//表示将这条广播截断abortBroadcast();使用本地广播之前我们发送和接收的广播都是属于系统全局广播本地就是只能在应用程序的内部进行传递LocalBroadcastManager 需要导入implementation ‘androidx.recyclerview:recyclerview:1.0.0’实现强制下线的功能界面上弹出一个对话框且中只有一个确定按钮,但用户可能出现在任意一个界面上，我们不可能每个界面都写这个弹出对话框的逻辑.git的基本命令git config –global user.name “zlw”git config –global user.email “985686843@qq.com“创建仓库git init不想要之前本地仓库删除那个隐藏的.git文件夹就行了提交本地代码git initgit add .git commit -m “First commit”git remote add origin https://github.com/ZlwPick/AndroidTest.gitgit push -u origin master添加单个文件git add build.gradle添加整个目录下的所有文件git add app添加所有文件git add .提交(描述信息)git commit -m “First commit”新建分支git branch newbranch检查分支git branch查看修改内容(显示更改的文件)git status查看更多修改信息()git diff 具体文件的位置撤销修改git checkout 具体文件的位置持久化技术数据持久化技术保证数据不在是瞬时数据.保存在内存中的数据是瞬时的,保存在存储设备上的数据是处于持久化状态android中三种常见的持久化：1.文件存储2.SharedPreference存储3.数据库存储文件存储最基础的一个数据存储方式,不对存储的内容进行任何的格式化处理.原封不动的保存到文件中,适用于简单的文本数据或者二进制数据.SharedPreference存储要想使用SharedPreferences,首先需要获得SharedPreferences对象,有以下三种方式得到对象.1.Context类中的getSharedPreferences()方法2.Activity类中的getPreferences()方法3.PreferenceManager 类中的 getDefaultSharedPreferences()方法主要有以下三步.1.调用 SharedPreferences对象的edit()获取SharedPreferences.Editor对象2.向SharedPreferences.Editor对象中添加数据putBoolean() putString() …3.调用 apply() 方法数据提交SQLite 数据库存储新建一个类继承 SQLiteOpenHelper 类,在重写 onCreate() 和 onUpgrade()两种方法都可以打开一个现有的数据库gerReadableDatabase()返回只能读操作的对象getWritableDatabase()返回一个可以对数据库进行读写操作的对象MyDatabaseHelper(Context context,String name, SQLiteDatabase.CursorFactory factory, int version)1.上下文对象 2.数据库名 3.Cursor对象,一般为null 4当前数据库的版本号 1内容提供器主要用于不同的应用程序之间实现数据共享的功能.运行时权限,用户不必在安装软件的时候一次性授权所有的申请权限，比如有打开相机的功能时在申请相机的权限.所以的权限分为普通权限、危险权限.每个危险权限都属于一个权限组下,当申请的一个危险权限得到授权时,整个组下的危险权限都可以使用.ContentResolver的基本用法1.Context.getContentResolver() 获取该类的实例,有一套CRUD(insert()、update()、delete()、query() ),不接受表名参数,而是使用一个Uri参数代替,Uri是由anthority和path组成,anthority是采用应用程序的包名来进行命名的,path则是用于对同一应用程序中不同的表做区分的.还需要在最前面加上协议如下：content://com.example.app.provider/table1content://com.example.app.provider/table2content://com.example.app.provider/table2/1 (table2id为1的数据)表示匹配任意长度的任意字符表时匹配任意长度的数字content://com.example.app.provider/* (匹配任意表)content://com.example.app.provider/table2/#匹配任意一行的数据内容Uri.parse() 将字符串解析成Uri对象UriMatcher中的addUri 实现匹配内容 参数列表(anthority,path,一个自定义代码)创建自己的内容提供器1.新建一个类去继承 ContentProvider 的方式来创建一个自己的内容提供器. 重写他的6个方法","link":"/2020/02/17/Android入门1/"},{"title":"java-8 stream","text":"本章节是根据java8实战总结的一些知识点,方便自己以后在去回顾.流是java8中一个新的概念,它允许你以声明性方法处理数据集合,类似于SQL语句,可以透明地并行处理.并不需要你自己去做,你只需要指示怎么操作就行了——流自动帮办好了！流的带来的好处有以下:1.声明性——更简洁,更易读2.可复合——更灵活3.可并行——性能更好流中的几个概念:1.元素序列—— 集合讲的是数据,流讲的是计算.2.源—— 流会使用一个提供数据的源.3.数据处理操作—— 流的数据处理功能支持类似于数据库的操作,以及函数式编程中常用的操作,可以是顺序或者并行执行.流操作两个重要的特点:1.流水线——很多流操作本身会返回一个流,这样多个操作就可以链接起来,形成一个大的流水线.(ps:类似于sql的查找)2.内部迭代——于使用迭代器显示迭代的集合不同,流的迭代操作是在背后进行的.3.流只能遍历一次,遍历完就已经被消费掉了,可以从原始数据源重新获得一个新的流.反正会报错.外部迭代是用户使用Collection接口自己去做迭代.内部迭代是它自动帮你把迭代做了,还把得到的流值存在某个地方,你只需要给出一个函数说要干什么就完事了,是不是很轻松.而且内部迭代是透明地并行处理,或者用更优化的顺序(某些合适你硬件的数据表示)进行处理.流的操作中间操作——会返回另一个流,这样可以多个操作连接起来,更重要的是,除非流水线上触发一个终端操作,否则中间操作不会执行任何处理——他们很懒(惰性求值).这是因为中间操作一般是可以合并起来,在终端操作时一次性全部处理.终端操作——从流的流水线生成结果,其结果是任何不是流的值.(List,Integer,甚至是void)使用流1.一个数据源(如集合)来执行一个查询.2.一个中间操作链,形成一条流的流水线.3.一个终端操作,执行流水线,并能生成结果.筛选和切片用谓词筛选,筛选出各不相同的元素filter()—-&gt;该操作会接受一个谓词(一个返回boolean的函数)作为参数,并返回一个包含所有符合谓词的元素的流.distinct()—-&gt;它会返回一个元素各异(根据流所生成元素的hashCode和equals方法实现)的流.limit()—-&gt;该方法会返回一个不超过给定长度的流.skip(n)—-&gt;返回一个扔掉前n个元素的流,如果流中元素不足n个,则返回一个空流.映射map()—-&gt;它会接受一个函数作为参数,这个函数会被应用到每个元素上,并将其映射成一个新的元素.flatMap()—-&gt;各个数组并不是分别映射成一个流,而是映射成流的内容.也就是生成的单个流被合并起来,即扁平化为一个流.查找和匹配anyMatch()—-&gt;检查谓词是否至少匹配一个元素,返回一个boolean,是一个终端操作.allMatch()—-&gt;检查谓词是否匹配所有元素.noneMacth()—-&gt;确保流中没有任何元素与给定的谓词匹配.以上三个操作都具有短路的特性.(当搜索的条件满足时,就不会继续下去了)findAny()—-&gt;返回当前流中的任意元素.findFirst()—-&gt;返回当前流中的第一个元素.归约将流中所以元素反复结合起来,得到一个值.这样的查询可以被归类为归约操作.(函数编程的术语为折叠)reduce(0,(a,b) -&gt; a + b);或者直接Integer里面的静态sum方法求和reduce(0,Integer::sum);或者求最大值、最小值reduce(0,Integer::min);reduce(0,Integer::max);练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static void main(String[] args) { Trader zlw1 = new Trader(\"zlw1\", \"hb\"); Trader zlw2 = new Trader(\"zlw2\", \"sz\"); Trader zlw3 = new Trader(\"zlw3\", \"hb\"); Trader zlw4 = new Trader(\"zlw4\", \"hb\"); List&lt;Transactions&gt; transactions1 = Arrays.asList( new Transactions(zlw4, 2011, 300), new Transactions(zlw1, 2012, 1000), new Transactions(zlw1, 2011, 400), new Transactions(zlw2, 2012, 710), new Transactions(zlw2, 2012, 700), new Transactions(zlw3, 2012, 950) ); //找出2011年发生的交易,并按交易排序(低到高) transactions1.stream() .filter(tran -&gt; tran.getYear() == 2011) .sorted(Comparator.comparing(Transactions::getValue)) .forEach(System.out::println); System.out.println(\"-------------------\"); //交易员在那些不同的城市工作 transactions1.stream() .map(transactions2 -&gt; transactions2.getTrader().getCity()).distinct() .forEach(System.out::println); System.out.println(\"-------------------\"); //返回所有湖北的交易员,并按姓名排序 transactions1.stream() .map(Transactions::getTrader) .filter(Trader -&gt; Trader.getCity().equals(\"hb\")) .distinct().sorted(Comparator.comparing(Trader::getName)) .forEach(System.out::println); System.out.println(\"-------------------\"); //返回所以交易员的姓名字符串,按字母排序 此方法的效率不高 其reduce()中使用String拼接 String reduce = transactions1.stream() .map(Transactions -&gt; Transactions.getTrader().getName()).distinct() .reduce(\"\", (a, b) -&gt; a + b); System.out.println(reduce); System.out.println(\"-------------------\"); //有没有在sz工作过的 boolean sz = transactions1.stream() .anyMatch(Transactions -&gt; Transactions.getTrader().getCity().equals(\"sz1\")); System.out.println(sz); System.out.println(\"-------------------\"); //打印所以在湖北的交易员的交易额 transactions1 .stream() .filter(transactions -&gt; transactions.getTrader().getCity().equals(\"hb\")) .map(Transactions::getValue) .forEach(System.out::println); System.out.println(\"-------------------\"); //输出交易中,交易额最高的交易额 Integer max = transactions1.stream() .map(Transactions::getValue) .reduce(Integer::max) .get(); System.out.println(max); System.out.println(\"-------------------\"); //最小的交易额 Integer min = transactions1.stream() .map(Transactions::getValue) .reduce(Integer::min) .get(); System.out.println(min); }数值流之前 .reduce(0, Integer::sum),有一个暗含的装箱成本,将每个Integer拆箱成一个原始类型.在进行求和,所以Stream API 提供原始类型流特化,来避免暗含的装箱成本,自动拆箱的操作. IntStream—&gt; intDoubleSteam—&gt; doubleLongStream—&gt; long1.映射到数据流mapToInt()mapToDouble()mapToLong()以上方法很之前的map()的工方式一样,只不过他们返回的是一个特化流,而不是Stream.2.转换回对象流boxed();特化流转换回非特化流.3.默认值OptionalInt如果流为空,那sum默认返回0,那你就无法区别流中是否有元素和最大值就是0的流?所以对于三个原始特化流,就分别有一个Optional原始类型特化版.OptionalIntOptionalDoubleOptionalLong数值范围第一个参数接受起始值,第二个是参数接受结束值range —&gt; 不包含结束值rangeClosed —&gt; 包含结束值构建流1.由值创建流Stream.ofexample: Streamstream = Stream.of(“java”, “c++”, “Python”, “go”);2.由数组创建流Arrays.stream(),参数传的是什么类型的,Stream就是XXXStreamint[] numbers ={1,2,3,4,5,6};int asInt = Arrays.stream(numbers).max().getAsInt();3.由文件生成流Files.lines4.由函数生成流:创建无限流没有固定的长度,根据函数按需创建值,可以无尽的计算下去.这个流是无界的Stream.iterate新生成的值应用函数title:斐波那契数列123Stream.iterate(new int[]{0,1},t -&gt; new int[]{t[1],t[0]+t[1]}) .limit(20) .forEach(t -&gt; System.out.print( t[0]+\" \"));Stream.generate","link":"/2019/12/06/java-8-stream/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"java 8","slug":"java-8","link":"/tags/java-8/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"写作","slug":"写作","link":"/tags/写作/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"SQL语言","slug":"SQL语言","link":"/tags/SQL语言/"},{"name":"好文章","slug":"好文章","link":"/tags/好文章/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"练习","slug":"练习","link":"/tags/练习/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"数据库基础和原理","slug":"数据库基础和原理","link":"/categories/数据库基础和原理/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}