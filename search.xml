<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java-8 Optional类解析</title>
      <link href="/2019/10/28/java-8-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/10/28/java-8-Optional%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。<br>新版本的Java，比如Java 8引入了一个新的Optional类。Optional类的Javadoc描述如下：</p><blockquote><p>这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p></blockquote><a id="more"></a><h4 id="of"><a href="#of" class="headerlink" title="of"></a><strong>of</strong></h4><blockquote><p>为非null的值创建一个Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//调用工厂方法创建Optional实例</span></span><br><span class="line">Optional&lt;String&gt; s = Optional.of(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"><span class="hljs-comment">//传入参数为null，抛出NullPointerException.</span></span><br><span class="line">Optional&lt;String&gt; s1 = Optional.of(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a><strong>ofNullable</strong></h4><blockquote><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况</span></span><br><span class="line"><span class="hljs-comment">//下面创建了一个不包含任何值的Optional实例</span></span><br><span class="line"><span class="hljs-comment">//例如，值为'null'</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a><strong>isPresent</strong></h4><blockquote><p>如果值存在返回true，否则返回false。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//isPresent方法用来检查Optional实例中是否包含值</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"ZLW"</span>);</span><br><span class="line">        String name = <span class="hljs-string">"zlw"</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(empty.isPresent())&#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a><strong>get</strong></h4><blockquote><p>如果Optional有值则将其返回，否则抛出NoSuchElementException。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            System.out.println(empty.get());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a><strong>ifPresent</strong></h4><blockquote><p>如果Optional实例有值则为其调用consumer，否则不做处理<br>要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。<br>如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ifPresent方法接受lambda表达式作为参数。</span></span><br><span class="line"><span class="hljs-comment">//lambda表达式对Optional的值调用consumer进行处理。</span></span><br><span class="line">empty.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a><strong>orElse</strong></h4><blockquote><p>如果有值则将其返回，否则返回指定的其它值。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 值为 null</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br><span class="line"><span class="hljs-comment">// 值为 zlw</span></span><br><span class="line">System.out.println(empty.orElse(<span class="hljs-string">"no value"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a><strong>orElseGet</strong></h4><blockquote><p>orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//orElseGet与orElse方法类似，区别在于orElse传入的是默认值，</span></span><br><span class="line"><span class="hljs-comment">//orElseGet可以接受一个lambda表达式生成默认值。</span></span><br><span class="line">System.out.println(empty.orElseGet(() -&gt; <span class="hljs-string">"no value!"</span>));</span><br></pre></td></tr></table></figure><h4 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a><strong>orElseThrow</strong></h4><blockquote><p>如果有值则将其返回，否则抛出supplier接口创建的异常。<br>在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">  <span class="hljs-comment">//orElseThrow与orElse方法类似。与返回默认值不同，</span></span><br><span class="line">  <span class="hljs-comment">//orElseThrow会抛出lambda表达式或方法生成的异常 </span></span><br><span class="line"></span><br><span class="line">  empty.orElseThrow(ValueAbsentException::<span class="hljs-keyword">new</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="hljs-comment">//输出: No value present in the Optional instance</span></span><br><span class="line">  System.out.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ValueAbsentException定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueAbsentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Throwable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueAbsentException</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"No value present in the Optional instance"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a><strong><font color="red">map</font></strong></h4><blockquote><p>如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//map方法执行传入的lambda表达式参数对Optional实例的值进行修改。</span></span><br><span class="line"><span class="hljs-comment">//为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; newempty = empty.map((value) -&gt; value.toUpperCase());</span><br><span class="line">System.out.println(newempty.orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h4><blockquote><p>如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//flatMap与map（Function）非常类似，区别在于传入方法的lambda表达式的返回类型。</span></span><br><span class="line"><span class="hljs-comment">//map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 </span></span><br><span class="line"><span class="hljs-comment">//但flatMap方法中的lambda表达式返回值必须是Optionl实例。 </span></span><br><span class="line"> Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line"> System.out.println(empty.flatMap((value) -&gt; Optional.of(value.toUpperCase())).orElseGet(() -&gt; <span class="hljs-string">"no value!!"</span>));</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h4><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p><blockquote><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。<br>可能你已经知道如何为filter方法传入一段代码。是的，这里可以传入一个lambda表达式。对于filter函数我们应该传入实现了Predicate接口的lambda表达式。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//filter方法检查给定的Option值是否满足某些条件。</span></span><br><span class="line"><span class="hljs-comment">//如果满足则返回同一个Option实例，否则返回空Optional。</span></span><br><span class="line">Optional&lt;String&gt; empty = Optional.ofNullable(<span class="hljs-string">"zlw"</span>);</span><br><span class="line">Optional&lt;String&gt; s = empty.filter((value) -&gt; value.length() &gt; <span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(s.orElse(<span class="hljs-string">"The name is less than 6 characters"</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-8 lambda 2</title>
      <link href="/2019/10/26/java-8-lambda-2/"/>
      <url>/2019/10/26/java-8-lambda-2/</url>
      
        <content type="html"><![CDATA[<p>关于函数式接口:</p><h5 id="1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。"><a href="#1-如果一个接口只有一个抽象方法-那么该接口就是一个函数式接口。" class="headerlink" title="1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。"></a>1.如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。</h5><h5 id="2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。"><a href="#2-如果我们在某个接口上声明了-FunctionInterface注解-那么编译器就会按照函数式接口的定义来要求该接口。" class="headerlink" title="2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。"></a>2.如果我们在某个接口上声明了@FunctionInterface注解,那么编译器就会按照函数式接口的定义来要求该接口。</h5><h5 id="3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。"><a href="#3-如果某个接口只有一个抽象方法-但我们并没有给该接口声明-FunctionInterface注解-那么编译器依旧会将该接口看作是函数式接口。" class="headerlink" title="3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。"></a>3.如果某个接口只有一个抽象方法,但我们并没有给该接口声明@FunctionInterface注解,那么编译器依旧会将该接口看作是函数式接口。</h5><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterfae</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-comment">// java.lang.Object 是所以类的父类 MyInterfae的实现类一点会直接或者间接的继承Object类 toString</span></span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他有lambda表达式语言中,lambda表达式的类型是函数,但在java中，Lambda表达式是对象,他们必须依附于一类特别的对象类型————函数式接口(functional interface)</p><h3 id="外部迭代"><a href="#外部迭代" class="headerlink" title="外部迭代"></a><strong>外部迭代</strong></h3><p>最传统的方法是用Iterator，当然还以用for i、增强for循环等等。这一类方法叫做外部迭代，意为显式地进行迭代操作，即集合中的元素访问是由一个处于集合外部的东西来控制的，在这里控制着循环的东西就是迭代器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = Arrays.asList(<span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"d"</span> &#125;);</span><br><span class="line"><span class="hljs-keyword">for</span> (String letter : alphabets) &#123;</span><br><span class="line">    System.out.println(letter.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部迭代"><a href="#内部迭代" class="headerlink" title="内部迭代"></a><strong>内部迭代</strong></h3><p>顾名思义，这种方式的遍历将在集合内部进行，我们不会显式地去控制这个循环。无需关心遍历元素的顺序，我们只需要定义对其中每一个元素进行什么样的操作。注意在这种设定下可能无法直接获取到当前元素的下标。<br>比如JDK8提供的最新的Collection.forEach(…)方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alphabets.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a><strong>Function接口</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 代表这一个方法，能够接受一个参数，并且返回一个结果</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.8</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 将参数赋予给相应方法</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 先执行参数(即也是一个Function)的，再执行调用者(同样是一个Function)</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 先执行调用者，再执行参数，和compose相反。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 返回当前正在执行的方法</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[例子]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextIDEA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TextIDEA TextIDEA = <span class="hljs-keyword">new</span> TextIDEA();</span><br><span class="line">        System.out.println(TextIDEA.compute(<span class="hljs-number">2</span>,(value) -&gt; value * <span class="hljs-number">3</span>,(value) -&gt; value * value)); <span class="hljs-comment">// 12</span></span><br><span class="line">        System.out.println(TextIDEA.compute1(<span class="hljs-number">2</span>,(value) -&gt; value * <span class="hljs-number">3</span>,(value) -&gt; value * value));<span class="hljs-comment">// 36</span></span><br><span class="line">        System.out.println(TextIDEA.compute2(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,(value1,value2) -&gt; value1 * value2)); <span class="hljs-comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, Function&lt;Integer,Integer&gt; function1, Function&lt;Integer,Integer&gt; function2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compute2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b, BiFunction&lt;Integer,Integer,Integer&gt; biFunction)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> biFunction.apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-comment">//唯一的抽象方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//且操作，既满足A也满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//且操作，既满足A也满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//或操作，满足A条件或者满足B条件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//静态方法，判定是否相等</span></span><br><span class="line">    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Predicate-1"><a href="#Predicate-1" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *这个接口是一个提供者的意思，只有一个get的抽象类，</span></span><br><span class="line"><span class="hljs-comment"> *没有默认的方法以及静态的方法，传入一个泛型T的，get方法，返回一个泛型T</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BinaryOperator"><a href="#BinaryOperator" class="headerlink" title="BinaryOperator"></a><strong>BinaryOperator</strong></h3><p>BinaryOperator:对同一类型的两个参数的操作比较操作,返回的和传入参数时相同的 ;<br>binaryOperator 继承制BiFunciton<br>方法1: minBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最小的对象<br>方法1: maxBy(comparator):返回的是一个binaryoperator函数接口 函数返回一个最大的对象</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 后缀补全</title>
      <link href="/2019/10/26/IDEA-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8/"/>
      <url>/2019/10/26/IDEA-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>IDEA 有个很厉害的功能，那就是后缀补全（不是自动补全），<br>这个功能可以使用代码补全来模板式地补全语句，如遍历循环语句（for、foreach）、使用 String.format() 包裹一个字符串、使用类型转化包裹一个表达式、根据判（非）空或者其它判别语句生成 if 语句、用 instanceOf 生成分支判断语句等。</p><p>使用的方式也很简单，就是在一个表达式后按下点号 . ，然后输入一些提示或者在列表中选择一个候选项，常见的候选项下面会给出 GIF 演示。</p><a id="more"></a><ol><li><h3 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a><strong>var 声明</strong></h3><p><img src="/images/IDEA/var.gif" alt></p></li><li><h3 id="null判断"><a href="#null判断" class="headerlink" title="null判断"></a><strong>null判断</strong></h3><p><img src="/images/IDEA/null.gif" alt></p></li><li><h3 id="notnull判断"><a href="#notnull判断" class="headerlink" title="notnull判断"></a><strong>notnull判断</strong></h3><p><img src="/images/IDEA/notnull.gif" alt></p></li><li><h3 id="nn判断"><a href="#nn判断" class="headerlink" title="nn判断"></a><strong>nn判断</strong></h3><p><img src="/images/IDEA/nn.gif" alt></p></li><li><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><p><img src="/images/IDEA/if.gif" alt></p></li><li><h3 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h3><p><img src="/images/IDEA/return.gif" alt></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 - 函数编程（lambda表达式）</title>
      <link href="/2019/10/25/Java-8-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%EF%BC%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/"/>
      <url>/2019/10/25/Java-8-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%EF%BC%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p><strong>超过3行的逻辑就不适用Lambda表达式了</strong>。虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖(用更简练的言语表达较复杂的含义)”,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。本人建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘.)<br>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口.lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。</p><a id="more"></a><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h3><blockquote><p><font color="orange">(parameters) -&gt; expression</font><br>或(请注意语句的花括号)<br><font color="green">(parameters) -&gt; {expression}</font></p></blockquote><p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：<br>public int add(int x, int y) {<br>return x + y;<br>}<br>转成λ表达式后是这个样子：<br>(int x, int y) -&gt; x + y;<br>参数类型也可以省略，Java编译器会根据上下文推断出来：<br>(x, y) -&gt; x + y; //返回两数之和<br>或者<br>(x, y) -&gt; { return x + y; } //显式指明返回值<br>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。<br>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：<br>() -&gt; { System.out.println(“Hello Lambda!”); }<br>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：<br>c -&gt; { return c.size(); }</p><figure class="highlight java hljs"><figcaption><span>[lambda简单例子]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1.不需要参数 返回值 7</span></span><br><span class="line">() -&gt; <span class="hljs-number">7</span></span><br><span class="line"><span class="hljs-comment">// 2. 接受两个int类型参数 返回值 为 两者之和</span></span><br><span class="line">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y) -&gt; x+y</span><br><span class="line"><span class="hljs-comment">// 3. 接受一个string类型参数,并进行打印,没有返回值</span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[循环输出]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 随便定义的数据</span></span><br><span class="line">        String[] str = &#123;<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"joe"</span>,<span class="hljs-string">"qjl"</span>,<span class="hljs-string">"lxl"</span>,<span class="hljs-string">"zc"</span>,<span class="hljs-string">"sam"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; players = Arrays.asList(str);</span><br><span class="line">        <span class="hljs-comment">// 以前的循环方式</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (String player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="hljs-string">"--------------"</span>);</span><br><span class="line">        <span class="hljs-comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">        players.forEach((player) -&gt; System.out.println(player));</span><br><span class="line">        System.out.println(<span class="hljs-string">"--------------"</span>);</span><br><span class="line">        <span class="hljs-comment">// 在 Java 8 中使用双冒号操作符(double colon operator)</span></span><br><span class="line">        players.forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>[使用lambdas 来实现 Runnable接口]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 使用匿名内部类 1.1</span></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"Hello lambda1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式1.2</span></span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Hello lambda2"</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用匿名内部类 2.1</span></span><br><span class="line">        Runnable hello_zlw_lambda1 = <span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"Hello zlw lambda1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式2.2</span></span><br><span class="line">        Runnable hello_zlw_lambda2 = () -&gt; System.out.println(<span class="hljs-string">"Hello zlw lambda2"</span>);</span><br><span class="line">        </span><br><span class="line">        hello_zlw_lambda1.run();</span><br><span class="line">        hello_zlw_lambda2.run();</span><br></pre></td></tr></table></figure><p><strong>使用Lambdas排序集合</strong><br>在Java中,Comparator 类被用来排序集合。 在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1.1 使用匿名内部类根据 name 排序</span></span><br><span class="line">String[] players = &#123;<span class="hljs-string">"zlw"</span>,<span class="hljs-string">"joe"</span>,<span class="hljs-string">"qjl"</span>,<span class="hljs-string">"lxl"</span>,<span class="hljs-string">"zc"</span>,<span class="hljs-string">"sam"</span>&#125;;</span><br><span class="line">Arrays.sort(players, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (o1.compareTo(o2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">Comparator&lt;String&gt; sortName = (String o1, String o2) -&gt; o1.compareTo(o2);</span><br><span class="line">Arrays.sort(players,sortName);</span><br><span class="line"></span><br><span class="line">Arrays.sort(players,(String o1,String o2) -&gt; o1.compareTo(o2));</span><br><span class="line">System.out.println(Arrays.toString(players));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平时看的好文章</title>
      <link href="/2019/10/24/%E5%B9%B3%E6%97%B6%E7%9C%8B%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
      <url>/2019/10/24/%E5%B9%B3%E6%97%B6%E7%9C%8B%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>技术人员的发展之路 –陈皓<br><a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17583.html</a></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法的知识体系</title>
      <link href="/2019/10/24/%E7%AE%97%E6%B3%95%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2019/10/24/%E7%AE%97%E6%B3%95%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>算法：<br>1、排序算法：快速排序、归并排序、计数排序<br>2、搜索算法：回溯、递归、剪枝<br>3、图论：最短路径、最小生成树、网络流建模<br>4、动态规划：背包问题、最长子序列、计数问题<br>5、基础技巧：分治、倍增、二分法、贪心算法</p><a id="more"></a><p>数据结构：<br>1、数组和链表<br>2、栈与队列<br>3、树和图<br>4、哈希表<br>5、大/小跟堆，可并堆<br>6、字符串：字典树、后缀树</p><p><img src="/images/alg-overview.png" alt></p><h1 id="两个刷算法题的网站"><a href="#两个刷算法题的网站" class="headerlink" title="两个刷算法题的网站"></a>两个刷算法题的网站</h1><ul><li><a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></li><li><a href="https://www.lintcode.com/problem/" target="_blank" rel="noopener">https://www.lintcode.com/problem/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+coding+github加速博客访问</title>
      <link href="/2019/10/24/Hexo-coding-github%E5%8A%A0%E9%80%9F%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/"/>
      <url>/2019/10/24/Hexo-coding-github%E5%8A%A0%E9%80%9F%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<p>之前使用Hexo+github建立后访问博客速慢,是因为github服务器在国外，可能访问量太大，国内访问速度有些慢;<br>然后改用coding 托管代码</p><a id="more"></a><h1 id="什么是coding？"><a href="#什么是coding？" class="headerlink" title="什么是coding？"></a><strong>什么是coding？</strong></h1><p>简单的说coding就是类似于github的开源代码仓库，几乎是完全仿照github做的；虽然现在代码量并不多，但是部分地方还是比github方便一些的：</p><ul><li>中文界面，对我们来用起来更加方便；</li><li>可以免费创建私有仓库；</li><li>虽然服务器也在国外，但访问速度比github要快不少</li></ul><h1 id="注册coding并创建项目"><a href="#注册coding并创建项目" class="headerlink" title="注册coding并创建项目"></a><strong>注册coding并创建项目</strong></h1><p>这一部分很简单，不多说。需要注意的是创建项目的时候项目名称跟我们在github上创建时候类似，<br>项目名一定要是：用户名 + coding.me<br>创建Coding项目<br>创建完成之后，先完成下一步在进行其他步骤</p><h1 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a><strong>配置SSH Key</strong></h1><p>只是把其中的添加SSH key添加到GitHub的步骤换成下面的就行,添加SSH key到Coding<br>将上面生产的id_rsa.pub中的内容<br>添加SSH Key到Coding<br>coding 　　---&gt; 个人账户　　 ---&gt; SSH公钥 　　 ---&gt; 添加公钥<br>测试SSH Key 是否配置成功</p><figure class="highlight plain hljs"><figcaption><span>[git bash]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h1 id="Hexo部署添加Coding仓库"><a href="#Hexo部署添加Coding仓库" class="headerlink" title="Hexo部署添加Coding仓库"></a><strong>Hexo部署添加Coding仓库</strong></h1><p>修改Hexo博客目录下的站点配置文件_config.yml中的部署配置</p><figure class="highlight plain hljs"><figcaption><span>[_config.yml]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https://github.com/ZlwPick/ZlwPick.github.io.git</span><br><span class="line">    coding: https://e.coding.net/zlwblog/zlw.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>重新执行Hexo部署命令，此时就会将Hexo博客部署到GitHub和Coding上了<br>hexo d<br>部署结束之后，Coding项目master分支下面就会有代码了<br>左侧菜单 　　---&gt; 部署 　　---&gt; 静态网址 　　---&gt; 把代码库里面的项目部署一下</p><h1 id="配置域名分流解析"><a href="#配置域名分流解析" class="headerlink" title="配置域名分流解析"></a><strong>配置域名分流解析</strong></h1><p><img src="/images/dns%E8%A7%A3%E6%9E%90.png" alt><br>dns修改之后需要一点时间刷新,之后在静态网页设置里面申请SSL证书(一定先把DNS中GitHub的解析关了,要不然申请失败),在下方打开https</p><h1 id="自动最小化静态文件"><a href="#自动最小化静态文件" class="headerlink" title="自动最小化静态文件"></a><strong>自动最小化静态文件</strong></h1><p>Chrome 开发者工具中提供的 Network 选项卡可以很方便的检测整个网站的文件传输情况。<br>通过输入 domain:kaitohh.com 筛选仅来自于源站的文件，可以看到所有来自于源站的文件及大小。<br>可以发现绝大部分文件都是一些网站本身的 CSS 和 JS，最大的文件是当前网站的 HTML 代码，这些文件由于经常会发生变动，<br>因此不能直接存在对象存储中。接下来，逐个预览这些文件，发现这些文件居然都没有最小化！<br>安装插件 <a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">https://github.com/chenzhutian/hexo-all-minifier</a></p><blockquote><p>$ npm install hexo-all-minifier –save</p></blockquote><p>_config.yml</p><blockquote><p>all_minifier: true</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 58.Length of Last Word</title>
      <link href="/2019/10/23/LeetCode-58-Length-of-Last-Word/"/>
      <url>/2019/10/23/LeetCode-58-Length-of-Last-Word/</url>
      
        <content type="html"><![CDATA[<h1 id="Length-of-Last-Word-最后一个单词长度"><a href="#Length-of-Last-Word-最后一个单词长度" class="headerlink" title="Length of Last Word(最后一个单词长度)"></a><strong>Length of Last Word(最后一个单词长度)</strong></h1><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。<br>如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指由字母组成，但不包含任何空格的字符串。<br><strong>示例</strong></p><blockquote><p><strong>输入:</strong> “Hello World”<br><strong>输出: 5</strong></p></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接从字符串最后开始先前找,总长度–,找到后记录那就是’ ‘之前的长度,再去用　　<br>总长度 - 去’ ‘之前的长度　=　最后一个单词的长度</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(s==<span class="hljs-keyword">null</span> || s.length()==<span class="hljs-number">0</span>)</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">String trim = s.trim();　　<span class="hljs-comment">//去掉字符串两边的' '空格</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(trim.length()==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="hljs-keyword">int</span> n = trim.length() -<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (n&gt;=<span class="hljs-number">0</span> &amp;&amp; trim.charAt(n)!=<span class="hljs-string">' '</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> trim.length() - <span class="hljs-number">1</span> -n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 语言 - 基础</title>
      <link href="/2019/10/23/SQL-%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/10/23/SQL-%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>基础</strong></li></ul><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><a id="more"></a><figure class="highlight sql hljs"><figcaption><span>[注释]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## 注释</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable 　　　<span class="hljs-comment">-- 注释</span></span><br><span class="line"><span class="hljs-comment">/*注释1</span></span><br><span class="line"><span class="hljs-comment">　注释2 */</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[数据库的创建与使用]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> zlwdb;</span><br><span class="line"><span class="hljs-keyword">USE</span> zlwdb;</span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[创建表与修改表]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable(</span><br><span class="line"> uid <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> z1 <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,</span><br><span class="line"> z2 <span class="hljs-built_in">INT</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,</span><br><span class="line"> z3 <span class="hljs-built_in">DATE</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="hljs-keyword">KEY</span>(<span class="hljs-string">'id'</span>) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">##修改表</span></span><br><span class="line"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable</span><br><span class="line"><span class="hljs-keyword">ADD</span> z4 <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>);</span><br><span class="line"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable</span><br><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> z4;</span><br><span class="line"><span class="hljs-comment">##删除表</span></span><br><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[插入,更新,删除]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mytable(z1,z2) <span class="hljs-keyword">VALUES</span>(va11,val2);</span><br><span class="line"><span class="hljs-comment">## 插入检索出来的数据</span></span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mytable1(z1,z2) <span class="hljs-keyword">SELECT</span> z1,z2 <span class="hljs-keyword">FROM</span> mytable2;</span><br><span class="line"><span class="hljs-comment">## 一个表的内容插入到一个新表</span></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> newtable <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">UPDATE</span> mytable <span class="hljs-keyword">SET</span> z1 = va11 <span class="hljs-keyword">WHERE</span> uid = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">WHERE</span> uid = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> mytable; <span class="hljs-comment">--也可以清空表，也就是删除所有行</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[查询]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">##DISTINCT --去重复，相同的值只会显示一次</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> z1,z2, <span class="hljs-keyword">FROM</span> mytable;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">##LIMIT -- 限制返回的行数,可以有两个参数,1.起始行2. 返回的总行数</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>,<span class="hljs-number">3</span>; <span class="hljs-comment">-- 从第3行到第第5行</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[排序]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## ASC 升序(默认)  DESC 降序</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> z1 <span class="hljs-keyword">DESC</span>, z2 <span class="hljs-keyword">ASC</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[过滤]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">WHERE</span> z1 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>单元格</td><td>单元格</td></tr><tr><td>&lt; 　&gt;</td><td>小于 　　大于</td></tr><tr><td>&lt;&gt;!= 　　 &lt;=!&gt;　　&gt;=!&lt;</td><td>不等于　　小于等于　　大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为NULL值</td></tr></tbody></table><p><strong>AND</strong> 和<strong>OR</strong> 用于连接多个过滤条件。优先处理 <strong>AND</strong>，当一个过滤表达式涉及到多个 <strong>AND</strong> 和 <strong>OR</strong> 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong> 操作符用于否定一个条件。</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><p>% 匹配 &gt;=0 个任意字符；</p><p>_ 匹配 ==1 个任意字符；</p><p>[ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p><p>使用 Like 来进行通配符匹配。<strong>不要滥用通配符，通配符位于开头处匹配会非常慢。</strong></p><figure class="highlight sql hljs"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">WHERE</span> z1 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'[^AB]'</span> <span class="hljs-comment">--不以 A 和 B 开头的文本</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><figcaption><span>[计算字段]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> z1 * z2 <span class="hljs-keyword">AS</span> xj <span class="hljs-keyword">FROM</span> mytable;</span><br><span class="line"><span class="hljs-comment">##CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，</span></span><br><span class="line"><span class="hljs-comment">##因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(<span class="hljs-keyword">TRIM</span>(z1), <span class="hljs-string">'('</span>, <span class="hljs-keyword">TRIM</span>(z2), <span class="hljs-string">')'</span>) <span class="hljs-keyword">AS</span> concat_z</span><br><span class="line"><span class="hljs-keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2 id="函数-MYSQL"><a href="#函数-MYSQL" class="headerlink" title="函数(MYSQL)"></a>函数(MYSQL)</h2><table><tr><th>函数</th><th>说明(列)</th></tr><tr><th>AVG()</th><th>平均值</th></tr><tr><th>COUNT()</th><th>行数</th></tr><tr><th>MAX()　　 MIN()</th><th>最大值　　最小值</th></tr><tr><th>SUM()</th><th>和</th></tr><tr><th>LEFT()　　 RIGHT()</th><th>左边的字符　　 右边的字符</th></tr><tr><th>LOWER()　　 UPPER()</th><th>转为小写字符　　 转为大写字符</th></tr><tr><th>LTRIM()　　 RTRIM()</th><th>去除左边的空格　　 去除右边的空格</th></tr></table><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a><strong><font color="red">分组</font></strong></h2><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql hljs"><figcaption><span>[分组]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> z1,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SUM</span> <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> z1;</span><br><span class="line"><span class="hljs-comment">##GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</span></span><br><span class="line"><span class="hljs-comment">##WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</span></span><br><span class="line"><span class="hljs-keyword">SELECT</span> z1,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> mytable <span class="hljs-keyword">WHERE</span> z1 &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> z1 <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">num</span> &gt;= <span class="hljs-number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>分组规定：</strong></p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li></ul><h1 id="未写完"><a href="#未写完" class="headerlink" title="未写完"></a><font color="green">未写完</font></h1><figure class="highlight sql hljs"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库基础和原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 66.Plus One</title>
      <link href="/2019/10/22/LeetCode-66-Plus-One/"/>
      <url>/2019/10/22/LeetCode-66-Plus-One/</url>
      
        <content type="html"><![CDATA[<h1 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a><strong>Plus One</strong></h1><p><strong>题目描述:</strong><br>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><a id="more"></a><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,2,3]<br><strong>输出:</strong> [1,2,4]<br><strong>解释:</strong> 输入数组表示数字 123。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [4,3,2,1]<br><strong>输出:</strong> [4,3,2,2]<br><strong>解释:</strong> 输入数组表示数字 4321。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = digits.length;</span><br><span class="line">        <span class="hljs-keyword">int</span>[] temp = digits;</span><br><span class="line">        <span class="hljs-comment">// 判断最后一位是否进位</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(temp[len-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>==<span class="hljs-number">10</span>)&#123;</span><br><span class="line">            temp[len-<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;</span><br><span class="line">            flag = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            temp[len-<span class="hljs-number">1</span>]+=<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(flag &amp;&amp; temp[i]+<span class="hljs-number">1</span>==<span class="hljs-number">10</span>)&#123;  <span class="hljs-comment">// 判断当前位是否有进位</span></span><br><span class="line">                temp[i]=<span class="hljs-number">0</span>;</span><br><span class="line">                flag = <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag)&#123; <span class="hljs-comment">// 当前位没有进位加一退出</span></span><br><span class="line">                temp[i]+=<span class="hljs-number">1</span>;</span><br><span class="line">                flag = <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">           例如 [9,9]</span></span><br><span class="line"><span class="hljs-comment">           个位进位 0</span></span><br><span class="line"><span class="hljs-comment">           十位进位 1+9=0</span></span><br><span class="line"><span class="hljs-comment">           但退出循环了,不能在进位了,数组长度要扩位+1</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (flag &amp;&amp; temp[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>];</span><br><span class="line">            res[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 20.Valid Paretheses</title>
      <link href="/2019/10/22/LeetCode-20-Valid-Paretheses/"/>
      <url>/2019/10/22/LeetCode-20-Valid-Paretheses/</url>
      
        <content type="html"><![CDATA[<h1 id="Valid-Paretheses-有效的括号"><a href="#Valid-Paretheses-有效的括号" class="headerlink" title="Valid Paretheses(有效的括号)"></a><strong>Valid Paretheses(有效的括号)</strong></h1><p><strong>题目描述:</strong><br>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><blockquote><p>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p></blockquote><a id="more"></a><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “()”<br><strong>输出:</strong> true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “()[]{}”<br><strong>输出:</strong> true</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “(]”<br><strong>输出:</strong> false</p></blockquote><p><strong>示例 4:</strong></p><blockquote><p><strong>输入:</strong> “([)]”<br><strong>输出:</strong> false</p></blockquote><p><strong>示例 5:</strong></p><blockquote><p><strong>输入:</strong> “{[]}”<br><strong>输出:</strong> true</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">       Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">'('</span> || s.charAt(i) == <span class="hljs-string">'&#123;'</span> || s.charAt(i) == <span class="hljs-string">'['</span>) &#123;</span><br><span class="line">               stack.push(s.charAt(i));</span><br><span class="line">           &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">               <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">               &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                   <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-string">'&#123;'</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">'&#125;'</span>) &#123;</span><br><span class="line">                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-string">'('</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">')'</span>) &#123;</span><br><span class="line">                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-string">'['</span> &amp;&amp; s.charAt(i) != <span class="hljs-string">']'</span>) &#123;</span><br><span class="line">                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="hljs-keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 13.Roman to Integer</title>
      <link href="/2019/10/21/LeetCode-13-Roman-to-Integer/"/>
      <url>/2019/10/21/LeetCode-13-Roman-to-Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a><strong>Roman to Integer</strong></h1><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><blockquote><p>字符　　　数值<br>I 　　　　　1<br>V 　　　　　5<br>X 　　　　　10<br>L 　　　　　50<br>C 　　　　　100<br>D 　　　　　500<br>M 　　　　　1000</p></blockquote><a id="more"></a><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p></blockquote><p><strong>示例 4:</strong></p><blockquote><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p></blockquote><p><strong>示例 5:</strong></p><blockquote><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="hljs-string">'I'</span>,<span class="hljs-number">1</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'V'</span>,<span class="hljs-number">5</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'X'</span>,<span class="hljs-number">10</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'L'</span>,<span class="hljs-number">50</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'C'</span>,<span class="hljs-number">100</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'D'</span>,<span class="hljs-number">500</span>);</span><br><span class="line">        map.put(<span class="hljs-string">'M'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; map.get(s.charAt(i)) &gt; map.get(s.charAt(i-<span class="hljs-number">1</span>)))&#123;</span><br><span class="line">                result += map.get(s.charAt(i)) - <span class="hljs-number">2</span> * map.get(s.charAt(i-<span class="hljs-number">1</span>));</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                result += map.get(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 7.Reverse Integer</title>
      <link href="/2019/10/21/LeetCode-7-Reverse-Integer/"/>
      <url>/2019/10/21/LeetCode-7-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a><strong>Reverse Integer</strong></h1><p><strong>题目描述:</strong><br>给定一个32位有符号整数，将整数中的数字进行反转</p><p><strong>示例1:</strong><br><strong>输入:</strong>123<br><strong>输入:</strong>321</p><a id="more"></a><p><strong>示例2:</strong><br><strong>输入:</strong>-123<br><strong>输入:</strong>-321</p><p><strong>示例3:</strong><br><strong>输入:</strong>120<br><strong>输入:</strong>21</p><p><strong>注意:</strong><br>假设我们的环境只能存储32位有符号整数，其数值范围是[-2^31 , 2^31 -1],如果反转后的整数溢出，返回0.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (x!=<span class="hljs-number">0</span>)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;  <span class="hljs-comment">// 取x的最后一位</span></span><br><span class="line">        x /= <span class="hljs-number">10</span>;           <span class="hljs-comment">// 删除X的最后一位</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(rev &gt; Integer.MAX_VALUE / <span class="hljs-number">10</span> || rev &lt; Integer.MIN_VALUE /<span class="hljs-number">10</span>)  <span class="hljs-comment">//溢出判断</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        rev = rev * <span class="hljs-number">10</span> + pop; <span class="hljs-comment">//之前的数值向前推进1位加上当前数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zlwblog.cn" target="_blank" rel="noopener">https://zlwblog.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 常用的快捷键</title>
      <link href="/2019/10/20/IDEA-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/10/20/IDEA-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一键格式化代碼：-Ctrl-Alt-L"><a href="#一键格式化代碼：-Ctrl-Alt-L" class="headerlink" title="一键格式化代碼： Ctrl+Alt+L"></a>一键格式化代碼： Ctrl+Alt+L</h1><h1 id="全局搜索替换：ctrl-shift-r"><a href="#全局搜索替换：ctrl-shift-r" class="headerlink" title="全局搜索替换：ctrl+shift+r"></a>全局搜索替换：ctrl+shift+r</h1><h1 id="强大的搜索功能，shift-shift-无论您想要搜啥都能找到"><a href="#强大的搜索功能，shift-shift-无论您想要搜啥都能找到" class="headerlink" title="强大的搜索功能，shift+shift (无论您想要搜啥都能找到)"></a>强大的搜索功能，shift+shift (无论您想要搜啥都能找到)</h1><h3 id="ctrl-shift-R-搜索类-emsp-emsp-CTRL-N：按照类名搜索类"><a href="#ctrl-shift-R-搜索类-emsp-emsp-CTRL-N：按照类名搜索类" class="headerlink" title="ctrl+shift+R:搜索类   &emsp;&emsp;   CTRL+N：按照类名搜索类"></a>ctrl+shift+R:搜索类 &emsp;&emsp; CTRL+N：按照类名搜索类</h3><a id="more"></a><ul><li><h1 id="常规"><a href="#常规" class="headerlink" title="[常规]"></a>[常规]</h1><blockquote><p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 - 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行<br>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-“，当前方法展开、折叠<br>Ctrl+Shift+”+/-“，全部展开、折叠</p></blockquote></li><li><h1 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="[调试部分、编译]"></a>[调试部分、编译]</h1><blockquote><p>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器</p></blockquote></li><li><h1 id="重构"><a href="#重构" class="headerlink" title="[重构]"></a>[重构]</h1><blockquote><p>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联</p></blockquote></li><li><h1 id="查找"><a href="#查找" class="headerlink" title="[查找]"></a>[查找]</h1><blockquote><p>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p></blockquote></li><li><h1 id="VCS"><a href="#VCS" class="headerlink" title="[VCS]"></a>[VCS]</h1><blockquote><p>Alt+~，VCS 操作菜单<br>Ctrl+K，提交更改<br>Ctrl+T，更新项目<br>Ctrl+Alt+Shift+D，显示变化</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1.Two Sum</title>
      <link href="/2019/10/20/LeetCode-1-Two-Sum/"/>
      <url>/2019/10/20/LeetCode-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><strong>Two Sum</strong></h1><p><strong>题目描述:</strong><br>给定一个整数数组和一个目标值,找出数组中和为目标值的 <strong>两个</strong> 数<br>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>示例</strong><br>给定 nums = [2,7,11,15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回[0,1]</p><a id="more"></a><ul><li><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight java hljs"><figcaption><span>[暴力破解法]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] Solution(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (target == nums[i] + nums[j])</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"not two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight java hljs"><figcaption><span>[一遍哈希表]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] Solution2(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(nums[i], i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"No two sum solution"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown操作</title>
      <link href="/2019/10/19/Markdown%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/10/19/Markdown%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Markdownd是一种轻量级的标记语言<br>Markdownd编写的文档后缀为.md,.markdown</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><a id="more"></a><ul><li><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h1><h1 id="我是一级标题"><a href="#我是一级标题" class="headerlink" title="我是一级标题"></a>我是一级标题</h1>我是二级标题</li></ul><hr><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><figure class="highlight plain hljs"><figcaption><span>[格式]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============</span><br><span class="line">------------</span><br><span class="line">#</span><br><span class="line">##</span><br><span class="line">###</span><br><span class="line">1-6个# 表示1-6级标题</span><br></pre></td></tr></table></figure><ul><li><h1 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a><strong>段落格式</strong></h1></li></ul><p>1.末尾添加两个空格<br>2.使用空行来换行</p><ul><li><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h1><figure class="highlight plain hljs"><figcaption><span>[字体格式]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*斜体字体*</span><br><span class="line">_斜体字体_</span><br><span class="line">**粗体字体**</span><br><span class="line">__粗体字体__</span><br><span class="line">***粗斜体字体***</span><br><span class="line">___粗斜体字体___</span><br></pre></td></tr></table></figure></li></ul><p><em>斜体字体</em><br><em>斜体字体</em><br><strong>粗体字体</strong><br><strong>粗体字体</strong><br><strong><em>粗斜体字体</em></strong><br><strong><em>粗斜体字体</em></strong></p><ul><li><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a><strong>分割线</strong></h1><figure class="highlight plain hljs"><figcaption><span>[分割线格式]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------</span><br></pre></td></tr></table></figure></li></ul><hr><hr><ul><li><h1 id="删除线和下划线和脚注"><a href="#删除线和下划线和脚注" class="headerlink" title="删除线和下划线和脚注"></a><strong>删除线和下划线和脚注</strong></h1><del>zlwblog</del><br><u>zlwBLOG</u></li></ul><p>zlwblog1</p><p>这是一个脚注<a href="周李伟!!!">^123</a>这是一个脚注</p><ul><li><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h1></li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ol><li>1</li><li>2</li><li>3</li><li>第一项<ul><li>1.1</li><li>1.2</li></ul></li><li>第二项<ul><li>2.1</li><li>2.2<br>结束</li></ul></li></ol><ul><li><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a><strong>区块</strong></h1><blockquote><p>zzzzzz<br>llllll<br>wwwwwww<br>z</p></blockquote></li></ul><blockquote><p>1</p><blockquote><p>2</p><blockquote><p>3</p></blockquote></blockquote></blockquote><ul><li>1<blockquote><p>1.1<br>1.2</p></blockquote></li><li>2</li></ul><ul><li><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><p><code>printf()</code>函数</p><figure class="highlight plain hljs"><figcaption><span>test()&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 111;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h1 id="支持HTML元素"><a href="#支持HTML元素" class="headerlink" title="支持HTML元素"></a><strong>支持HTML元素</strong></h1><p><a href="https://github/ZlwPick" target="_blank" rel="noopener">https://github/ZlwPick</a><br><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd>重启电脑</p></li></ul><p>转义 *</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>练习hexo的发布</title>
      <link href="/2019/10/18/%E7%BB%83%E4%B9%A0hexo%E7%9A%84%E5%8F%91%E5%B8%83/"/>
      <url>/2019/10/18/%E7%BB%83%E4%B9%A0hexo%E7%9A%84%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain hljs"><figcaption><span>[title] [] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:  #文章标题</span><br><span class="line">date:  #时间，一般不用改</span><br><span class="line">categories:  #目录分类</span><br><span class="line">tags:  #标签，格式可以是[Hexo,总结]，中间用英文逗号分开</span><br><span class="line">keywords:  #文章关键词，多个关键词用英文逗号隔开</span><br><span class="line">---</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><h1>插入图片的方法</h1><h3><b>绝对路径</b></h3>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source/images/image.jpg</span><br><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>图片既可以在首页内容中访问到，也可以在文章正文中访问到。<p>相对路径<br>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。<br>_config.yml</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。<br>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/zlwzlw.jpg" alt></p><figure class="highlight java hljs"><figcaption><span>Time.java</span><a href="/downloads/code//hexolx/Time.java">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zlw</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2019-09-11 22:53</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Time</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        doSomeThing();</span><br><span class="line">        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="hljs-string">"===================="</span>);</span><br><span class="line">        System.out.println( (endTime - startTime)+<span class="hljs-string">"ms"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span></span>{</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) {</span><br><span class="line">                System.out.println(i * j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zzz</title>
      <link href="/2019/06/24/%E5%91%A8%E6%9D%8E%E4%BC%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/06/24/%E5%91%A8%E6%9D%8E%E4%BC%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><figure class="highlight plain hljs"><figcaption><span>[title] [] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code snippet</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/23/hello-world/"/>
      <url>/2019/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
